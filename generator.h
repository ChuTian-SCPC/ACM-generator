// ==================================================
// Auto-generated by xmake amalgamate
// Time: 2025-12-27 08:06:03
// ==================================================
#ifndef _SGPCET_
#define _SGPCET_
#ifndef _SGPCET_COMMON_H_
#define _SGPCET_COMMON_H_

#include"testlib.h"
#include <sstream>
#include <unordered_map>
#include <thread>
#include <chrono>
#include <sys/stat.h>
#include <queue>
#include <stack>
#include <unordered_set>

#ifdef ON_WINDOWS
#include <direct.h>
#include <windows.h>
#include <io.h>
#define dup _dup
#define dup2 _dup2
#define fileno _fileno
#define mkdir(dir, mode) _mkdir(dir)
#define stat _stat 
#else
#include <unistd.h>
#include <limits.h>
#include <dirent.h> 
#include <sys/types.h>
#include <sys/wait.h>
#include <csignal>
#endif

#ifdef __APPLE__
#include <mach-o/dyld.h>
#endif

#endif // !_SGPCET_COMMON_H_
#ifndef _SGPCET_ENUM_H_
#define _SGPCET_ENUM_H_

namespace generator {
  namespace _enum {
    enum class Color {
      Red,
      Green,
      Yellow,
      Grey,
      Reset,
      Default = Reset,
      MaxColor
    };
    
    constexpr int __color_index(Color color) {
      return static_cast<int>(color);
    }
    
    enum class _JudgeState {
      _UNKNOWN,
      _AC,
      _WA,
      _ERROR = 3,
      _TLE = 4,
      _TLE_AC = 5,
      _TLE_WA = 6,
      _JUDGE_STATE_MAX
    };

    constexpr int __state_index(_JudgeState state) {
      return static_cast<int>(state);
    }

    inline _JudgeState& operator++(_JudgeState& s) {
      if (s != _JudgeState::_JUDGE_STATE_MAX) 
        s = static_cast<_JudgeState>(static_cast<int>(s) + 1);
      return s;
    }

    inline _JudgeState operator|(_JudgeState lhs, _JudgeState rhs) {
        return static_cast<_JudgeState>(
            static_cast<int>(lhs) | static_cast<int>(rhs)
        );
    }

    inline _JudgeState& operator|=(_JudgeState& lhs, _JudgeState rhs) {
        lhs = lhs | rhs;
        return lhs;
    }

    bool __has_ac(_JudgeState state) {
      return state == _JudgeState::_AC || state == _JudgeState::_TLE_AC;
    }

    bool __has_wa(_JudgeState state) {
      return state == _JudgeState::_WA || state == _JudgeState::_TLE_WA;
    }
    
    bool __is_tle(_JudgeState state) {
      return state == _JudgeState::_TLE;
    }
    
    bool __has_tle(_JudgeState state) {
      return __is_tle(state) || state == _JudgeState::_TLE_AC || state == _JudgeState::_TLE_WA;
    }

    bool __is_combine_state(_JudgeState state) {
      return state == _JudgeState::_TLE_AC || state == _JudgeState::_TLE_WA;
    }
    
    bool __is_run_error(_JudgeState state) {
      return state == _JudgeState::_ERROR;
    }

    bool __is_unknown(_JudgeState state) {
      return state == _JudgeState::_UNKNOWN;
    }

    bool __is_consider_state(_JudgeState state) {
      return !__is_unknown(state) && !__is_run_error(state);
    }

    enum _End{
      _IN,
      _OUT,
      _ANS,
      _LOG,
      _LOGC,
      _EXE,
      _VAL,
      _CHECK_RESULT,
      _MAX_END  
    };

    enum _FuncProgramType {
      _GENERATOR,
      _CHECKER,
      _VALIDATOR,
      _RESULT,
      _OTHER  
    };

    enum Checker{
      lcmp,
      yesno,
      rcmp4,
      rcmp6,
      rcmp9,
      wcmp,
      MaxChecker
    };

    enum CharType{
      LowerLetter,
      UpperLetter,
      Letter,
      Number,
      LetterNumber,
      ZeroOne,
      MaxCharType
    };

    enum TreeGenerator {
      RandomFather,
      Pruefer
    };

    enum class LinkType {
      Direct,
      Increase,
      Shuffle,           
      Dedupe
    };
    
    using MergeType = LinkType;
    
    enum class TreeLinkType {
      Direct,
      Increase,
      Shuffle            
    };

    enum PointDirection {
      COUNTER_CLOCKWISE,
      CLOCKWISE,
      ONLINE_BACK,
      ONLINE_FRONT,
      ON_SEGMENT
    };

    enum VectorOrder {
      Ascending,  // 递增
      Descending, // 递减
      Random
    };

    enum VectorUniqueness {
      Distinct, // 不重复
      Duplicate // 允许重复
    };
  } // namespace _enum
} // namespace generator

#endif // !_SGPCET_ENUM_H_
#ifndef _SGPCET_SETTING_H_
#define _SGPCET_SETTING_H_

#ifndef _SGPCET_COMMON_H_
#include "common.h"
#endif // !_SGPCET_COMMON_H_

namespace generator {
  namespace io {
    std::string __lib_path() {
        return __FILE__;
    }
  }; // namespace io
  
  namespace _setting {
    int vector_limit = 10000000; // 1e7
    int node_limit = 10000000;
    int edge_limit = 10000000;
    long long edge_count_inf = -1;
    long long auto_edge_limit = -2;

    int _auto_int = -2;

    long long count_range_inf = -1;
    
    int time_limit_inf = -1; 
    int _time_limit_auto = -2;
    int test_case_limit = 1000;
    int _extra_run_time = 100;

  #ifdef ON_WINDOWS
    char _path_split = '\\';
    char _other_split = '/';
  #else
    char _path_split = '/';
    char _other_split = '\\';
  #endif // ON_WINDOWS
    
    const char* _default_path = "";
  
    std::string _checker_folder = "checker";
  #ifdef ON_WINDOWS
    std::string _sub_checker_folder = "windows";
  #elif defined(__APPLE__)
    std::string _sub_checker_folder = "macos";
  #else
    std::string _sub_checker_folder = "linux";
  #endif // ON_WINDOWS
    
    std::string _lib_folder = io::__lib_path();
    std::string testcase_folder = "testcases";
    std::string compare_folder = "cmp";
    std::string hack_folder = "hack";
    std::string validate_folder = "validate";
    std::string _empty_program_name = "";

    std::string input_suffix = ".in";
    std::string output_suffix = ".out";
    
    std::string _first_generator_argv = "generator";
    std::string _first_checker_argv = "checker";
    std::string _first_validator_argv = "validator";
    
    double time_limit_over_ratio = 2;
    double time_limit_check_ratio = 2;

    const int _error_return = -1;

    bool default_seed = true;
    std::string default_stable_seed = "";
    std::string default_hack_stable_seed = "hack";

    int _rand_sum_sum_limit = 1000000;

    struct BigNumberSetting {

      static void init_labels() {
        upper_labels();       
      }

      static void upper_labels() {
        set_labels("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      }

      static void lower_labels() {
        set_labels("0123456789abcdefghijklmnopqrstuvwxyz");
      }

      static void set_labels(const std::vector<std::string>& l) {
        __set_labels(l);
      }

      static void set_labels(const std::string& l) {
        __set_labels(l);
      }

      static void set_labels(int idx, const std::string& l) {
        auto& _labels = labels();
        auto& _labels_map = labels_map();
        auto& _multi_label = __multi_label();
        if (_labels.size() < idx + 1) _labels.resize(idx + 1);
        else if (_labels[idx] != "") {
          if (_labels[idx].size() != 1) _multi_label--;
          _labels_map.erase(_labels[idx]);
        }
        _labels[idx] = l;
        _labels_map[l] = idx; 
        if (l.size() != 1) _multi_label++;
      }

      static void set_labels(int idx, char l) {
        set_labels(idx, std::string(1, l));
      }
    
      static std::vector<std::string>& labels() {
          static std::vector<std::string> instance;
          return instance;
      }

      static std::unordered_map<std::string, int>& labels_map() {
          static std::unordered_map<std::string, int> instance;
          return instance;
      }

      static bool is_single_label() {
        return __multi_label() == 0;
      }

      static bool has_empty_or_same_label() {
        return labels().size() != labels_map().size();
      }
    private:
      static int& __multi_label() {
        static int multi_label = 0;
        return multi_label;
      }

      template<typename T>
      static void __set_labels(const T& l) {
        auto& _labels = labels();
        auto& _labels_map = labels_map();
        auto& _multi_label = __multi_label();
        _labels.clear();
        _labels_map.clear();
        _labels.resize(l.size());
        _multi_label = 0;
        for (int i = 0; i < l.size(); i++) set_labels(i, l[i]);
      }
    };

    int ntt_threshold = 1000;
    int fast_div_threshold = 1000;
    int newton_threshold = 4;
    bool big_int_parse_prefix = true; // 0, 0b, 0x
    bool big_int_cache_pow = true;

    namespace {
      struct BigNumberSettingInitializer {
        BigNumberSettingInitializer() {
          BigNumberSetting::init_labels();
        }
      } _big_number_setting_initializer;  
    }

    const double PI = 3.14159265358979323846;


  };// namespace _setting
  
};// namespace generator

#endif // !_SGPCET_SETTING_H_
#ifndef _SGPCET_MACRO_H_
#define _SGPCET_MACRO_H_

#include <functional>

#ifndef _GET_VALUE_CONST
#define _GET_VALUE_CONST(type, name) \
  type name() const { return _##name; }
#endif // !_GET_VALUE_CONST

#ifndef _GET_VALUE_REF
#define _GET_VALUE_REF(type, name) \
  type& name##_ref() { return _##name; }
#endif // !_GET_VALUE_REF

#ifndef _GET_VALUE
#define _GET_VALUE(type, name) \
  _GET_VALUE_CONST(type, name) \
  _GET_VALUE_REF(type, name)
#endif // !_GET_VALUE


#ifndef _SET_VALUE
#define _SET_VALUE(type, name) \
  void set_##name(type name) { _##name = name; }
#endif // !_SET_VALUE

#ifndef _SET_GET_VALUE
#define _SET_GET_VALUE(type, name) \
  _GET_VALUE(type, name) \
  _SET_VALUE(type, name)
#endif // !_SET_GET_VALUE

#ifndef _OUTPUT_FUNCTION
#define _OUTPUT_FUNCTION(_TYPE) \
    typedef std::function<void(std::ostream&, const _TYPE&)> OutputFunction; \
    OutputFunction _output_function;
#endif // !_OUTPUT_FUNCTION

#ifndef _OUTPUT_FUNCTION_SETTING
#define _OUTPUT_FUNCTION_SETTING(_TYPE) \
    void set_output(OutputFunction func) { \
        _output_function = func; \
    } \
    friend std::ostream& operator<<(std::ostream& os, const _TYPE& type) { \
        type._output_function(os, type); \
        return os; \
    } \
    void println() { \
        std::cout << *this << std::endl; \
    } \
    void set_output_default() { \
        _output_function = default_function(); \
    } \
    OutputFunction default_function() { \
        OutputFunction func = \
            [](std::ostream& os, const _TYPE& type) { \
                type.default_output(os); \
            }; \
        return func; \
    }
#endif // !_OUTPUT_FUNCTION_SETTING

#ifndef _DEF_GEN_FUNCTION
#define _DEF_GEN_FUNCTION \
    typedef std::function<NodeType()> NodeGenFunction; \
    typedef std::function<EdgeType()> EdgeGenFunction;
#endif // !_DEF_GEN_FUNCTION

#ifndef _CONTEXT_V
#define _CONTEXT_V(name) \
  this->_context.name()
#endif // !_CONTEXT_V

#ifndef _CONTEXT_V_REF
#define _CONTEXT_V_REF(name) \
  this->_context.name##_ref()
#endif // !_CONTEXT_V_REF

#ifndef _CONTEXT_GET
#define _CONTEXT_GET(name) \
    auto name = _CONTEXT_V(name);
#endif // !_CONTEXT_GET

#ifndef _CONTEXT_GET_REF
#define _CONTEXT_GET_REF(name) \
    auto& name = _CONTEXT_V_REF(name);
#endif // !_CONTEXT_GET

#ifndef _MUST_IS_ROOTED
#define _MUST_IS_ROOTED \
    void set_is_rooted(int is_rooted) = delete; 
#endif // !_MUST_IS_ROOTED

#ifndef _DEFAULT_GRAPH_GEN_FUNC
#define _DEFAULT_GRAPH_GEN_FUNC(name) \
  void __default_generator() { \
    this->_generator = new name##Gen<NodeType, EdgeType>(*this); \
  }
#endif // !_DEFAULT_GRAPH_GEN_FUNC

#ifndef _DEFAULT_GEOMETRY_GEN_FUNC
#define _DEFAULT_GEOMETRY_GEN_FUNC(name) \
  void __default_generator() { \
    this->_generator = new name##Gen<T>(*this); \
  }
#endif //!_DEFAULT_GEOMETRY_GEN_FUN

#ifndef _DEFAULT_OUTPUT
#define _DEFAULT_OUTPUT \
  _output_function = this->default_function();
#endif // !_DEFAULT_OUTPUT

#ifndef _DEFAULT_GEN
#define _DEFAULT_GEN \
  __default_generator();
#endif // !_DEFAULT_GEN

#ifndef _TREE_GRAPH_DEFAULT
#define _TREE_GRAPH_DEFAULT \
  _DEFAULT_OUTPUT \
  _DEFAULT_GEN
#endif // !_TREE_GRAPH_DEFAULT

#ifndef _GEOMETRY_DEFAULT
#define _GEOMETRY_DEFAULT \
  _TREE_GRAPH_DEFAULT
#endif //!_GEOMETRY_DEFAULT

#ifndef _DISABLE_NODE_COUNT
#define _DISABLE_NODE_COUNT \
    void set_node_count(int node_count) = delete; 
#endif //!_DISABLE_NODE_COUNT

#ifndef _DISABLE_EDGE_COUNT
#define _DISABLE_EDGE_COUNT \
    void set_edge_count(int edge_count) = delete; 
#endif // !_DISABLE_EDGE_COUNT

#ifndef _DISABLE_DIRECTION
#define _DISABLE_DIRECTION  \
    void set_direction(bool direction) = delete; 
#endif // !_DISABLE_DIRECTION

#ifndef _DISABLE_MULTIPLY_EDGE
#define _DISABLE_MULTIPLY_EDGE \
    void set_multiply_edge(bool multiply_edge) = delete; 
#endif // !_DISABLE_MULTIPLY_EDGE

#ifndef _DISABLE_SELF_LOOP
#define _DISABLE_SELF_LOOP \
    void set_self_loop(bool self_loop) = delete; 
#endif // !_DISABLE_SELF_LOOP

#ifndef _DISABLE_CONNECT
#define _DISABLE_CONNECT \
    void set_connect(bool connect) = delete; 
#endif // !_DISABLE_CONNECT

#ifndef _GEOMETRY_IN_RAND_FUNC
#define _GEOMETRY_IN_RAND_FUNC(Gen) \
  void rand(T x_left, T x_right, T y_left, T y_right) { \
    Gen<T> g; \
    g.set_xy_limit(x_left, x_right, y_left, y_right); \
    __rand(g); \
  } \
  void rand(T left, T right) { \
    Gen<T> g; \
    g.set_xy_limit(left, right); \
    __rand(g); \
  } \
  void rand(std::string format) { \
    Gen<T> g; \
    g.set_xy_limit(format); \
    __rand(g); \
  }
#endif //!_GEOMETRY_IN_RAND_FUNC

#ifndef _GEOMETRY_OUT_RAND_FUNC
#define _GEOMETRY_OUT_RAND_FUNC(FuncName, ReturnType) \
  template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type> \
  ReturnType<T> FuncName(T x_left, T x_right, T y_left, T y_right) { \
    ReturnType<T> r; \
    r.rand(x_left, x_right, y_left, y_right); \
    return r; \
  } \
  template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type> \
  ReturnType<T> FuncName(T left, T right) { \
    ReturnType<T> r; \
    r.rand(left, right); \
    return r; \
  } \
  template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type> \
  ReturnType<T> FuncName(std::string format) { \
    ReturnType<T> r; \
    r.rand(format); \
    return r; \
  }
#endif //!_GEOMETRY_OUT_RAND_FUNC

#ifndef _DISABLE_SAME_POINT
#define _DISABLE_SAME_POINT \
    void set_same_point(bool same_point) = delete; 
#endif //!_DISABLE_SAME_POINT

#endif // !_SGPCET_MACRO_H_
#ifndef _SGPCET_TOOLS_H_
#define _SGPCET_TOOLS_H_

#ifndef _SGPCET_COMMON_H_
#include "common.h"
#endif // !_SGPCET_COMMON_H_

namespace generator {
  namespace tools {
    template <typename T>
    void __join_helper(std::ostringstream& oss, std::string, const T& data) {
      oss << data;
    }
    
    template <typename T, typename... Args>
    void __join_helper(std::ostringstream& oss, std::string split, const T& data, const Args&... args) {
        oss << data; 
        oss << split; 
        __join_helper(oss, split, args...);
    }
    
    template <typename... Args>
    std::string string_join(std::string split, const Args&... args) {
        std::ostringstream oss;
        __join_helper(oss, split, args...);
        return oss.str();
    }
    
    template <typename... Args>
    std::string string_join(char split, const Args&... args) {
        std::ostringstream oss;
        __join_helper(oss, std::string(1, split), args...);
        return oss.str();
    }

    std::string string_format(const char* format, ...) {
        FMT_TO_RESULT(format, format, _format);
        return _format;
    }

    std::chrono::steady_clock::time_point now() { return std::chrono::steady_clock::now(); }

    long long duration_us(std::chrono::steady_clock::time_point& start) {
        auto end = now();
        long long d = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
        start = now();
        return d;
    }

    long long duration_ms(std::chrono::steady_clock::time_point& start) {
        auto end = now();
        long long d = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
        start = now();
        return d;
    }
    
  } // namespace tools
} // namespace generator

#endif // !_SGPCET_TOOLS_H_
#ifndef _SGPCET_COLOR_H_
#define _SGPCET_COLOR_H_

#ifndef _SGPCET_SETTING_H_
#include "basic/setting.h"
#endif // !_SGPCET_SETTING_H_
#ifndef _SGPCET_ENUM_H_
#include "basic/enum.h"
#endif // !_SGPCET_ENUM_H_

namespace generator {
    
    namespace _msg {
      
    #ifdef ON_WINDOWS
      WORD _color_ansi[_enum::__color_index(_enum::Color::MaxColor)] = {
        FOREGROUND_RED,
        FOREGROUND_GREEN,
        FOREGROUND_GREEN | FOREGROUND_RED,
        FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_RED,
        0 // default
      };
    #else
      std::string _color_ansi[_enum::__color_index(_enum::Color::MaxColor)] = {
        "\033[1;31m",
        "\033[32m",
        "\033[1;33m",
        "\033[0m",
        "\033[0m"
      };
    #endif // ON_WINDOWS
    
      FILE *__get_std_stream(const std::ostream &stream) {
        if (&stream == &std::cout)
          return stdout;
        else if ((&stream == &std::cerr) || (&stream == &std::clog))
          return stderr;

        return 0;
      }

      bool __is_atty(const std::ostream &stream) {
        FILE *std_stream = __get_std_stream(stream);
        
        if (!std_stream) return false;
        
      #ifdef ON_WINDOWS
        return _isatty(_fileno(std_stream));
      #else
        return isatty(fileno(std_stream));
      #endif // ON_WINDOWS
      }
      
      static int _colorize_index = std::ios_base::xalloc();
      
      bool __is_colorized(std::ostream &stream) {
        return __is_atty(stream) || static_cast<bool>(stream.iword(_colorize_index));
      }
    
    #ifdef ON_WINDOWS
      void __win_color(std::ostream &stream, _enum::Color color) {
        if (!__is_atty(stream)) return;
        HANDLE hTerminal = INVALID_HANDLE_VALUE;
        if (&stream == &std::cout) hTerminal = GetStdHandle(STD_OUTPUT_HANDLE);
        else if (&stream == &std::cerr) hTerminal = GetStdHandle(STD_ERROR_HANDLE);
        
        if (!_color_ansi[_enum::__color_index(_enum::Color::Default)]) {
          CONSOLE_SCREEN_BUFFER_INFO info;
          if (!GetConsoleScreenBufferInfo(hTerminal, &info))
            _color_ansi[_enum::__color_index(_enum::Color::Default)] = _color_ansi[_enum::__color_index(_enum::Color::Grey)];
          else
            _color_ansi[_enum::__color_index(_enum::Color::Default)] = info.wAttributes;
        }

        SetConsoleTextAttribute(hTerminal, _color_ansi[_enum::__color_index(color)]);
      }
    #endif // ON_WINDOWS
    
      std::ostream& __color(std::ostream &stream, _enum::Color color) {
        if (__is_colorized(stream)) {
        #ifdef ON_WINDOWS
          __win_color(stream, color);
        #else
          stream << _color_ansi[_enum::__color_index(color)];
        #endif // ON_WINDOWS
        }
        return stream;
      }
      
    #define _COLOR_FUNC(func, color) \
      std::ostream& func(std::ostream& stream) { \
          return __color(stream, color); \
      }
    
      _COLOR_FUNC(__red, _enum::Color::Red)
      _COLOR_FUNC(__green, _enum::Color::Green)
      _COLOR_FUNC(__yellow, _enum::Color::Yellow)
      _COLOR_FUNC(__color_reset, _enum::Color::Reset)
      _COLOR_FUNC(__color_default, _enum::Color::Default)
    
    #undef _COLOR_FUNC
    
      class _ColorMsg {
      protected:
        std::string msg_;
        _enum::Color color_;
      public:
        _ColorMsg(std::string msg, _enum::Color color = _enum::Color::Default) : msg_(msg), color_(color) {}
        friend std::ostream& operator<<(std::ostream& os, const _ColorMsg& color_msg) {
          __color(os, color_msg.color_);
          os << color_msg.msg_;
          os << __color_reset;
          return os;
        }

        int size() { return msg_.size(); }
      };
      
      _ColorMsg _warn("WARN", _enum::Color::Yellow);
      _ColorMsg _success("SUCCESS", _enum::Color::Green);
      _ColorMsg _fail("FAIL", _enum::Color::Red);
      _ColorMsg _error("ERROR", _enum::Color::Red);
      _ColorMsg _set_fail("SETTING FAIL", _enum::Color::Red);
      
    } // namespace _msg
}

#endif // !_SGPCET_COLOR_H_
#ifndef _SGPCET_LOGGER_H_
#define _SGPCET_LOGGER_H_

#ifndef _SGPCET_COLOR_H_
#include "color.h"
#endif // !_SGPCET_COLOR_H_
#ifndef _SGPCET_TOOLS_H_
#include "basic/tools.h"
#endif // !_SGPCET_TOOLS_H_
#ifndef _SGPCET_ENUM_H_
#include "basic/enum.h"
#endif // !_SGPCET_ENUM_H_
#ifndef _SGPCET_MACRO_H_
#include "basic/macro.h"
#endif // !_SGPCET_MACRO_H_

namespace generator {
    namespace io {
        class Path;
    } // namespace io

    namespace _msg {

        class OutStream {
        protected:
          std::ostream* _stream;
          std::ofstream _file;
          std::string _path;
          std::unordered_set<std::string> _logs;
          bool _log_same;
        public:
          OutStream(bool log_same = true) : _log_same(log_same) { __default_output(); }
          OutStream(std::ostream& stream, bool log_same = true) : 
            _stream(&stream), _path(""), _log_same(log_same) {}
          OutStream(const io::Path& path, bool log_same = true);
          OutStream(const std::string& path, bool log_same = true) : _stream(nullptr), _log_same(log_same) {
            open(path);
          }
          ~OutStream() { close(); }
          
          OutStream(const OutStream&) = delete;
          OutStream& operator=(const OutStream&) = delete;
          
          OutStream(OutStream&& other) noexcept : _logs(other._logs), _log_same(other._log_same) {
            open(std::move(other._path));
          }
          
          OutStream& operator=(OutStream&& other) noexcept {
            if (this != &other) {
              open(std::move(other._path));
              _logs = std::move(other._logs);
              _log_same = other._log_same;
            }
            return *this;
          }
          
          void swap(OutStream& other) noexcept {
            std::swap(_path, other._path);
            open(_path);
            std::swap(_logs, other._logs);
            std::swap(_log_same, other._log_same);
          }
          
          template <typename T>
          OutStream& operator<<(const T& data) {
            *_stream << data;
            return *this;
          }
          
          OutStream& operator<<(std::ostream& (*manipulator)(std::ostream&)) {
            manipulator(*_stream);
            return *this;
          }
          
          void print() { return; }
          
          template <typename T>
          void print(const T& data) { this->operator<<(data); }
          
          void println() { this->operator<<(std::endl); }
          
          template <typename T>
          void println(const T& data) { print(data); this->operator<<(std::endl); }
          
          template <typename T, typename... Args>
          void print(const T& data, const Args&... args) {
            print(data);
            print(args...);
          }
          
          template <typename T, typename... Args>
          void println(const T& data, const Args&... args) {
            print(data);
            println(args...);
          }
          
          template <typename... Args>
          bool same_log(const Args&... args) {
            if (!__enable_log_same()) {
              if (__has_same_logs(args...)) return true;
              __store_logs(args...);
            }
            return false;
          }

          _GET_VALUE_CONST(std::string, path)
          _SET_GET_VALUE(bool, log_same)
            
        protected:
          void open(std::string path) {
            close(); 
            if (!path.empty()) {
              _file.open(path);
              if (_file.is_open()) {
                _stream = &_file;
                _path = path;
                return; 
              }
              else {
                std::cerr << "Error opening file: " << path << std::endl;
                std::cerr << "Using std::cerr instead." << std::endl;                
              }
            }
            __default_output(); 
          }
          
          void close() {
            if (_file.is_open()) _file.close();
          }
          
          void __default_output() {
            _stream = &std::cerr;
            _path = "";
            _stream->iword(_colorize_index) = true;
          }
          
          bool __enable_log_same() {
            return _log_same;
          }
          
          template <typename... Args>
          void __store_logs(const Args&... args) {
            std::string log = tools::string_join("", args...);
            _logs.insert(log);
          }
          
          template <typename... Args>
          bool __has_same_logs(const Args&... args) {
            std::string log = tools::string_join("", args...);
            return _logs.find(log) != _logs.end();
          }
      };
      
      template <typename... Args>
      void __fail_msg(OutStream& out, Args... args) {
        out.println(_fail, " ", args...);
        exit(EXIT_FAILURE);
      }
      
      template <typename... Args>
      void __success_msg(OutStream& out, Args... args) {
        if (!out.same_log(_success, " ",args...))
          out.println(_success, " ", args...);
        return;
      }
      
      template <typename... Args>
      void __info_msg(OutStream& out, Args... args) {
        if (!out.same_log(args...))
          out.println(args...);
        return;
      }
      
      template <typename... Args>
      void __warn_msg(OutStream& out, Args... args) {
        if (!out.same_log(_warn, " ", args...))
          out.println(_warn, " ", args...);
        return;
      }
      
      template <typename... Args>
      void __error_msg(OutStream& out, Args... args) {
        out.println(_error, " ", args...);
        exit(EXIT_FAILURE);
      }

      template <typename... Args>
      void __set_fail_msg(OutStream& out, Args... args) {
        if (!out.same_log(_set_fail, " ", args...))
          out.println(_set_fail, " ", args...);
        return;
      }

      void __endl(OutStream& out, int count = 1) {
        for (int i = 1; i <= count; i++) out.println();
      }

      template <typename... Args>
      void __flash_msg(OutStream& out, Args... args) {
        out.print("\r", args...);
      }
      
      OutStream _defl; // default_log
    } // namespace _msg
} // namespace generator

#endif // !_SGPCET_LOGGER_H_
#ifndef _SGPCET_NUMBER_FORMAT_H_
#define _SGPCET_NUMBER_FORMAT_H_

#ifndef _SGPCET_COMMON_H_
#include "basic/common.h"
#endif // !_SGPCET_COMMON_H_
#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif // !_SGPCET_LOGGER_H_

namespace generator {
    namespace tools {
        // 检查R是否可以包含T的所有值
        template<typename T, typename R>
        struct IsRangeContained {
        private:
            static constexpr bool check_integral_range() {
                if (std::is_same<T, R>::value) return true;
                
                if (std::is_signed<T>::value && std::is_unsigned<R>::value) {
                    return std::numeric_limits<R>::max() >= std::numeric_limits<T>::max() &&
                        std::numeric_limits<T>::min() >= 0; 
                }
                
                if (std::is_unsigned<T>::value && std::is_signed<R>::value) {
                    return std::numeric_limits<R>::max() >= std::numeric_limits<T>::max();
                }
                
                return std::numeric_limits<R>::min() <= std::numeric_limits<T>::min() &&
                    std::numeric_limits<R>::max() >= std::numeric_limits<T>::max();
            }
            
        public:
            static constexpr bool value = 
                std::is_integral<T>::value &&
                std::is_integral<R>::value &&
                check_integral_range();
        };

        template<typename T>
        T __string_to_value(const std::string& s) {
            _msg::__error_msg(_msg::_defl, "Unsupported type.");
        }
        
        template<>
        float __string_to_value(const std::string& s) {
            return std::stof(s);
        }
        
        template<>
        double __string_to_value(const std::string& s) {
            return std::stod(s);
        }
        
        bool __is_real_format(const std::string& s) {
            return s.find_first_of("eE.") != std::string::npos;
        }
        
        template<>
        int __string_to_value(const std::string& s) {
            if (__is_real_format(s)) 
                return (int)__string_to_value<double>(s);
            return std::stoi(s);
        }
        
        template<>
        long __string_to_value(const std::string& s) {
            if (__is_real_format(s)) 
                return (long)__string_to_value<double>(s);
            return std::stol(s);
        }
        
        template<>
        unsigned long __string_to_value(const std::string& s) {
            if (__is_real_format(s)) 
                return (unsigned long)__string_to_value<double>(s);
            return std::stoul(s);
        }
        
        template<>
        long long __string_to_value(const std::string& s) {
            if (__is_real_format(s)) 
                return (long long)__string_to_value<double>(s);
            return std::stoll(s);
        }
        
        template<>
        unsigned long long __string_to_value(const std::string& s) {
            if (__is_real_format(s)) 
                return (unsigned long long)__string_to_value<double>(s);
            return std::stoull(s);
        }
        
        template<>
        unsigned int __string_to_value(const std::string& s) {
            return (unsigned int)__string_to_value<long long>(s);
        }

        std::string __sub_value_string(std::string&s, size_t from, size_t to) {
            return s.substr(from + 1, to - from - 1);
        }
        
        template <typename T = long long>
        typename std::enable_if<std::is_integral<T>::value, std::pair<T, T>>::type
        __format_to_int_range(std::string s) {
            static std::unordered_map<std::string, std::pair<T, T>> range_cache;
            if(range_cache.find(s) != range_cache.end()) return range_cache[s];
            size_t open = s.find_first_of("[(");
            size_t close = s.find_first_of(")]");
            size_t comma = s.find(',');
            if(open == std::string::npos || close == std::string::npos || comma == std::string::npos) {
                _msg::__fail_msg(_msg::_defl, tools::string_format("%s is an invalid range.",s.c_str()));
            }
            T left = __string_to_value<T>(__sub_value_string(s, open, comma));
            T right = __string_to_value<T>(__sub_value_string(s, comma, close));
            if (s[open] == '(') left++;
            if (s[close] == ')') right--;
            _msg::__warn_msg(_msg::_defl, tools::string_format("translate format \"%s\" into range [%s, %s], please check.",
                s.c_str(), std::to_string(left).c_str(), std::to_string(right).c_str()));
            range_cache[s] = std::make_pair(left, right);
            return range_cache[s];
        }

        int __number_accuracy(const std::string& s) {
            static std::unordered_map<std::string, int> accuracy_cache;
            if(accuracy_cache.find(s) != accuracy_cache.end()) return accuracy_cache[s];
            int digit = 1;
            bool is_decimal_part = false;
            bool is_scientific_part = false;
            std::string scientific_part = "";
            for(auto c : s) {
                if(is_decimal_part == true){
                    if(c >= '0' && c <= '9') digit ++;
                    else is_decimal_part = false;
                }
                if(is_scientific_part == true) scientific_part += c;
                if(c == '.') is_decimal_part = true;
                if(c == 'e' || c == 'E') is_scientific_part = true;
            }
            if(scientific_part != ""){
                int scientific_length = std::stoi(scientific_part);
                digit -= scientific_length;
            }
            accuracy_cache[s] = digit;
            return accuracy_cache[s];
        }
        
        template <typename T = double>
        typename std::enable_if<std::is_floating_point<T>::value, std::pair<T, T>>::type
        __format_to_double_range(std::string s) {
            static std::unordered_map<std::string, std::pair<T, T>> range_cache;
            if(range_cache.find(s) != range_cache.end()) return range_cache[s];
            int accuracy = 1;
            size_t open = s.find_first_of("[(");
            size_t close = s.find_first_of(")]");
            size_t comma = s.find(',');
            if(open == std::string::npos || close == std::string::npos || comma == std::string::npos) {
                _msg::__fail_msg(_msg::_defl, tools::string_format("%s is an invalid range.",s.c_str()));
            }
            std::string left_str = __sub_value_string(s, open, comma);
            std::string right_str = __sub_value_string(s, comma, close);
            T left = __string_to_value<T>(left_str);
            T right = __string_to_value<T>(right_str);
            accuracy = std::max(accuracy, std::max(__number_accuracy(left_str), __number_accuracy(right_str)));
            double eps1 = std::pow(10.0, -accuracy + 1);
            double eps2 = std::pow(10.0, -accuracy);
            if(s[open] == '(') left += eps1;
            if(s[close] == ']') right += eps2;
            _msg::__warn_msg(_msg::_defl, tools::string_format("translate format \"%s\" into range [%.*f, %.*f), the accuracy is 10^{-%d}, please check.",
                s.c_str(), accuracy, left, accuracy, right, accuracy - 1));
            range_cache[s] = std::make_pair(left, right);
            return range_cache[s];
        }

        template<typename T>
        typename std::enable_if<std::is_integral<T>::value, std::pair<T, T>>::type
        __format_to_range(std::string s) {
            return __format_to_int_range<T>(s);
        }
        
        template<typename T>
        typename std::enable_if<std::is_floating_point<T>::value, std::pair<T, T>>::type
        __format_to_range(std::string s) {
            return __format_to_double_range<T>(s);
        }

        template <typename T, typename R>
        typename std::enable_if<IsRangeContained<T, R>::value, R>::type
        __change_to_int(T value, std::string) {
            return static_cast<R>(value);
        }

        template <typename T, typename R>
        typename std::enable_if<!IsRangeContained<T, R>::value, R>::type
        __change_to_int(T value, std::string name) {
            static std::unordered_map<T, R> cache;
            if(cache.find(value) != cache.end()) return cache[value];
            R result = static_cast<R>(value);
            std::string value_s = std::to_string(value);
            std::string result_s = std::to_string(result);
            _msg::__warn_msg(_msg::_defl, tools::string_format("change %s number : %s -> %s, please check.",
                name.c_str(), value_s.c_str(), result_s.c_str()));
            cache[value] = result;
            return result;
        }

        template <typename T, typename R>
        typename std::enable_if<std::is_same<T, R>::value, R>::type
        __change_to_double(T value, std::string){
            return value;
        }

        template <typename T, typename R>
        typename std::enable_if<!std::is_same<T, R>::value, R>::type
        __change_to_double(T value, std::string name){
            static std::unordered_map<T, R> cache;
            if(cache.find(value) != cache.end()) return cache[value];
            R result = static_cast<R>(value);
            std::string value_s = std::to_string(value);
            std::string result_s = std::to_string(result);
            _msg::__warn_msg(_msg::_defl,  tools::string_format("change %s number : %s -> %s, please check.",
                name.c_str(), value_s.c_str(), result_s.c_str()));
            cache[value] = result;
            return result;
        }

        template <typename T, typename R>
        typename std::enable_if<std::is_integral<R>::value, R>::type
        __change_to_value(T value, std::string name) {
            return __change_to_int<T, R>(value, name);
        }
    
        template <typename T, typename R>
        typename std::enable_if<std::is_floating_point<R>::value, R>::type
        __change_to_value(T value, std::string name) {
            return __change_to_double<T, R>(value, name);
        }

    } // namespace rand_numeric
} // namespace generator

#endif // !_SGPCET_NUMBER_FORMAT_H_
#ifndef _SGPCET_NUMBER_CONST_H_
#define _SGPCET_NUMBER_CONST_H_

#ifndef _SGPCET_COMMON_H_
#include "basic/common.h"
#endif // !_SGPCET_COMMON_H_
#ifndef _SGPCET_ENUM_H_
#include "basic/enum.h"
#endif // !_SGPCET_ENUM_H_

namespace generator {
    namespace rand_numeric {
        const long long __LONG_LONG_MIN = std::numeric_limits<long long>::min();
        const unsigned long long __UNSIGNED_LONG_LONG_MAX = std::numeric_limits<unsigned long long>::max();
        const unsigned long long __UNSIGNED_LONG_LONG_MIN = std::numeric_limits<unsigned long long>::min();
        const unsigned long long __CHECK_LONG_LONG_MAX = (unsigned long long)std::numeric_limits<long long>::max();
        const unsigned long long __CHECK_ABS_LONG_LONG_MIN = __CHECK_LONG_LONG_MAX + 1ULL;
        const unsigned long long __CHECK_UNSIGNED_LONG_MAX = (unsigned long long)std::numeric_limits<unsigned long>::max();
    
        template <typename T>
        struct IsNumeric {
            static constexpr bool value = std::is_integral<T>::value || std::is_floating_point<T>::value;
        };

        const std::string _PATTERN[_enum::MaxCharType]={
            "[a-z]",
            "[A-Z]",
            "[a-zA-Z]",
            "[0-9]",
            "[a-zA-Z0-9]",
            "[01]"
        };
    } // namespace rand_numeric
} // namespace generator

#endif // !_SGPCET_NUMBER_CONST_H_
#ifndef _SGPCET_NUMERIC_H_
#define _SGPCET_NUMERIC_H_

#ifndef _SGPCET_NUMBER_CONST_H_
#include "rand/number_const.h"
#endif // !_SGPCET_NUMBER_CONST_H_
#ifndef _SGPCET_NUMBER_FORMAT_H_
#include "rand/number_format.h"
#endif // !_SGPCET_NUMBER_FORMAT_H_

namespace generator {
    namespace rand_numeric {
        bool rand_bool() {
            return rnd.next(2);
        }

        template<typename T>
        T __rand_int_impl(T x) {
            return rnd.next(x);
        }
        
        template<>
        unsigned int __rand_int_impl<unsigned int>(unsigned int n) {
            long long nl = n;
            long long x = rnd.next(nl);
            return (unsigned int)x;
        }
        
        template<>
        unsigned long long __rand_int_impl<unsigned long long>(unsigned long long n) {
            if (n == 0) {
                _msg::__fail_msg(_msg::_defl, "n must greater than 0.");
            }
            long long ask = (1LL << 32);
            unsigned long long limit = __UNSIGNED_LONG_LONG_MAX / n * n;
            unsigned long long z;
            do {
                long long x = rnd.next(ask);
                long long y = rnd.next(ask);
                z = ((unsigned long long)x << 32)^((unsigned long long)y);
            } while(z >= limit);
            return z % n;
        }
        
        template<>
        unsigned long __rand_int_impl<unsigned long>(unsigned long n) {
            if (__CHECK_UNSIGNED_LONG_MAX == __UNSIGNED_LONG_LONG_MAX) return (unsigned long)__rand_int_impl<unsigned long long>(n);
            else return (unsigned long)__rand_int_impl<unsigned int>(n);
        }
        
        template<typename T>
        T __rand_int_impl(T from, T to) {
            return rnd.next(from, to);
        }
        
        template<>
        unsigned long long __rand_int_impl<unsigned long long>(unsigned long long from, unsigned long long to) {
            if (from > to) {
                _msg::__fail_msg(_msg::_defl, tools::string_format("range [%llu, %llu] is not valid.", from, to));
            }
            if (from == __UNSIGNED_LONG_LONG_MIN && to == __UNSIGNED_LONG_LONG_MAX) {
                unsigned long long result = __rand_int_impl<unsigned long long>(from, to / 2);
                int x = rand_bool();
                return x ? result * 2ULL + 1 : result * 2ULL;
            }
            return __rand_int_impl<unsigned long long>(to - from + 1ULL) + from;
        }
        
        template<>
        long long __rand_int_impl<long long>(long long from, long long to) {
            if (from > to) {
                _msg::__fail_msg(_msg::_defl, tools::string_format("range [%lld, %lld] is not valid.", from, to));
            }
            if ((from < 0 && to < 0) || (from > 0 && to > 0)) {
                return rnd.next(from, to);
            }
            else {
                unsigned long long froml = (unsigned long long)from - __LONG_LONG_MIN;
                unsigned long long tol = (unsigned long long)to - __LONG_LONG_MIN;
                unsigned long long result = __rand_int_impl<unsigned long long>(froml, tol);
                if (result >= __CHECK_ABS_LONG_LONG_MIN) return (long long)(result - __CHECK_ABS_LONG_LONG_MIN);
                else return (long long)result - __CHECK_ABS_LONG_LONG_MIN;
            }
        }
        
        template<>
        unsigned long __rand_int_impl<unsigned long>(unsigned long from, unsigned long to) {
            if (__CHECK_UNSIGNED_LONG_MAX == __UNSIGNED_LONG_LONG_MAX) return (unsigned long)__rand_int_impl<unsigned long long>(from, to);
            else return (unsigned long)__rand_int_impl<unsigned int>(from, to);
        }

        template <typename T = int>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        rand_int(T n){
            T x = __rand_int_impl<T>(n);
            return x;
        }

        template <typename T = int>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        rand_int(T from, T to){
            T x = __rand_int_impl<T>(from, to);
            return x;
        }

        template <typename R = long long, typename T = long long, typename U = long long>
        typename std::enable_if<
            std::is_integral<R>::value &&
            std::is_convertible<T, R>::value && 
            std::is_convertible<U, R>::value, R>::type
        rand_int(T from, U to){
            R from_r = tools::__change_to_int<T, R>(from, "from");
            R to_r = tools::__change_to_int<U, R>(to, "to");
            R x = __rand_int_impl<R>(from_r, to_r);
            return x;
        }

        template <typename T = long long>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        rand_int(std::string format) {
            std::pair<T, T> range = tools::__format_to_int_range<T>(format);
            T x = __rand_int_impl<T>(range.first, range.second);
            return x;
        }

        template <typename T>
        T __to_odd_need_limit(T n, bool lower) {
            if (n % 2 == 0) lower ?  n++ : n--;
            return (n - 1) / 2;
        }
         
        template <typename T>
        T __rand_odd_impl(T from, T to) {
            if (to < from || (to == from && to % 2 == 0)) {
                _msg::__fail_msg(_msg::_defl, tools::string_format("There is no odd number between [%s, %s].", 
                    std::to_string(from).c_str(), std::to_string(to).c_str()));
            }
            T l = __to_odd_need_limit(from, true);
            T r = __to_odd_need_limit(to, false);
            T v = rand_int(l, r);
            return v * 2 + 1;
        }

        template <typename T>
        T __rand_odd_impl(T n) {
            if (n <= 1) {
                _msg::__fail_msg(_msg::_defl, tools::string_format("There is no odd number between [1, %s).",
                    std::to_string(n).c_str()));
            }
            return __rand_odd_impl<T>(0, n - 1);
        }  

        template <typename T = int>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        rand_odd(T n){
            return __rand_odd_impl<T>(n);
        }
        
        template <typename T = int>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        rand_odd(T from, T to){
            return __rand_odd_impl<T>(from, to);
        }

        template <typename R = long long, typename T = long long, typename U = long long>
        typename std::enable_if<
            std::is_integral<R>::value &&
            std::is_convertible<T, R>::value && 
            std::is_convertible<U, R>::value, R>::type
        rand_odd(T from, U to){
            R from_r = tools::__change_to_int<T, R>(from, "from");
            R to_r = tools::__change_to_int<U, R>(to, "to");
            return __rand_odd_impl<R>(from_r, to_r);
        }

        template <typename T = long long>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        rand_odd(std::string format) {
            std::pair<T, T> range = tools::__format_to_int_range<T>(format);
            return __rand_odd_impl<T>(range.first,range.second);
        }

        template <typename T>
        T __to_even_need_limit(T n, bool lower) {
            if (n % 2 != 0) lower ? n++ : n--;
            return n / 2;
        }
        
        template <typename T>
        T __rand_even_impl(T from, T to) {
            if (to < from || (to == from && to % 2 != 0)) {
                _msg::__fail_msg(_msg::_defl, tools::string_format("There is no even number between [%s, %s].", 
                    std::to_string(from).c_str(), std::to_string(to).c_str())); 
            }
            T l = __to_even_need_limit(from, true);
            T r = __to_even_need_limit(to, false);
            T v = rand_int(l, r);
            return v * 2;
        }

        template <typename T>
        T __rand_even_impl(T n) {
            if (n <= 0) {
                _msg::__fail_msg(_msg::_defl, tools::string_format("There is no even number between [0, %s).", 
                    std::to_string(n).c_str()));
            }
            return __rand_even_impl<T>(0, n - 1);
        }

        template <typename T = int>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        rand_even(T n){
            return __rand_even_impl<T>(n);
        }
        
        template <typename T = int>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        rand_even(T from, T to){
            return __rand_even_impl<T>(from, to);
        }

        template <typename R = long long, typename T = long long, typename U = long long>
        typename std::enable_if<
            std::is_integral<R>::value &&
            std::is_convertible<T, R>::value && 
            std::is_convertible<U, R>::value, R>::type
        rand_even(T from, U to){
            R from_r = tools::__change_to_int<T, R>(from, "from");
            R to_r = tools::__change_to_int<U, R>(to, "to");
            return __rand_even_impl<R>(from_r, to_r);
        }

        template <typename T = long long>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        rand_even(std::string format) {
            std::pair<T, T> range = tools::__format_to_int_range<T>(format);
            return __rand_even_impl<T>(range.first,range.second);
        }

        template <typename R = double, typename T = double>
        typename std::enable_if<
            std::is_floating_point<R>::value &&
            std::is_convertible<T, double>::value, R>::type
        rand_real() {
            double x = rnd.next();
            return x;
        }

        template <typename R = double, typename T = double>
        typename std::enable_if<
            std::is_floating_point<R>::value &&
            std::is_convertible<T, double>::value, R>::type
        rand_real(T n) {
            double n_d = tools::__change_to_double<T, double>(n, "to");
            double x = rnd.next(n_d);
            return x;
        }

        template <typename R = double, typename T = double>
        typename std::enable_if<
            std::is_floating_point<R>::value &&
            std::is_convertible<T, double>::value, R>::type
        rand_real(T from, T to) {
            double from_d = tools::__change_to_double<T, double>(from, "from");
            double to_d = tools::__change_to_double<T, double>(to, "to");
            double x = rnd.next(from_d, to_d);
            return x;
        }

        template <typename R = double, typename T = double, typename U = double>
        typename std::enable_if<
            std::is_floating_point<R>::value &&
            std::is_convertible<T, double>::value &&
            std::is_convertible<U, double>::value, R>::type
        rand_real(T from, U to) {
            double from_d = tools::__change_to_double<T, double>(from, "from");
            double to_d = tools::__change_to_double<U, double>(to, "to");
            double x = rnd.next(from_d, to_d);
            return x;
        }

        template <typename T = double>
        typename std::enable_if<std::is_floating_point<T>::value, T>::type
        rand_real(std::string format) {
            std::pair<T, T> range = tools::__format_to_double_range<T>(format);
            double x = rnd.next(range.first, range.second);
            return x;
        }

        template <typename T>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        __rand_value(std::string s) {
            return rand_int<T>(s.c_str());
        }
        
        template <typename T>
        typename std::enable_if<std::is_floating_point<T>::value, T>::type
        __rand_value(std::string s) {
            return rand_real<T>(s.c_str());
        }

        template <typename T>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        __rand_value(T n) {
            return rand_int<T>(n);
        }
        
        template <typename T>
        typename std::enable_if<std::is_floating_point<T>::value, T>::type
        __rand_value(T n) {
            return rand_real<T>(n);
        }

        template <typename T>
        typename std::enable_if<std::is_integral<T>::value, T>::type
        __rand_value(T from, T to) {
            return rand_int<T>(from, to);
        }
        
        template <typename T>
        typename std::enable_if<std::is_floating_point<T>::value, T>::type
        __rand_value(T from, T to) {
            return rand_real<T>(from, to);
        }

        double rand_abs(){
            double x = rand_real();
            return rand_bool() ? x : -x;
        }

        template <typename T>
        typename std::enable_if<IsNumeric<T>::value, T>::type
        rand_abs(T n) {
            T x = __rand_value<T>(n);
            return rand_bool() ? x : -x;
        }
        
        template <typename T>
        typename std::enable_if<IsNumeric<T>::value , T>::type
        rand_abs(T from, T to) {
            T x = __rand_value<T>(from, to);
            return rand_bool() ? x : -x;
        }

        template <typename R = double, typename T, typename U>
        typename std::enable_if<
            IsNumeric<R>::value &&
            std::is_convertible<T, R>::value &&
            std::is_convertible<U, R>::value, R>::type
        rand_abs(T from, U to) {
            R from_r = tools::__change_to_value<T, R>(from, "from");
            R to_r = tools::__change_to_value<U, R>(to, "to");
            R x = __rand_value<R>(from_r, to_r);
            return rand_bool() ? x : -x;
        }

        template <typename T = double>
        typename std::enable_if<IsNumeric<T>::value, T>::type
        rand_abs(std::string format) {
            T x = __rand_value<T>(format);
            return rand_bool() ? x : -x;
        }       

        char rand_char(_enum::CharType type = _enum::LowerLetter){
            std::string s = rnd.next(_PATTERN[type]);
            return s.c_str()[0];
        }

        char rand_char(std::string format) {
            std::string s = rnd.next(format);
            if(s.empty()) {
                _msg::__fail_msg(_msg::_defl, "can't generator a char from an empty string.");
            }
            return s.c_str()[0];
        }

        template<typename KeyType>
        class ProbTable {
        private:
            std::vector<KeyType> _elements;
            std::vector<unsigned long long> _probs;
        public:
            ProbTable() = default;

            template <typename Con>
            ProbTable(const Con& map) {
                __add(map);
            }

            template<typename ValueType>
            ProbTable(KeyType key, ValueType value) {
                __add(key, value);
            }

            template<typename Con>
            void add(const Con& map) {
                __add(map);
            }

            template<typename ValueType>
            void add(const KeyType& key, ValueType value) {
                __add(key, value);
            }

            KeyType rand() const {
                if (_probs.empty()) {
                    _msg::__fail_msg(_msg::_defl, "can't generator a value from an empty ProbTable.");
                }
                unsigned long long sum = _probs.back();
                if (sum == 0) {
                    _msg::__fail_msg(_msg::_defl, "sum of the values must greater than 0, but found 0.");
                }
                long long p = rand_int(1ULL, sum);
                auto pos = lower_bound(_probs.begin(), _probs.end(), p) - _probs.begin();
                return *(_elements.begin() + pos);
            }

            void clear() {
                _elements.clear();
                _probs.clear();
            }
        private:
            template <typename Con>
            typename std::enable_if<
                (std::is_same<Con, std::map<typename Con::key_type, typename Con::mapped_type>>::value ||
                std::is_same<Con, std::unordered_map<typename Con::key_type, typename Con::mapped_type>>::value) &&
                std::is_convertible<typename Con::mapped_type, unsigned long long>::value &&
                std::is_convertible<typename Con::key_type, KeyType>::value,
                void
            >::type 
            __add(const Con& map) {
                using ValueType = typename Con::mapped_type;
                for (auto iter : map) {
                    __add(iter.first, iter.second);
                }
            }

            template <typename ValueType>
            typename std::enable_if<std::is_constructible<ValueType, unsigned long long>::value, void>::type
            __add(const KeyType& key, ValueType value) {
                unsigned long long sum = _probs.empty() ? 0ULL : _probs.back();
                if (value < 0) {
                    _msg::__warn_msg(_msg::_defl, "value can't less than 0, but found (key : ", key,
                        ", value : ", value, "). Ignore this element.");
                } else {
                    _elements.emplace_back(key);
                    sum += static_cast<unsigned long long>(value);
                    _probs.emplace_back(sum);
                }
                if (_elements.size() > _setting::vector_limit) {
                    _msg::__fail_msg(_msg::_defl, 
                        tools::string_format("the size of the ProbTable must less than %d(_setting::vector_limit), but found %d.",
                            _setting::vector_limit, _elements.size()));
                }
            }
        };

        template <typename Con>
        typename std::enable_if<
                (std::is_same<Con, std::map<typename Con::key_type, typename Con::mapped_type>>::value ||
                std::is_same<Con, std::unordered_map<typename Con::key_type, typename Con::mapped_type>>::value) &&
                std::is_integral<typename Con::mapped_type>::value,
                typename Con::key_type
        >::type
        rand_prob(const Con& map)
        {
            using KeyType = typename Con::key_type;
            using ValueType = typename Con::mapped_type;
            ProbTable<KeyType> prob(map);
            return prob.rand();
        }

        template<typename KeyType>
        KeyType rand_prob(const ProbTable<KeyType>& prob) {
            return prob.rand();
        }

        template<typename T = long long>
        typename std::enable_if<std::is_integral<T>::value, std::pair<T, T>>::type
        rand_range(T from, T to) {
            T l = rand_int<T>(from, to);
            T r = rand_int<T>(from, to);
            if (l > r) std::swap(l, r);
            return std::make_pair(l, r);
        }

        template <typename R = long long, typename T = long long, typename U = long long>
        typename std::enable_if<
            std::is_integral<R>::value &&
            std::is_convertible<T, R>::value && 
            std::is_convertible<U, R>::value, std::pair<R, R>>::type
        rand_range(T from, U to) {
            R from_r = tools::__change_to_value<T, R>(from, "from");
            R to_r = tools::__change_to_value<U, R>(to, "to");
            return rand_range<R>(from_r, to_r);
        }
    } // namespace rand_numeric
} // namespace generator

#endif // !_SGPCET_NUMERIC_H_
#ifndef _SGPCET_ARRAY_H_
#define _SGPCET_ARRAY_H_

#ifndef _SGPCET_NUMERIC_H_
#include "rand/numeric.h"
#endif // !_SGPCET_NUMERIC_H_
#ifndef _SGPCET_SETTING_H_
#include "basic/setting.h"
#endif // !_SGPCET_SETTING_H_

namespace generator {
    namespace rand_array {
        void __judge_vector_lower_bound(int to, std::string type) {
            if (to < 0) {
                _msg::__fail_msg(_msg::_defl,
                    tools::string_format("size of the %s can't less than 0, but found %d.", type.c_str(), to));
            }
        }

        void __judge_vector_upper_bound(int from, std::string type) {
            if (from > _setting::vector_limit) {
                _msg::__fail_msg(_msg::_defl,
                    tools::string_format("size of the %s can't greater than the vector_limit(%d), but found %d.", 
                    type.c_str(), _setting::vector_limit, from));
            }
        }

        template <typename T>
        void __judge_range(T from, T to) {
            if (from > to) {
                _msg::__fail_msg(_msg::_defl, 
                    tools::string_format("invalid range [%s, %s], to can't less than from.",
                    std::to_string(from).c_str(), std::to_string(to).c_str()));
            }
        }

        void __judge_count_range(long long from, long long to) {
            if (from == _setting::count_range_inf) _msg::__fail_msg(_msg::_defl, "from can't be inf");
            if (from < 0) _msg::__fail_msg(_msg::_defl, tools::string_format("from can't be less than 0, but found %lld.", from));
            if (to != _setting::count_range_inf && from > to) {
                _msg::__fail_msg(_msg::_defl, 
                    tools::string_format("invalid range [%s, %s], to can't less than from.",
                    std::to_string(from).c_str(), std::to_string(to).c_str()));
            }
        }

        std::string rand_string(int n, _enum::CharType type = _enum::LowerLetter) {
            __judge_vector_lower_bound(n, "string");
            __judge_vector_upper_bound(n, "string");
            std::string s = rnd.next("%s{%d}", rand_numeric::_PATTERN[type].c_str(), n);
            return s;
        }

        std::string rand_string(int from, int to, _enum::CharType type = _enum::LowerLetter) {
            __judge_range(from, to);
            __judge_vector_lower_bound(to, "string");
            __judge_vector_upper_bound(from, "string");
            std::string s = rnd.next("%s{%d,%d}", rand_numeric::_PATTERN[type].c_str(), from, to);
            return s;
        }

        std::string rand_string(int n, std::string format){
            __judge_vector_lower_bound(n, "string");
            __judge_vector_upper_bound(n, "string");
            std::string s = rnd.next("%s{%d}", format.c_str() ,n);
            return s;
        }

        std::string rand_string(int from, int to, std::string format){
            __judge_range(from, to);
            __judge_vector_lower_bound(to, "string");
            __judge_vector_upper_bound(from, "string");
            std::string s = rnd.next("%s{%d,%d}", format.c_str(), from, to);
            return s;
        }

        std::string rand_string(std::string format) {
            return rnd.next(format);
        }

        template <typename T>
        std::vector<T> rand_p(T n){
            __judge_vector_lower_bound(n, "vector");
            __judge_vector_upper_bound(n, "vector");
            std::vector<T> v = rnd.perm(n, T(0));
            return v;
        }

        template <typename T,typename E>
        std::vector<E> rand_p(T n, E s){
            __judge_vector_lower_bound(n, "vector");
            __judge_vector_upper_bound(n, "vector");
            std::vector<E> v = rnd.perm(n, s);
            return v;
        }

        template<typename T = long long>
        typename std::enable_if<std::is_integral<T>::value , std::vector<T> >::type
        rand_sum(int size,T sum) {
            __judge_vector_lower_bound(size, "vector");
            __judge_vector_upper_bound(size, "vector");
            auto v = rnd.partition(size,sum);
            return v;
        }

        template<typename T = long long>
        typename std::enable_if<std::is_integral<T>::value , std::vector<T> >::type
        rand_sum(int size,T sum,T min_part) {
            __judge_vector_lower_bound(size, "vector");
            __judge_vector_upper_bound(size, "vector");
            __judge_range(T(0), min_part);
            auto v = rnd.partition(size,sum,min_part);
            return v;
        }
        
        template<typename T>
        void __rand_small_sum(std::vector<T>&v, T sum, T limit) {
            int size = v.size();
            std::vector<int> rand_v(size);
            for(int i = 0; i < size; i++)
                rand_v[i] = i;
            shuffle(rand_v.begin(), rand_v.end());
            int last = size - 1;
            for (int i = 0; i <= last; i++) {
                if (v[rand_v[i]] >= limit) {
                    std::swap(rand_v[last], rand_v[i]);
                    last--;
                }
            }
            while(sum--) {
                int rand_pos = rnd.next(0, last);
                int add_pos = rand_v[rand_pos];
                v[add_pos]++;
                if(v[add_pos] >= limit) {
                    std::swap(rand_v[last], rand_v[rand_pos]);
                    last--;
                }
            }
            return;
        }
        
        template<typename T>
        bool __rand_large_sum(std::vector<T>&v, T& sum, T limit) {
            int size = v.size();
            std::vector<int> rand_v(size);
            for(int i = 0; i < size; i++)
                rand_v[i] = i;
            shuffle(rand_v.begin(), rand_v.end());
            int last = size - 1;
            T once_add_base = sum / _setting::_rand_sum_sum_limit;
            while(sum > _setting::_rand_sum_sum_limit) {
                int rand_pos, add_pos, once_add;
                do {
                    rand_pos = rnd.next(0, last);
                    add_pos = rand_v[rand_pos];
                    // 95% ~ 105% for once add
                    T once_add_l = std::max(T(0), once_add_base - once_add_base / 20);
                    T once_add_r = std::min(once_add_base + once_add_base / 20, sum);
                    if (once_add_l > once_add_r) {
                        return sum > _setting::_rand_sum_sum_limit;
                    }
                    once_add = rnd.next(once_add_l, once_add_r);
                }while(v[add_pos] + once_add > limit);         
                v[add_pos] += once_add;
                sum -= once_add;
                if(v[add_pos] >= limit) {
                    std::swap(rand_v[last], rand_v[rand_pos]);
                    last--;
                }
            }
            return false;
        }
        
        template<typename T = long long>
        typename std::enable_if<std::is_integral<T>::value , std::vector<T> >::type
        rand_sum(int size, T sum, T from, T to) {
            __judge_vector_lower_bound(size, "vector");
            __judge_vector_upper_bound(size, "vector");
            __judge_range(from, to);
            if((long long)size * from > sum || (long long)size * to < sum){
                _msg::__fail_msg(_msg::_defl,
                    tools::string_format("sum of the vector is in range [%lld, %lld], but need sum = %s.",
                    (long long)from * size, (long long)to * size, std::to_string(sum).c_str()));
            }
            if(size == 0) {
                if(sum != 0){
                    _msg::__fail_msg(_msg::_defl, "sum of the empty vector must be 0.");
                }
                return std::vector<T>();
            }

            T ask_sum = sum;

            std::vector<T> v(size,0);
            sum -= from * size;
            T limit = to - from;
            if (sum <= _setting::_rand_sum_sum_limit) {
                __rand_small_sum(v, sum, limit);
            }
            else if (limit * size - sum <= _setting::_rand_sum_sum_limit){
                __rand_small_sum(v, limit * size - sum, limit);
                for (int i = 0; i < size; i++) {
                    v[i] = limit - v[i];
                }
            }
            else {
                while(__rand_large_sum(v, sum, limit));
                __rand_small_sum(v, sum, limit);
            }
            for (int i = 0; i < size; i++) {
                v[i] += from;
            }

            T result_sum = 0;
            for(int i = 0;i < size;i++){
                if(v[i] < from || v[i] > to){
                    _msg::__error_msg(_msg::_defl, 
                        tools::string_format("the %d%s number %s is out of range [%s, %s], please notice author to fix bug.",
                        i + 1, englishEnding(i + 1).c_str(), std::to_string(v[i]).c_str(), 
                        std::to_string(from).c_str(), std::to_string(to).c_str()));
                }
                result_sum += v[i];
            }
            if (result_sum != ask_sum){
                _msg::__error_msg(_msg::_defl,
                    tools::string_format("sum of the vector is equal to %s, not %s, please notice author to fix bug.",
                    std::to_string(result_sum).c_str(), std::to_string(ask_sum).c_str()));
            }
            return v;
        }

        template <typename R = long long, typename S, typename T, typename U>
        typename std::enable_if<
            std::is_integral<R>::value &&
            std::is_convertible<S, R>::value && 
            std::is_convertible<T, R>::value && 
            std::is_convertible<U, R>::value, std::vector<R> >::type
        rand_sum(int size, S sum, T from, U to) {
            __judge_vector_lower_bound(size, "vector");
            __judge_vector_upper_bound(size, "vector");
            R sum_r = tools::__change_to_int<S, R>(sum, "sum");
            R from_r = tools::__change_to_int<T, R>(from, "from");
            R to_r = tools::__change_to_int<U, R>(to, "to");
            __judge_range(from_r, to_r);
            return rand_sum<R>(size, sum_r, from_r, to_r);
        }

        template <typename T>
        std::vector<T> rand_vector(int size, std::function<T()> func) {
            __judge_vector_lower_bound(size, "vector");
            __judge_vector_upper_bound(size, "vector");
            std::vector<T> v(size);
            for(int i = 0; i < size; i++){
                T x = func();
                v[i] = x;
            }
            return v;
        }

        template <typename T>
        std::vector<T> rand_vector(int from, int to, std::function<T()> func) {
            __judge_range(from, to);
            __judge_vector_lower_bound(to, "vector");
            __judge_vector_upper_bound(from, "vector");
            int size = rnd.next(from, to);
            return rand_vector(size, func);
        }

        template<typename T>
        typename std::enable_if<std::is_integral<T>::value, std::vector<T> >::type
        rand_vector(int size, T from, T to, _enum::VectorOrder order = _enum::VectorOrder::Random, _enum::VectorUniqueness uniqueness = _enum::VectorUniqueness::Duplicate) {
            __judge_range(from, to);
            std::vector<T> v;
            if (uniqueness == _enum::VectorUniqueness::Distinct)  v = rnd.distinct(size, from, to);
            else v = rand_vector<T>(size, [&from, &to]() { return rand_numeric::rand_int(from, to); });
            if (order == _enum::VectorOrder::Ascending) sort(v.begin(), v.end());
            else if (order == _enum::VectorOrder::Descending) sort(v.begin(), v.end(), std::greater<T>());
            return v;
        }

        template<typename R = long long, typename T, typename U>
        typename std::enable_if<std::is_integral<R>::value &&
            std::is_convertible<T, R>::value && 
            std::is_convertible<U, R>::value, std::vector<R> >::type
        rand_vector(int size, T from, U to, _enum::VectorOrder order = _enum::VectorOrder::Random, _enum::VectorUniqueness uniqueness = _enum::VectorUniqueness::Duplicate) {
            R from_r = tools::__change_to_int<T, R>(from, "from");
            R to_r = tools::__change_to_int<U, R>(to, "to");
            return rand_vector<R>(size, from_r, to_r, order, uniqueness);
        }

        template<typename T>
        class CountRange {
        private:
            T _value;
            long long _from, _to;
        public:
            CountRange(T value, long long from = 0LL, long long to = _setting::count_range_inf) : _value(value), _from(from), _to(to) {}

            _SET_GET_VALUE(T, value)
            _SET_GET_VALUE(long long, from)
            _SET_GET_VALUE(long long, to)

            void set_range(long long from, long long to) {
                _from = from;
                _to = to;
            }

            void set_range(std::string s) {
                auto p = tools::__format_to_int_range<long long>(s);
                set_range(p.first, p.second);
            }

        };

        template <typename T>
        std::vector<T> rand_vector(int size, std::vector<CountRange<T>> limits) {
            __judge_vector_lower_bound(size, "vector");
            __judge_vector_upper_bound(size, "vector");
            long long lower_bound = 0;
            long long upper_bound = 0;
            std::vector<int> result;
            std::vector<std::pair<T, long long>> vars;
            for (auto& p : limits) {
                long long from = p.from();
                long long to = p.to();
                T value = p.value();
                __judge_count_range(from, to);
                lower_bound += from;
                if (upper_bound != _setting::count_range_inf) {
                    if (to != _setting::count_range_inf) upper_bound += to;
                    else upper_bound = _setting::count_range_inf;
                }
                if (lower_bound > size) {
                    _msg::__fail_msg(_msg::_defl, 
                        tools::string_format("sum of count range from must less than or equal to vector size %d, but found %lld.", size, lower_bound));
                }
                for(int i = 0; i < from; i++){
                    result.push_back(value);
                }
                if (to == _setting::count_range_inf) vars.emplace_back(value, _setting::count_range_inf);
                else if (to - from > 0) vars.emplace_back(value, to - from);
            }
            if (upper_bound != _setting::count_range_inf && upper_bound < size) {
                _msg::__fail_msg(_msg::_defl, 
                    tools::string_format("sum of count range to must greater than or equal to vector size %d, but found %lld.", size, upper_bound));
            }
            int n = vars.size();
            int sum = size - lower_bound;
            while(sum--) {
                int x = rand_numeric::rand_int(n);
                result.push_back(vars[x].first);
                if (vars[x].second != _setting::count_range_inf) {
                    vars[x].second--;
                    if (vars[x].second == 0) {
                        std::swap(vars[x], vars[n - 1]);
                        n--;
                    }
                }
            }
            shuffle(result.begin(), result.end());
            return result;   
        }

        template <typename T>
        std::vector<T> rand_vector_by_index(int size, std::function<T(int)> func) {
            __judge_vector_lower_bound(size, "vector");
            __judge_vector_upper_bound(size, "vector");
            std::vector<T> v(size);
            for(int i = 0; i < size; i++){
                T x = func(i);
                v[i] = x;
            }
            return v;
        }

        template <typename T>
        std::vector<T> rand_vector_by_index(int from, int to, std::function<T(int)> func) {
            __judge_range(from, to);
            __judge_vector_lower_bound(to, "vector");
            __judge_vector_upper_bound(from, "vector");
            int size = rnd.next(from, to);
            return rand_vector_by_index<T>(size, func);
        }
       
        template<typename Iter>
        std::vector<int> shuffle_index(Iter begin, Iter end, int offset = 0) {
            int tot = 0;
            std::vector<int> res;
            for (Iter i = begin; i != end; i++) {
                int x = *i;
                if (x < 0) _msg::__fail_msg(_msg::_defl, "elements must be non negtive number.");
                tot += x;
                __judge_vector_upper_bound(tot, "vector");
                while (x--) res.emplace_back((i - begin) + offset);
            }
            shuffle(res.begin(),res.end());
            return res;
        }

        std::vector<int> shuffle_index(std::vector<int> v, int offset = 0) {
            return shuffle_index(v.begin(), v.end(), offset);
        }

        std::string __rand_palindrome_impl(int n, int p, std::string char_type) {
            __judge_vector_lower_bound(n, "string");
            __judge_vector_upper_bound(n, "string");
            if (p < 0) {
                 _msg::__fail_msg(_msg::_defl,
                 tools::string_format("palindrome part length must be a non-negative integer, but found %d.", n));
            }
            if (p > n) {
                _msg::__fail_msg(_msg::_defl,
                tools::string_format("palindrome length must less than or equal to string length %d, but found %d.", n, p));
            }
            std::string palindrome_part(p, ' ');
            for (int i = 0; i < (p + 1) / 2; i++) {
                char c = rand_numeric::rand_char(char_type);
                palindrome_part[i] = c;
                palindrome_part[p - i - 1] = c;
            }
            std::string result(n, ' ');
            int pos_l = rnd.next(0, n - p);
            int pos_r = pos_l + p - 1;
            for (int i = 0; i < n; i++) {
                if (i < pos_l || i > pos_r) result[i] = rand_numeric::rand_char(char_type);
                else result[i] = palindrome_part[i - pos_l];
            }
            return result;
        }

        std::string rand_palindrome(int n, int p, _enum::CharType type = _enum::LowerLetter) {
            return __rand_palindrome_impl(n, p, rand_numeric::_PATTERN[type]);
        }

        std::string rand_palindrome(int n, int p, std::string format) {
            return __rand_palindrome_impl(n, p, format);
        }    
        
        // see https://www.luogu.com.cn/article/f3xefa5v
        std::string rand_bracket_seq(int len, std::string brackets = "()") {
            __judge_vector_lower_bound(len, "string");
            __judge_vector_upper_bound(len, "string");
            if (len < 0 || len % 2) {
                _msg::__fail_msg(_msg::_defl, 
                    tools::string_format("length must be positive even number, but found %d.", len));
            }
            std::stack<int> st;
            std::string open = "";
            std::string close = "";
            int n = brackets.size();
            if (n == 0 || n % 2) {
                _msg::__fail_msg(_msg::_defl, 
                    tools::string_format("bracket must appear in pairs and the length must be greater than 0, but found %d.", n));
            }
            for (int i = 0; i < n; i++) {
                if (i % 2 == 0) open += brackets[i];
                else close += brackets[i];
            }
            std::vector<bool> arr(len, false); // 0 : open ; 1 : close
            for (int i = 0; i < len / 2; i++) arr[i] = true;
            shuffle(arr.begin(), arr.end());
            int start = 0, end = len;
            bool has_invaild = true;
            while (has_invaild) {
                has_invaild = false;
                int sum = 0;
                for (int i = start; i < end; i++) {
                    sum += arr[i] ? -1 : 1; 
                    if (sum >= 0) continue;
                    for (int j = i + 1; j < end; j++) {
                        sum += arr[j] ? -1 : 1;
                        if (sum < 0) continue;
                        int l = j - i - 1;
                        std::rotate(arr.begin() + i + 1, arr.begin() + j + 1, arr.begin() + end);
                        std::copy_backward(arr.begin() + end - l - 1, arr.begin() + end - 1, arr.begin() + end);
                        std::transform(arr.begin() + end - l, arr.begin() + end, arr.begin() + end - l, [](bool x) { return !x; });
                        arr[i] = 0; 
                        arr[end - l - 1] = 1;
                        start = i + 1; 
                        end = end - l - 1;
                        has_invaild = true;
                        break;
                    }
                }
            }
            std::string res(len, ' ');
            for (int i = 0; i < len; i++) {
                if (arr[i] == 0) {
                    int p = rand_numeric::rand_int(n / 2);
                    res[i] = open[p];
                    st.push(p);
                } else {
                    res[i] = close[st.top()];
                    st.pop();
                }
            }
            return res;
        }
        
        std::string rand_bracket_seq(int from, int to, std::string brackets = "()") {
            __judge_range(from, to);
            __judge_vector_lower_bound(from, "string");
            __judge_vector_upper_bound(to, "string");
            int len = rand_numeric::rand_even(from, to);
            return rand_bracket_seq(len, brackets);
        }

        template<typename T = long long>
        typename std::enable_if<std::is_integral<T>::value, std::vector<std::pair<T, T>>>::type
        rand_range_query(int q, T from, T to) {
            __judge_vector_lower_bound(q, "vector");
            __judge_vector_upper_bound(q, "vector");
            std::vector<std::pair<T, T>> res(q);
            for (int i = 0; i < q; i++) res[i] = rand_numeric::rand_range<T>(from, to);
            return res;
        }

        template<typename T = long long>
        typename std::enable_if<std::is_integral<T>::value, std::vector<std::pair<T, T>>>::type
        rand_range_query(int q, T from, T to, T lower, T upper) {
            __judge_vector_lower_bound(q, "vector");
            __judge_vector_upper_bound(q, "vector");
            long long range = to - from + 1;
            if (range * q < lower || lower < q) _msg::__fail_msg(_msg::_defl,
                tools::string_format("lower must in range [%d, %lld], but found %lld.", q, range, lower));
            __judge_range(lower, upper);
            if (range * q < upper || upper < q) _msg::__fail_msg(_msg::_defl,
                tools::string_format("upper must in range [%d, %lld], but found %lld.", q, range, upper));
            T sum = rand_numeric::rand_int(lower, upper);
            auto ranges = rand_sum(q, sum, 0, range);
            std::vector<std::pair<T, T>> res(q);
            for (int i = 0; i < q; i++) {
                T l = rand_numeric::rand_int<T>(from, (T)(to - ranges[i] + 1));
                res[i] = std::make_pair(l, l + ranges[i] - 1);
            }
            return res;
        }

        template<typename R = long long, typename T = long long, typename U = long long>
        typename std::enable_if<
            std::is_integral<R>::value &&
            std::is_convertible<T, R>::value && 
            std::is_convertible<U, R>::value, std::vector<std::pair<R, R>>>::type
        rand_range_query(int q, T from, U to) {
            R from_r = tools::__change_to_value<T, R>(from, "from");
            R to_r = tools::__change_to_value<U, R>(to, "to");
            return rand_range_query<R>(q, from_r, to_r);
        }

        template<typename R = long long, typename T = long long, typename U = long long, typename F = long long, typename S = long long>
        typename std::enable_if<
            std::is_integral<R>::value &&
            std::is_convertible<T, R>::value && 
            std::is_convertible<U, R>::value &&
            std::is_convertible<F, R>::value &&
            std::is_convertible<S, R>::value, std::vector<std::pair<R, R>>>::type
        rand_range_query(int q, T from, U to, F lower, S upper) {
            R from_r = tools::__change_to_value<T, R>(from, "from");
            R to_r = tools::__change_to_value<U, R>(to, "to");
            R lower_r = tools::__change_to_value<F, R>(lower, "lower");
            R upper_r = tools::__change_to_value<S, R>(upper, "upper");
            return rand_range_query<R>(q, from_r, to_r, lower_r, upper_r);
        }

        template<typename T = long long>
        typename std::enable_if<std::is_integral<T>::value, std::vector<std::pair<T, T>>>::type
        rand_range_query(int q, T from, T to, T lower) {
            T upper = q * (to - from + 1);
            return rand_range_query<T>(q, from, to, lower, upper);
        }

        template<typename R = long long, typename T = long long, typename U = long long, typename F = long long>
        typename std::enable_if<
            std::is_integral<R>::value &&
            std::is_convertible<T, R>::value && 
            std::is_convertible<U, R>::value &&
            std::is_convertible<F, R>::value , std::vector<std::pair<R, R>>>::type
        rand_range_query(int q, T from, U to, F lower) {
            R from_r = tools::__change_to_value<T, R>(from, "from");
            R to_r = tools::__change_to_value<U, R>(to, "to");
            R lower_r = tools::__change_to_value<F, R>(lower, "lower");
            return rand_range_query<R>(q, from_r, to_r, lower_r);
        }

    } // namespace rand_array
} // namespace generator

#endif // !_SGPCET_ARRAY_H_
#ifndef _SGPCET_WEIGHT_TYPE_H_
#define _SGPCET_WEIGHT_TYPE_H_

#ifndef _SGPCET_COMMON_H_
#include "basic/common.h"
#endif // !_SGPCET_COMMON_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename T, typename U>
            using _IsBothWeight = typename std::enable_if<
                !std::is_void<T>::value && !std::is_void<U>::value, int>::type;

            template<typename T, typename U>
            using _IsEdgeWeight = typename std::enable_if<
                std::is_void<T>::value && !std::is_void<U>::value, int>::type;

            template<typename T, typename U>
            using _IsNodeWeight = typename std::enable_if<
                !std::is_void<T>::value && std::is_void<U>::value, int>::type;

            template<typename T, typename U>
            using _IsUnweight = typename std::enable_if<
                std::is_void<T>::value && std::is_void<U>::value, int>::type;

            template<typename T>
            using _HasT = typename std::enable_if<!std::is_void<T>::value, int>::type;

            template<typename T>
            using _NotHasT = typename std::enable_if<std::is_void<T>::value, int>::type;

        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_WEIGHT_TYPE_H_
#ifndef _SGPCET_EDGE_H_
#define _SGPCET_EDGE_H_

#ifndef _SGPCET_MACRO_H_
#include "basic/macro.h"
#endif // !_SGPCET_MACRO_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            class _BasicEdge {
            protected:
                int _u, _v;
                bool _swap_node;
            public:
                _BasicEdge(int u, int v) : _u(u), _v(v), _swap_node(false) {}

                _SET_GET_VALUE(int, u)
                _SET_GET_VALUE(int, v)
                _SET_GET_VALUE(bool, swap_node)

                friend bool operator==(const _BasicEdge a, const _BasicEdge b) {
                    return a._u == b._u && a._v == b._v;
                }
                friend bool operator!=(const _BasicEdge a, const _BasicEdge b) {
                    return !(a == b);
                }
                friend bool operator<(const _BasicEdge a, const _BasicEdge b) {
                    if (a._u == b._u) return a._v < b._v;
                    return a._u < b._u;
                }
                friend bool operator<=(const _BasicEdge a, const _BasicEdge b) {
                    return a == b || a < b;
                }
                friend bool operator>(const _BasicEdge a, const _BasicEdge b) {
                    return !(a <= b);
                }
                friend bool operator>=(const _BasicEdge a, const _BasicEdge b) {
                    return !(a < b);
                }     
            };

            template<typename T>
            class _Edge : public _BasicEdge {
            protected:
                using _Self = _Edge<T>;
                T _w;
                _OUTPUT_FUNCTION(_Self)
            public:
                _Edge(int u, int v) : _BasicEdge(u, v), _w(T()) {
                    _DEFAULT_OUTPUT
                }
                _Edge(int u, int v, T w) : _BasicEdge(u, v), _w(w) {
                    _DEFAULT_OUTPUT
                }

                _SET_GET_VALUE(T, w)

                std::tuple<int, int, T> edge() const { return std::make_tuple(_u, _v, _w); }
                
                void default_output(std::ostream& os) const {
                    if (_swap_node) os << _v << " " << _u << " " << _w;
                    else os << _u << " " << _v << " " << _w;  
                }

                _OUTPUT_FUNCTION_SETTING(_Self)
            };

            template<>
            class _Edge<void> : public _BasicEdge {
            protected:
                using _Self = _Edge<void>;
                _OUTPUT_FUNCTION(_Self)
            public:
                _Edge(int u, int v) : _BasicEdge(u, v) {
                    _DEFAULT_OUTPUT
                }

                std::tuple<int, int> edge() const { return std::make_tuple(_u, _v); }

                void default_output(std::ostream& os) const {
                    if (_swap_node) os << _v << " " << _u ;
                    else os << _u << " " << _v ;     
                }

                _OUTPUT_FUNCTION_SETTING(_Self)
            };
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_EDGE_H_
#ifndef _SGPCET_NODE_H_
#define _SGPCET_NODE_H_

#ifndef _SGPCET_MACRO_H_
#include "basic/macro.h"
#endif // !_SGPCET_MACRO_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename U>
            class _Node {
            protected:
                using _Self = _Node<U>;
                U _w;
                _OUTPUT_FUNCTION(_Self)
            public:
                _Node() : _w(U()) {
                    _DEFAULT_OUTPUT
                }
                _Node(U w) : _w(w) {
                    _DEFAULT_OUTPUT
                }
                
                _SET_GET_VALUE(U, w)
                
                void default_output(std::ostream& os) const {
                    os << _w ;
                }

                _OUTPUT_FUNCTION_SETTING(_Self)
            };
            
            template<>
            class _Node<void> {
            protected:
                using _Self = _Node<void>;
                _OUTPUT_FUNCTION(_Self)
            public:
                _Node(){
                    _DEFAULT_OUTPUT
                }

                void default_output(std::ostream& os) const { return; }

                _OUTPUT_FUNCTION_SETTING(_Self)
            };
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_NODE_H_
#ifndef _SGPCET_GEN_STRATEGY_H_
#define _SGPCET_GEN_STRATEGY_H_

#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif // !_SGPCET_LOGGER_H_

namespace generator {
    namespace tools {
            class _Gen {
            public:
                _Gen(){}
                virtual void generate() {
                    _msg::__fail_msg(_msg::_defl, "unsupport generator.");
                };
            };

            template <typename T>
            class _BasicGen : public _Gen {
            protected:
                T& _context;
            public:
                _BasicGen(T& context) : _context(context) {}
            };

            class _GenSwitch {
            protected:
                _Gen* _generator;
            public:
                _GenSwitch() : _generator(nullptr) {}
                virtual ~_GenSwitch() { __delete_generator(); }

                _SET_GET_VALUE(_Gen*, generator);

            protected:
                void __delete_generator() {
                    if (_generator) delete _generator;
                }
            };
    } // namespace tools
} // namespace generator

#endif // !_SGPCET_GEN_STRATEGY_H_
#ifndef _SGPCET_LINK_FORWARD_H_
#define _SGPCET_LINK_FORWARD_H_

#ifndef _SGPCET_COMMON_H_
#include "basic/common.h"
#endif // !_SGPCET_COMMON_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType> 
            class _LinkImpl;
            
            template<typename NodeType, typename EdgeType>
            class _TreeLinkImpl;

        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_LINK_FORWARD_H_
#ifndef _SGPCET_TREE_STRATEGY_H_
#define _SGPCET_TREE_STRATEGY_H_

#ifndef _SGPCET_COMMON_H_
#include "basic/common.h"
#endif // !_SGPCET_COMMON_H_
#ifndef _SGPCET_MACRO_H_
#include "basic/macro.h"
#endif // !_SGPCET_MACRO_H_
#ifndef _SGPCET_GEN_STRATEGY_H_
#include "basic/gen_strategy.h"
#endif // !_SGPCET_GEN_STRATEGY_H_
#ifndef _SGPCET_NODE_H_
#include "node.h"
#endif // !_SGPCET_NODE_H_
#ifndef _SGPCET_EDGE_H_
#include "edge.h"
#endif // !_SGPCET_EDGE_H_
#ifndef _SGPCET_WEIGHT_TYPE_H_
#include "weight_type.h"
#endif // !_SGPCET_WEIGHT_TYPE_H_
#ifndef _SGPCET_ARRAY_H_
#include "rand/array.h"
#endif // !_SGPCET_ARRAY_H_

namespace generator {
    namespace rand_graph {
        namespace basic {

            template <template <typename, typename> class TreeType, typename NodeType, typename EdgeType>
            class BasicTreeGen : public tools::_BasicGen<TreeType<NodeType, EdgeType>> {
            public:
                BasicTreeGen(TreeType<NodeType, EdgeType>& context) : tools::_BasicGen<TreeType<NodeType, EdgeType>>(context) {}
                virtual void generate() override {                      
                    __init();
                    __generate_tree(); 
                    __generate_nodes_weight();
                    _CONTEXT_GET_REF(edges)
                    shuffle(edges.begin(), edges.end());
                };
            protected:
                virtual void __generate_tree() {
                    _msg::__fail_msg(_msg::_defl, "unsupport tree generator.");
                }

                void __add_edge(_Edge<EdgeType> edge) {
                    _CONTEXT_V_REF(edges).emplace_back(edge);
                }
                
                template<typename T = EdgeType, _NotHasT<T> = 0>
                void __add_edge(int u, int v) {
                    __add_edge(_Edge<void>(u, v));

                }

                template<typename T = EdgeType, _HasT<T> = 0>
                void __add_edge(int u, int v, int w) {
                    __add_edge(_Edge<EdgeType>(u, v, w));
                }
                
                template<typename T = EdgeType, _HasT<T> = 0>
                void __add_edge(int u, int v) {
                    EdgeType w = this->_context.edges_weight_function()();
                    __add_edge(u, v, w);
                }

                void __judge_comman_limit() {
                    _CONTEXT_GET(node_count)
                    if (node_count <= 0) {
                        _msg::__fail_msg(_msg::_defl, 
                            tools::string_format("node_count must be a positive integer, but found %d.", 
                            node_count));
                    }

                    if (node_count > _setting::node_limit) {
                        _msg::__fail_msg(_msg::_defl,
                            tools::string_format("node_count can't greater than node_limit(%d), but found.",
                            _setting::node_limit, node_count));
                    }

                    if (_CONTEXT_V(is_rooted)) {
                        _CONTEXT_GET_REF(root)
                        if (root < 0 || root >= node_count) {
                            _msg::__fail_msg(_msg::_defl,
                                tools::string_format("limit of the root is [1, %d], but found %d.", 
                                node_count, root + 1));                           
                        }
                    }
                }

                virtual void __judge_self_limit() {}

                void __judge_limits() {
                    __judge_comman_limit();
                    __judge_self_limit();
                }
                
                virtual void __self_init(){};
                
                void __init() {
                    __self_init();
                    this->_context.check_gen_function();
                    __judge_limits();
                    _CONTEXT_V_REF(edges).clear();
                    __clear_nodes_weight();    
                    _CONTEXT_GET(node_indices)
                    _CONTEXT_GET(node_count)
                    if ((int)node_indices.size() != node_count) {
                        _msg::__warn_msg(_msg::_defl, 
                            tools::string_format("size of node_indices %d is not equal to node_count %d, use default node_indices.",
                            node_indices.size(), node_count));
                        this->_context.default_node_indices();
                    }
                }
                
                template<typename T = NodeType, _NotHasT<T> = 0>
                void __generate_nodes_weight() { return; }
                
                template<typename T = NodeType, _HasT<T> = 0>
                void __generate_nodes_weight() {
                    for (int i = 0; i < _CONTEXT_V(node_count) ; i++) {
                        NodeType w = this->_context.nodes_weight_function()();
                        this->_context.nodes_weight_ref().emplace_back(w);
                    }
                }

                template <typename T = NodeType, _NotHasT<T> = 0>
                void __clear_nodes_weight() { return; }

                template <typename T = NodeType, _HasT<T> = 0>
                void __clear_nodes_weight() {
                    this->_context.nodes_weight_ref().clear(); 
                }
            };

            template <template <typename, typename> class TreeType, typename NodeType, typename EdgeType>
            class BasicRandomFatherGen : public BasicTreeGen<TreeType, NodeType, EdgeType> {
            protected:
                using Context = TreeType<NodeType, EdgeType>;
                std::vector<int> _rank;
                
            public:
                BasicRandomFatherGen(Context& tree) : BasicTreeGen<TreeType, NodeType, EdgeType>(tree) {}
            protected:
                virtual void __generate_tree() override {
                    __init_rank();
                    __random_father();
                }

                virtual void __init_rank() {
                    int node_count = this->_context.node_count();
                    _rank = rand_array::rand_p(node_count);
                    if (this->_context.is_rooted()) {
                        for (int i = 1; i < node_count; i++) {
                            if (_rank[i] == this->_context.root_ref()) {
                                std::swap(_rank[0], _rank[i]);
                                break;
                            }
                        } 
                    }
                }
                virtual void __random_father() {
                    int node_count = this->_context.node_count();
                    for (int i = 1; i < node_count; i++) {
                        int f = rnd.next(i);
                        this->__add_edge(_rank[f], _rank[i]);
                    }
                }
            };

            template <template <typename, typename> class TreeType, typename NodeType, typename EdgeType>
            class BasicPrueferGen : public BasicTreeGen<TreeType, NodeType, EdgeType> {
            protected:
                using Context = TreeType<NodeType, EdgeType>;
            public:
                BasicPrueferGen(Context& tree) : BasicTreeGen<TreeType, NodeType, EdgeType>(tree) {}
            protected:
                virtual void __generate_tree() override {
                    _CONTEXT_GET(node_count)
                    if (node_count == 1) return;
                    __generate_pruefer();
                }

                virtual void __generate_pruefer() {
                    _CONTEXT_GET(node_count);
                    std::vector<int> times = rand_array::rand_sum(node_count, node_count - 2, 0);
                    std::vector<int> pruefer = rand_array::shuffle_index(times);
                    __pruefer_decode(pruefer);                    
                }
                void __pruefer_decode(std::vector<int> pruefer) {
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(is_rooted)
                    if (node_count == 2) {
                        int u = is_rooted ? _CONTEXT_V_REF(root) : 0;
                        this->__add_edge(u, 1 ^ u);
                        return;
                    }

                    std::vector<int> degree(node_count, 1);
                    for (auto x: pruefer) {
                        degree[x]++;
                    }
                    int ptr = 0;
                    while (degree[ptr] != 1) {
                        ptr++;
                    }
                    int leaf = ptr;
                    for (auto u: pruefer) {
                        this->__add_edge(u, leaf);
                        degree[u]--;
                        if (degree[u] == 1 && u < ptr) {
                            leaf = u;
                        } else {
                            do {
                                ptr++;
                            } while (degree[ptr] != 1);
                            leaf = ptr;
                        }
                    }
                    int u = leaf;
                    int v = node_count - 1;
                    if (is_rooted && v == _CONTEXT_V_REF(root)) {
                        std::swap(u, v);
                    }
                    this->__add_edge(u, v);
                }
            };

            class _TreeGenSwitch : public tools::_GenSwitch {
            public:
                void set_tree_generator(tools::_Gen* gen) {
                    __delete_generator();
                    _generator = gen;
                }
            };

        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_TREE_STRATEGY_H_
#ifndef _SGPCET_GEN_FUNCTION_H_
#define _SGPCET_GEN_FUNCTION_H_

#ifndef _SGPCET_COMMON_H_
#include "basic/common.h"
#endif // !_SGPCET_COMMON_H_
#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif // !_SGPCET_LOGGER_H_
#ifndef _SGPCET_WEIGHT_TYPE_H_
#include "weight_type.h"
#endif // !_SGPCET_WEIGHT_TYPE_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class _RandomFunction {
            protected:
                _DEF_GEN_FUNCTION
                NodeGenFunction _nodes_weight_function;
                EdgeGenFunction _edges_weight_function;
            public:
                _RandomFunction(
                    NodeGenFunction nodes_weight_function,
                    EdgeGenFunction edges_weight_function) :
                    _nodes_weight_function(nodes_weight_function),
                    _edges_weight_function(edges_weight_function) 
                {}
                
                virtual ~_RandomFunction() = default;

                template<typename T = NodeType, _HasT<T> = 0>
                void set_nodes_weight_function(NodeGenFunction nodes_weight_function) {
                    _nodes_weight_function = nodes_weight_function;
                }
                
                template<typename T = EdgeType, _HasT<T> = 0>
                void set_edges_weight_function(EdgeGenFunction edges_weight_function) {
                    _edges_weight_function = edges_weight_function;
                }
                
                _GET_VALUE(NodeGenFunction, nodes_weight_function)
                _GET_VALUE(EdgeGenFunction, edges_weight_function)

                void check_gen_function() {
                    __check_nodes_weight_function();
                    __check_edges_weight_function();
                }

                void check_nodes_weight_function() {
                    __check_nodes_weight_function();
                }

                void check_edges_weight_function() {
                    __check_edges_weight_function();
                }
            protected:
                                                           
                template<typename T = NodeType, _HasT<T> = 0>
                void __check_nodes_weight_function() {
                    if (_nodes_weight_function == nullptr) {
                        _msg::__fail_msg(_msg::_defl, "nodes weight generator function is nullptr, please set it.");
                    }
                }
                
                template<typename T = NodeType, _NotHasT<T> = 0>
                void __check_nodes_weight_function() {}
                
                template<typename T = EdgeType, _HasT<T> = 0>
                void __check_edges_weight_function() {
                    if (_edges_weight_function == nullptr) {
                        _msg::__fail_msg(_msg::_defl, "edges weight generator function is nullptr, please set it.");
                    }
                }
                
                template<typename T = EdgeType, _NotHasT<T> = 0>
                void __check_edges_weight_function() {}
            };

        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_GEN_FUNCTION_H_
#ifndef _SGPCET_BASIC_TREE_GRAPH_H_
#define _SGPCET_BASIC_TREE_GRAPH_H_

#ifndef _SGPCET_NODE_H_
#include "node.h"
#endif // !_SGPCET_NODE_H_
#ifndef _SGPCET_EDGE_H_
#include "edge.h"
#endif // !_SGPCET_NODE_H_
#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif // !_SGPCET_NODE_H_
#ifndef _SGPCET_NUMERIC_H_
#include "rand/numeric.h"
#endif // !_SGPCET_NUMERIC_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            class _BasicTreeGraph {
            protected:
                int _node_count; // the number of nodes in the tree  
                int _begin_node; // index of the first node 

                // output format
                bool _output_node_count;
                bool _swap_node;// true means output `father son` or `son father` by random

                std::vector<int> _node_indices;
                bool _node_indices_changed;
            public:
                _BasicTreeGraph(int node_count, int begin_node, bool output_node_count, bool swap_node):
                    _node_count(node_count),
                    _begin_node(begin_node),
                    _output_node_count(output_node_count),
                    _swap_node(swap_node),
                    _node_indices_changed(false)
                {
                    __init_node_indices();
                }

                virtual ~_BasicTreeGraph() = default;

                void set_node_count(int node_count) { 
                    if (node_count != _node_count) {
                        if (_node_indices_changed) {
                            _msg::__warn_msg(_msg::_defl, 
                                tools::string_format("using default `node_indices` for `node_count` changed (%d -> %d).",
                                _node_count, node_count));                            
                        }
                        _node_count = node_count; 
                        __init_node_indices();               
                    }             
                }
                _GET_VALUE(int, node_count)

                void set_begin_node(int begin_node) { 
                    if (begin_node != _begin_node) {
                        if (_node_indices_changed) {
                            _msg::__warn_msg(_msg::_defl, 
                                tools::string_format("using default `node_indices` for `begin_node` changed (%d -> %d).",
                                _begin_node, begin_node));                            
                        }

                        _begin_node = begin_node;
                        __init_node_indices();                 
                    }                 
                }
                _GET_VALUE(int, begin_node)

                _SET_GET_VALUE(bool, output_node_count)
                _SET_GET_VALUE(bool, swap_node)

                void set_node_indices(std::vector<int> node_indices) {
                    if ((int)node_indices.size() != _node_count) {
                        _msg::__set_fail_msg(_msg::_defl,
                            tools::string_format("size of node_indices must equal to node_count %d, but found %d.", 
                            _node_count, node_indices.size()));
                        return;
                    }
                    _node_indices_changed = true;
                    _node_indices = node_indices;
                }         
                void set_node_indices(int index, int number) {
                    if (index < 1 || index > _node_count) {
                        _msg::__set_fail_msg(_msg::_defl,
                            tools::string_format("node index must in range [1, %d], but found %d.",
                            _node_count, index));
                        return;
                    }
                    if (_node_indices.size() != _node_count) __init_node_indices();
                    _node_indices_changed = true;
                    _node_indices[index - 1] = number;
                }
                _GET_VALUE(std::vector<int>, node_indices)
                void default_node_indices() { __init_node_indices(); }
            protected:
                void __init_node_indices() {
                    _node_indices.clear();
                    for (int i = 0 ; i < _node_count; i++) {
                        _node_indices.emplace_back(i + _begin_node);
                    }
                    _node_indices_changed = false;
                }
            };
            
            class _BasicTree : public _BasicTreeGraph {
            protected:
                
                bool _is_rooted;
                // use if `_is_rooted` is true,
                int _root;
                bool _output_root;    
            public:
                _BasicTree(
                    int node_count, int begin_node, bool is_rooted, int root,
                    bool output_node_count, bool output_root) :
                    _BasicTreeGraph(node_count, begin_node, output_node_count, !is_rooted),
                    _is_rooted(is_rooted),
                    _root(root - 1),
                    _output_root(output_root) {}

                void set_is_rooted(int is_rooted) { 
                    if (_is_rooted != is_rooted) {
                        _swap_node = is_rooted ? false : true;
                        _msg::__warn_msg(_msg::_defl, 
                            tools::string_format("setting `swap_node` to %s, becase `is_rooted` changed!", 
                            (_swap_node ? "true" : "false")));
                    }
                    _is_rooted = is_rooted; 
                }
                _GET_VALUE(bool, is_rooted)

                void set_root(int root) {
                    _root = root - 1;
                    if (!_is_rooted) {
                       _msg::__warn_msg(_msg::_defl, "unrooted Tree, set root is useless."); 
                    }
                }
                int root() const {
                    if (!_is_rooted) {
                        _msg::__warn_msg(_msg::_defl, "unrooted Tree, root is useless.");
                    }
                    return _node_indices[_root];
                }
                
                int& root_ref() {
                    if (!_is_rooted) {
                        _msg::__warn_msg(_msg::_defl, "unrooted Tree, root is useless.");
                    }
                    return _root;
                }

                _SET_GET_VALUE(bool, output_root)
                
            }; 

            class _BasicGraph : public _BasicTreeGraph {
            protected:
                int _edge_count;
                bool _direction;
                bool _multiply_edge;
                bool _self_loop;
                bool _connect;
                bool _output_edge_count; 
            
            public:

                _BasicGraph(int node_count, int edge_count, int begin_node,
                    bool direction, bool multiply_edge, bool self_loop, bool connect,
                    bool swap_node, bool output_node_count, bool output_edge_count) :
                    _BasicTreeGraph(node_count, begin_node, output_node_count, swap_node),
                    _edge_count(edge_count),
                    _direction(direction),
                    _multiply_edge(multiply_edge),
                    _self_loop(self_loop),
                    _connect(connect),
                    _output_edge_count(output_edge_count) {}
                
                _SET_GET_VALUE(int, edge_count)

                void set_direction(bool direction) { 
                    if (_direction != direction) {
                        _swap_node = direction ? false : true;
                        _msg::__warn_msg(_msg::_defl, 
                            tools::string_format("setting `swap_node` to %s, becase `direction` changed!",
                            _swap_node ? "true" : "false"));
                    }
                    _direction = direction; 
                }
                _GET_VALUE(bool, direction)

                _SET_GET_VALUE(bool, multiply_edge)
                _SET_GET_VALUE(bool, self_loop)
                _SET_GET_VALUE(bool, connect)
                _SET_GET_VALUE(bool, output_edge_count)

                virtual long long max_edge_count() {
                    if (this->_node_count == 0) return 0;
                    long long sum = 0;
                    if (this->_multiply_edge) {
                        if (this->_node_count == 1 && !this->_self_loop) return 0;
                        return _setting::edge_count_inf;
                    } else {
                        long long n = (long long)this->_node_count;
                        sum += n * (n - 1) / 2;
                        if (this->_direction) sum *= 2;
                        if (this->_self_loop) sum += n;
                        return sum;
                    }
                };

                virtual long long min_edge_count() {
                    if (this->_node_count == 0) return 0;
                    return this->_connect ? this->_node_count - 1 : 0;
                };

                virtual void rand_edge_count(long long from = _setting::auto_edge_limit, long long to = _setting::auto_edge_limit) {
                    auto p = __edge_from_to_limit(from, to);
                    _edge_count = rand_numeric::rand_int(p.first, p.second); 
                }
            protected:
                std::pair<long long, long long> __edge_from_to_limit(long long from, long long to) {
                    long long l = min_edge_count();
                    long long r = max_edge_count();
                    long long limit = _setting::edge_limit;
                    if (r > limit || r == _setting::edge_count_inf) {
                        r = limit;
                    }                    
                    if (from != _setting::auto_edge_limit) l = std::max(l, from);
                    if (to != _setting::auto_edge_limit) r = std::min(r, to);
                    return std::make_pair(l, r);
                }
            };

        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_BASIC_TREE_GRAPH_H_
#ifndef _SGPCET_GEOMETRY_BASIC_H_
#define _SGPCET_GEOMETRY_BASIC_H_

#ifndef _SGPCET_COMMON_H_
#include "basic/common.h"
#endif //!_SGPCET_COMMON_H_
#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif // !_SGPCET_NODE_H_

namespace generator {
    namespace rand_geometry {
        #if defined(__SIZEOF_INT128__) && __SIZEOF_INT128__ == 16
            using MaxIntType = __int128;
            std::ostream& operator<<(std::ostream& os, __int128 value) {
                if (value < 0) {
                    os << "-";
                    value = -value;
                }

                std::string str;
                while (value > 0) {
                    str.insert(str.begin(), '0' + (value % 10));
                    value /= 10;
                }

                if (str.empty()) {
                    str = "0";
                }

                os << str;
                return os;
            }
        #else
            using MaxIntType = long long;
        #endif
        
        template<typename T>
        struct is_signed_integral {
            static const bool value = std::is_integral<T>::value && !std::is_unsigned<T>::value;
        };
        
        template<typename T>
        struct is_point_type {
            static const bool value = is_signed_integral<T>::value || std::is_floating_point<T>::value;
        };
        
        template<typename T>
        struct _ResultType {
            using type = typename std::conditional<
                is_signed_integral<T>::value,   
                MaxIntType,
                double 
            >::type;
        };
        
        template<typename T>
        using _ResultTypeT = typename _ResultType<T>::type; 
    } // namespace rand_geometry
} // namespace generator

#endif //!_SGPCET_GEOMETRY_BASIC_H_
#ifndef _SGPCET_GEN_TREE_H_
#define _SGPCET_GEN_TREE_H_

#ifndef _SGPCET_BASIC_TREE_GRAPH_H_
#include "basic_tree_graph.h"
#endif // !_SGPCET_BASIC_TREE_GRAPH_H_
#ifndef _SGPCET_GEN_FUNCTION_H_
#include "gen_function.h"
#endif // !_SGPCET_GEN_FUNCTION_H_
#ifndef _SGPCET_TREE_STRATEGY_H_
#include "tree_strategy.h"
#endif // !_SGPCET_TREE_STRATEGY_H_
#ifndef _SGPCET_LINK_FORWARD_H_
#include "link_forward.h"
#endif // !_SGPCET_LINK_FORWARD_H_
#ifndef _SGPCET_ARRAY_H_
#include "rand/array.h"
#endif // !_SGPCET_ARRAY_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class _RandomFuncTree : public _BasicTree, public _RandomFunction<NodeType, EdgeType> {
            protected:
                using _Self =  _RandomFuncTree<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                std::vector<_Edge<EdgeType>> _edges;
                std::vector<_Node<NodeType>> _nodes_weight;          
            public:
                friend class _LinkImpl<NodeType, EdgeType>;
                friend class _TreeLinkImpl<NodeType, EdgeType>;
            public:
                _RandomFuncTree():
                    _BasicTree(0, 1, false, 1, true, true),
                    _RandomFunction<NodeType, EdgeType>(nullptr, nullptr) {}                   

                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                _RandomFuncTree(int node_count, int begin_node, bool is_rooted, int root,
                    NodeGenFunction nodes_weight_function,
                    EdgeGenFunction edges_weight_function) :
                    _BasicTree(node_count, begin_node, is_rooted, root, true, true),
                    _RandomFunction<NodeType, EdgeType>(nodes_weight_function, edges_weight_function)
                {
                    _DEFAULT_OUTPUT
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                _RandomFuncTree(int node_count, int begin_node, bool is_rooted, int root,
                    EdgeGenFunction edges_weight_function) :
                    _BasicTree(node_count, begin_node, is_rooted, root, true, true),
                    _RandomFunction<NodeType, EdgeType>(nullptr, edges_weight_function)
                {
                    _DEFAULT_OUTPUT
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                _RandomFuncTree(int node_count, int begin_node, bool is_rooted, int root,
                    NodeGenFunction nodes_weight_function) :
                    _BasicTree(node_count, begin_node, is_rooted, root, true, true),
                    _RandomFunction<NodeType, EdgeType>(nodes_weight_function, nullptr)
                {
                    _DEFAULT_OUTPUT
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                _RandomFuncTree(int node_count, int begin_node, bool is_rooted, int root) :
                    _BasicTree(node_count, begin_node, is_rooted, root, true, true),
                    _RandomFunction<NodeType, EdgeType>(nullptr, nullptr)
                {
                    _DEFAULT_OUTPUT
                }

                virtual ~_RandomFuncTree() {}

                std::vector<_Edge<EdgeType>> edges() const { return __get_output_edges(); }
                std::vector<_Edge<EdgeType>>& edges_ref() { return _edges; }

                template<typename T = NodeType, _HasT<T> = 0>
                std::vector<_Node<NodeType>> nodes_weight() const { return _nodes_weight; }
                template<typename T = NodeType, _HasT<T> = 0>
                std::vector<_Node<NodeType>>& nodes_weight_ref() { return _nodes_weight; }
                
                void reroot() {
                    __reroot_check();
                    __reroot();
                }

                void reroot(int root) {
                    __reroot_set_check(root);
                    __reroot();
                }
                
                void default_output(std::ostream& os) const {
                    std::vector<int> first_line_vec;
                    if (_output_node_count) {
                        first_line_vec.push_back(_node_count);
                    }
                    if (_is_rooted && _output_root) {
                        first_line_vec.push_back(root());
                    }
                    std::vector<std::string> output_lines{join(first_line_vec)};
                    output_lines.push_back(__nodes_weight_format());
                    std::vector<_Edge<EdgeType>> output_edges = __get_output_edges();
                    for (auto &edge : output_edges) {
                        if (_swap_node && rand_numeric::rand_bool()) {
                            edge.set_swap_node(true);
                        }
                    }
                    output_lines.push_back(join(output_edges, "\n"));

                    output_lines.erase(std::remove(output_lines.begin(), output_lines.end(), ""), output_lines.end());
                    os << join(output_lines, "\n");
                }

                _OUTPUT_FUNCTION_SETTING(_Self)
            protected:

                void __reroot_check() {
                    if (!_is_rooted) {
                        _msg::__warn_msg(_msg::_defl, "unrooted tree can't re-root.");
                        return;
                    } 
                    if ((int)_edges.size() < _node_count - 1) {
                        _msg::__warn_msg(_msg::_defl, "should use gen() to generate tree first.");
                        return;
                    }                                       
                }

                void __reroot_set_check(int root) {
                    __reroot_check();
                    if (root < 1 || root > _node_count) {
                        _msg::__warn_msg(_msg::_defl, 
                            tools::string_format("limit of the root is [1, %d], but found %d.", 
                            _node_count, root));
                        return;
                    }
                    _root = root - 1;
                }

                void __reroot() {
                    std::vector<_Edge<EdgeType>> result;
                    std::vector<std::vector<_Edge<EdgeType>>> node_edges(_node_count);
                    for (auto edge : _edges) {
                        node_edges[edge.u()].emplace_back(edge);
                        node_edges[edge.v()].emplace_back(edge);
                    }
                    std::vector<int> visit(_node_count, 0);
                    std::queue<int> q;
                    q.push(_root);
                    while(!q.empty()) {
                        int u = q.front();
                        q.pop();
                        visit[u] = 1;
                        for (auto& edge : node_edges[u]) {
                            if (edge.u() != u) {
                                std::swap(edge.u_ref(), edge.v_ref());
                            }
                            int v = edge.v();
                            if (visit[v]) {
                                continue;
                            }
                            result.emplace_back(edge);
                            q.push(v);
                        }
                    }
                    shuffle(result.begin(), result.end());
                    _edges = result;       
                }

                template<typename T = EdgeType, _NotHasT<T> = 0>
                std::vector<_Edge<EdgeType>> __get_output_edges() const {
                    std::vector<_Edge<EdgeType>> output_edges;
                    for (const auto& edge : _edges) {
                        output_edges.emplace_back(_node_indices[edge.u()], _node_indices[edge.v()]);
                    }
                    return output_edges;
                }

                template<typename T = EdgeType, _HasT<T> = 0>
                std::vector<_Edge<EdgeType>> __get_output_edges() const {
                    std::vector<_Edge<EdgeType>> output_edges;
                    for (const auto& edge : _edges) {
                        output_edges.emplace_back(_node_indices[edge.u()], _node_indices[edge.v()], edge.w());
                    }
                    return output_edges;
                }

                template<typename T = NodeType, _NotHasT<T> = 0>
                std::string __nodes_weight_format() const {
                    return "";
                }

                template<typename T = NodeType, _HasT<T> = 0>
                std::string __nodes_weight_format() const {
                    return join(_nodes_weight);
                }
            };

            template<typename NodeType, typename EdgeType>
            class _GenTree : public _RandomFuncTree<NodeType, EdgeType>, public _TreeGenSwitch {
            protected:
                using _Self = _GenTree<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                using _TreeGenSwitch::set_tree_generator;
            public:
                _GenTree() : _RandomFuncTree<NodeType, EdgeType>(), _TreeGenSwitch() {}

                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                _GenTree(int node_count, int begin_node, bool is_rooted, int root,
                    NodeGenFunction nodes_weight_function,
                    EdgeGenFunction edges_weight_function) :
                    _RandomFuncTree<NodeType, EdgeType>(node_count, begin_node, is_rooted, root,
                        nodes_weight_function, edges_weight_function),
                    _TreeGenSwitch() {}
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                _GenTree(int node_count, int begin_node, bool is_rooted, int root,
                    EdgeGenFunction edges_weight_function) :
                    _RandomFuncTree<void, EdgeType>(node_count, begin_node, is_rooted, root,
                        edges_weight_function),
                    _TreeGenSwitch() {}
                
                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                _GenTree(int node_count, int begin_node, bool is_rooted, int root,
                    NodeGenFunction nodes_weight_function) :
                    _RandomFuncTree<NodeType, void>(node_count, begin_node, is_rooted, root,
                        nodes_weight_function),
                    _TreeGenSwitch() {}
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                _GenTree(int node_count, int begin_node, bool is_rooted, int root) :
                    _RandomFuncTree<void, void>(node_count, begin_node, is_rooted, root),
                    _TreeGenSwitch() {}

                void gen() { 
                    this->_generator->generate(); 
                    if (this->_is_rooted) this->__reroot();
                }
            };

        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_GEN_TREE_H_
#ifndef _SGPCET_RANGE_FORMAT_H_
#define _SGPCET_RANGE_FORMAT_H_

#ifndef _SGPCET_GEOMETRY_BASIC_H_
#include "geometry_basic.h"
#endif //!_SGPCET_GEOMETRY_BASIC_H_
#ifndef _SGPCET_NUMBER_FORMAT_H_
#include "rand/number_format.h"
#endif //!_SGPCET_NUMBER_FORMAT_H_

namespace generator {
    namespace rand_geometry {
        struct _RangeString {
            std::string range;
            std::string type;
            _RangeString(std::string range = "", std::string type = "") : range(range), type(type) {}

            bool any_type() { return type == ""; }
            bool empty_range() { return range == ""; }
        };

        _RangeString __find_range(std::string s, size_t& pos_start, std::vector<std::string>& types) {
            size_t open = s.find_first_of("[(", pos_start);
            size_t close = s.find_first_of(")]", pos_start);
            if (open == std::string::npos && close == std::string::npos)
                return _RangeString();
            std::string range = s.substr(open, close - open + 1);
            if (open == std::string::npos || close == std::string::npos)
                _msg::__fail_msg(_msg::_defl, "%s is not a vaild range.", range.c_str());
            std::string mark = s.substr(pos_start, open - pos_start);
            pos_start = close + 1;
            std::string range_type = "";
            for (auto& type : types) {
                if (mark.find_first_of(type) != std::string::npos) {
                    if (range_type != "" && range_type != type)
                        return _RangeString(range);
                    range_type = type;
                }
            }
            return _RangeString(range, range_type);
        }

        std::pair<std::string, std::string> __format_xy_range(std::string format) {          
            std::vector<std::string> types = { "xX", "yY" };
            size_t pos_start = 0;
            std::vector<_RangeString> ranges;
            while (pos_start < format.length()) {
                _RangeString range = __find_range(format, pos_start, types);
                if (range.empty_range()) break;
                ranges.push_back(range);
            }
            if (ranges.size() == 0) _msg::__fail_msg(_msg::_defl, "no range found.");
            if (ranges.size() > 2) _msg::__fail_msg(_msg::_defl, "too many ranges found.");
            if (ranges.size() == 1) {
                if (!ranges[0].any_type()) 
                    _msg::__fail_msg(_msg::_defl, tools::string_format("only found %c range.", ranges[0].type[0]));
                return std::make_pair(ranges[0].range, ranges[0].range);
            }
            if (!ranges[0].any_type() && ranges[0].type == ranges[1].type) 
                _msg::__fail_msg(_msg::_defl, tools::string_format("found %c range twice.", ranges[0].type[0]));
            auto result = std::make_pair(ranges[0].range, ranges[1].range);
            // a a
            // a x -> x a
            // a y
            // x a
            // x y
            // y a -> a y
            // y x -> x y
            if (ranges[0].type == types[1] || ranges[1].type == types[0]) std::swap(result.first, result.second);
            return result;
        }
    } // namespace rand_geometry
} // namespace generator

#endif // !_SGPCET_RANGE_FORMAT_H_
#ifndef _SGPCET_GEOMETRY_STRATEGY_H_
#define _SGPCET_GEOMETRY_STRATEGY_H_

#ifndef _SGPCET_MACRO_H_
#include "basic/macro.h"
#endif // !_SGPCET_MACRO_H_
#ifndef _SGPCET_GEN_STRATEGY_H_
#include "basic/gen_strategy.h"
#endif // !_SGPCET_GEN_STRATEGY_H_

namespace generator {
    namespace rand_geometry {
        template<template<typename, typename...> class GeoType, typename T>
        class BasicGeometryGen : public tools::_BasicGen<GeoType<T>> {
        public:
            BasicGeometryGen(GeoType<T>& context) : tools::_BasicGen<GeoType<T>>(context) {}
            virtual void generate() override {                       
                __init();
                __generate_geometry();
            };
        protected:
            virtual void __init() {
                __self_init();
                __judge_limits();
            };

            void __judge_limits() {
                __judge_comman_limit();
                __judge_self_limit();
            } 

            virtual void __judge_comman_limit() {
                _CONTEXT_GET(x_left_limit);
                _CONTEXT_GET(x_right_limit);
                _CONTEXT_GET(y_left_limit);
                _CONTEXT_GET(y_right_limit);
                if (x_left_limit > x_right_limit)
                    _msg::__fail_msg(_msg::_defl, tools::string_format( "range [%s, %s] for x-coordinate is invalid.",
                        std::to_string(x_left_limit).c_str(), std::to_string(x_right_limit).c_str()));
                if (y_left_limit > y_right_limit)
                    _msg::__fail_msg(_msg::_defl, tools::string_format( "range [%s, %s] for y-coordinate is invalid.",
                        std::to_string(y_left_limit).c_str(), std::to_string(y_right_limit).c_str()));
            }

            virtual void __self_init() {}

            virtual void __judge_self_limit() {}

            virtual void __generate_geometry() {
                _msg::__fail_msg(_msg::_defl, "unsupport geometry generator.");
            };

            T __rand_x() { 
                _CONTEXT_GET(x_left_limit);
                _CONTEXT_GET(x_right_limit);
                return rand_numeric::__rand_value<T>(x_left_limit, x_right_limit); 
            }
            T __rand_y() {
                _CONTEXT_GET(y_left_limit);
                _CONTEXT_GET(y_right_limit);
                return rand_numeric::__rand_value<T>(y_left_limit, y_right_limit);
            }
        };

        class _GeometryGenSwitch : public tools::_GenSwitch {
        public:
            void set_geometry_generator(tools::_Gen* gen) {
                __delete_generator();
                _generator = gen;
            }
        };
    } // namespace rand_geometry
} // namespace generator

#endif // !_SGPCET_GEOMETRY_STRATEGY_H_
#ifndef _SGPCET_TREE_H_
#define _SGPCET_TREE_H_

#ifndef _SGPCET_GEN_TREE_H_
#include "gen_tree.h"
#endif // !_SGPCET_GEN_TREE_H_
#ifndef _SGPCET_ENUM_H_
#include "basic/enum.h"
#endif // !_SGPCET_ENUM_H_


namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class Tree;

            template <typename NodeType, typename EdgeType>
            class TreeGen : public BasicTreeGen<Tree, NodeType, EdgeType> {
            public:
                using Context = Tree<NodeType, EdgeType>;
                TreeGen(Context& tree) : BasicTreeGen<Tree, NodeType, EdgeType>(tree) {}
            };

            template <typename NodeType, typename EdgeType>
            class RandomFatherGen : public BasicRandomFatherGen<Tree, NodeType, EdgeType> {
            protected:
                using Context = Tree<NodeType, EdgeType>;        
            public:
                RandomFatherGen(Context& tree) : BasicRandomFatherGen<Tree, NodeType, EdgeType>(tree) {}
            };

            template <typename NodeType, typename EdgeType>
            class PrueferGen : public BasicPrueferGen<Tree, NodeType, EdgeType> {
            protected:
                using Context = Tree<NodeType, EdgeType>;
            public:
                PrueferGen(Context& tree) : BasicPrueferGen<Tree, NodeType, EdgeType>(tree) {}
            };

            template <typename NodeType, typename EdgeType>
            class Tree : public _GenTree<NodeType, EdgeType> {
            protected:
                using _Self =  Tree<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                using _GenTree<NodeType, EdgeType>::set_tree_generator;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                Tree(
                    int node_count = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr,
                    _enum::TreeGenerator tree_generator = _enum::RandomFather) :
                    _GenTree<NodeType, EdgeType>(node_count, begin_node, is_rooted, root,
                        nodes_weight_function, edges_weight_function)
                {
                    _DEFAULT_OUTPUT
                    set_tree_generator(tree_generator);
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                Tree(
                    int node_count = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    EdgeGenFunction edges_weight_function = nullptr,
                    _enum::TreeGenerator tree_generator = _enum::RandomFather) :
                    _GenTree<void, EdgeType>(node_count, begin_node, is_rooted, root, edges_weight_function)
                {
                    _DEFAULT_OUTPUT
                    set_tree_generator(tree_generator);
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                Tree(
                    int node_count = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    _enum::TreeGenerator tree_generator = _enum::RandomFather) :
                    _GenTree<NodeType, void>(node_count, begin_node, is_rooted, root, nodes_weight_function)
                {
                    _DEFAULT_OUTPUT
                    set_tree_generator(tree_generator);
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                Tree(
                    int node_count = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    _enum::TreeGenerator tree_generator = _enum::RandomFather) :
                    _GenTree<void, void>(node_count, begin_node, is_rooted, root)
                {
                    _DEFAULT_OUTPUT
                    set_tree_generator(tree_generator);
                }

                void set_tree_generator(_enum::TreeGenerator tree_generator) {
                    if (tree_generator == _enum::RandomFather) use_random_father();
                    else use_pruefer(); 
                }
                void use_random_father() {
                    this->__delete_generator();
                    this->_generator = new RandomFatherGen<NodeType, EdgeType>(*this);
                }
                void use_pruefer() {
                    this->__delete_generator();
                    this->_generator = new PrueferGen<NodeType, EdgeType>(*this);
                }

                _OUTPUT_FUNCTION_SETTING(_Self)
            };

        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_TREE_H_
#ifndef _SGPCET_PATH_H_
#define _SGPCET_PATH_H_

#ifndef _SGPCET_SETTING_H_
#include "basic/setting.h"
#endif // !_SGPCET_SETTING_H_
#ifndef _SGPCET_MACRO_H_
#include "basic/macro.h"
#endif // !_SGPCET_MACRO_H_
#ifndef _SGPCET_TOOLS_H_
#include "basic/tools.h"
#endif // !_SGPCET_TOOLS_H_
#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif // !_SGPCET_LOGGER_H_

namespace generator {
  namespace io {
    class Path {
    protected:
      std::string _path;
    public:
      Path() : _path("") {}
      Path(const std::string& s) : _path(s) {}
      Path(const char *s) : _path(std::string(s)) {}
      Path(const Path& other) : _path(other._path) {}
      Path(Path&& other) noexcept : _path(std::move(other._path)) {}
      Path(std::string&& s) noexcept : _path(std::move(s)) {}
      Path& operator=(Path&& other) noexcept {
          if (this != &other) _path = std::move(other._path);
          return *this;
      }
      Path& operator=(const Path& other) {
          if (this != &other) _path = other._path;
          return *this;
      }
      Path& operator=(const std::string& s) {
          _path = s;
          return *this;
      }
      
      _SET_GET_VALUE(std::string, path)
      void set_path(const char* path) { _path = std::string(path); }
      void set_path(Path other_path) { _path = other_path.path(); }
      const char* cname() const { return _path.c_str(); }
      
      bool __empty() { return _path.empty(); }
      bool __file_exist() {
        std::ifstream file(_path.c_str());
        bool result = file.is_open();
        if (result) file.close();
        return result;
      }

      void __ensure_file_exist() {
        if (__empty()) return;
        __file_exist();
      }
      
      bool __directory_exists() {
        #ifdef ON_WINDOWS
          struct _stat path_stat;
          if (_stat(_path.c_str(), &path_stat) != 0) return false;
          return (path_stat.st_mode & _S_IFDIR) != 0;
        #else
          struct stat path_stat;
          if (stat(_path.c_str(), &path_stat) != 0) return false;
          return S_ISDIR(path_stat.st_mode);
        #endif
      }
      
      void __unify_split() {
        for (auto& c : _path) 
          if (c == _setting::_other_split)
            c = _setting::_path_split;
      }
      
      Path __folder_path() {
        if (__directory_exists()) return Path(_path);
        __unify_split();
        size_t pos = _path.find_last_of(_setting::_path_split);
        if (pos != std::string::npos) return Path(_path.substr(0, pos));
        return Path();
      }
      
      std::string __file_name() {
        if (!__file_exist()) 
          _msg::__fail_msg(_msg::_defl, 
            tools::string_format("%s is not a file or the file doesn't exist.", _path.c_str()));
        __unify_split();
        size_t pos = _path.find_last_of(_setting::_path_split);
        std::string file_full_name = pos == std::string::npos ? _path : _path.substr(pos + 1);
        size_t pos_s = file_full_name.find_last_of('.');
        std::string file_name = pos_s == std::string::npos ? file_full_name : file_full_name.substr(0, pos_s);
        return file_name;
      }
      
      void full() {
        #ifdef ON_WINDOWS
          char buffer[MAX_PATH];
          if (GetFullPathNameA(_path.c_str(), MAX_PATH, buffer, nullptr) == 0) 
            _msg::__fail_msg(_msg::_defl, tools::string_format("Can't find full path :%s.", _path.c_str()));
        #else
          char buffer[PATH_MAX];
          if (realpath(_path.c_str(), buffer) == nullptr) 
            _msg::__fail_msg(_msg::_defl, tools::string_format("Can't find full path :%s.", _path.c_str()));
        #endif
          _path = std::string(buffer);
      }
      
      Path full_path() {
        Path other;
        other.set_path(_path);
        other.full();
        return other;
      }
      
      void __delete_file() {
        if(this->__file_exist()) std::remove(_path.c_str());
      }
      
      friend std::ostream& operator<<(std::ostream& os, const Path& path) {
        os << path._path;
        return os;
      }
      
      template <typename... Args>
      Path join(const Args&... args) {
      #ifdef ON_WINDOWS
        if (this->__empty()) return tools::string_join(_setting::_path_split, args...);
      #endif // ON_WINDOWS
        std::string path_join = tools::string_join(_setting::_path_split, _path, args...);
        return Path(path_join);
      }
    };
    
    template <typename T, typename... Args>
    Path __path_join(const T& path, const Args &... args) {
      return Path(path).join(args...);
    }
    
    template<typename T>
    struct IsPath {
      static constexpr bool value = std::is_same<T, Path>::value;
    };
    
    template<typename T>
    struct IsPathConstructible {
      static constexpr bool value = std::is_convertible<T, std::string>::value || IsPath<T>::value;
    };

    Path __current_path() {
    #ifdef ON_WINDOWS
        char buffer[MAX_PATH];
        GetModuleFileName(NULL, buffer, MAX_PATH);
    #elif defined(__APPLE__)
        char buffer[PATH_MAX];
        uint32_t size = sizeof(buffer);
        _NSGetExecutablePath(buffer, &size);
    #else
        char buffer[PATH_MAX];
        ssize_t length = readlink("/proc/self/exe", buffer, sizeof(buffer));
        if (length != -1) {
            buffer[length] = '\0';
        }
    #endif
        Path executable_path(buffer);
        return executable_path.__folder_path();
    }

    template <typename T>
    typename std::enable_if<IsPathConstructible<T>::value, Path>::type
    __full_path(T p) {
        Path path(p);
        path.full();
        return path;
    }
    
    bool __create_directory(Path& path) {
        if(path.__directory_exists())  return true;
        return mkdir(path.cname(),0777) == 0;
    }

    void __create_directories(Path path) {
        path.__unify_split();
        std::istringstream ss(path.path());
        std::string token;
        Path current_path("");
        while (std::getline(ss, token, _setting::_path_split)) {
            current_path = __path_join(current_path, token);
        #ifdef ON_WINDOWS
            if(current_path.path().find_first_of( _setting::_path_split) == std::string::npos && current_path.path().back() == ':') continue;
        #else
            if(current_path.path().size() == 1 && current_path.path()[0] ==  _setting::_path_split) continue;
        #endif
            if (!__create_directory(current_path)) 
              _msg::__fail_msg(_msg::_defl, tools::string_format("Error in creating folder : %s.",current_path.cname()));
        }
    }
    
    template<typename T1, typename T2>
    typename std::enable_if<IsPathConstructible<T1>::value && IsPathConstructible<T2>::value, void>::type
    __copy_file(T1 source, T2 destination) {
    #ifdef ON_WINDOWS
        CopyFile(Path(source).cname(), Path(destination).cname(), true);
    #else
        std::string command = tools::string_join(" ", "cp", source, destination);
        std::system(command.c_str());
    #endif
        
    }

  } // namespace io
  
  namespace _msg {
    OutStream::OutStream(const io::Path& path, bool log_same) {
      open(path.path());
      _log_same = log_same;
    }
  } // namespace _msg
}

#endif // !_SGPCET_PATH_H_
#ifndef _SGPCET_COORDINATE_H_
#define _SGPCET_COORDINATE_H_

#ifndef _SGPCET_GEOMETRY_STRATEGY_H_
#include "geometry_strategy.h"
#endif //!_SGPCET_GEOMETRY_STRATEGY_H_
#ifndef _SGPCET_NUMERIC_H_
#include "rand/numeric.h"
#endif //!_SGPCET_NUMERIC_H_
#ifndef _SGPCET_RANGE_FORMAT_H_
#include "range_format.h"
#endif //!_SGPCET_RANGE_FORMAT_H_

namespace generator {
    namespace rand_geometry {
    
        template<typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class Coordinate {
        protected:
            T _x, _y;

            using _Self = Coordinate<T>;
            _OUTPUT_FUNCTION(_Self)
        public:
            Coordinate(T x = 0, T y = 0) : _x(x), _y(y) {
                _DEFAULT_OUTPUT
            }

            Coordinate(const Coordinate<T>& p) : _x(p._x), _y(p._y) {
                _DEFAULT_OUTPUT
            }

            Coordinate(Coordinate<T>&& p) noexcept : _x(std::move(p._x)), _y(std::move(p._y)) {
                _DEFAULT_OUTPUT
            }

            Coordinate<T>& operator=(const Coordinate<T>& p) {
                if (this != &p) {
                    _x = p._x;
                    _y = p._y;
                }
                return *this;
            }

            Coordinate<T>& operator=(Coordinate<T>&& p) noexcept {
                if (this != &p) {
                    _x = std::move(p._x);
                    _y = std::move(p._y);
                }
                return *this;
            } 

            _SET_GET_VALUE(T, x);
            _SET_GET_VALUE(T, y);

            void default_output(std::ostream& os) const {
                os << _x << " " << _y;
            }

            _OUTPUT_FUNCTION_SETTING(_Self)
        };

        template<typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class LimitRange {
        protected:
            T _x_left_limit, _x_right_limit;
            T _y_left_limit, _y_right_limit;
        public:
            LimitRange(T x_left_limit = 0, T x_right_limit = 0, T y_left_limit = 0, T y_right_limit = 0) :
                _x_left_limit(x_left_limit), _x_right_limit(x_right_limit),
                _y_left_limit(y_left_limit), _y_right_limit(y_right_limit) {}

            _SET_GET_VALUE(T, x_left_limit);
            _SET_GET_VALUE(T, x_right_limit);
            _SET_GET_VALUE(T, y_left_limit);
            _SET_GET_VALUE(T, y_right_limit);

            void set_x_limit(T left_limit, T right_limit) {
                _x_left_limit = left_limit;
                _x_right_limit = right_limit;
            }

            void set_x_limit(std::string format) {
                auto range = tools::__format_to_range<T>(format);
                _x_left_limit = range.first;
                _x_right_limit = range.second;
            }

            void set_y_limit(T left_limit, T right_limit) {
                _y_left_limit = left_limit;
                _y_right_limit = right_limit;  
            }

            void set_y_limit(std::string format) {
                auto range = tools::__format_to_range<T>(format);
                _y_left_limit = range.first;
                _y_right_limit = range.second; 
            }

            void set_xy_limit(T left, T right) {
                set_x_limit(left, right);
                set_y_limit(left, right);
            }

            void set_xy_limit(T x_left_limit, T x_right_limit, T y_left_limit, T y_right_limit) {
                set_x_limit(x_left_limit, x_right_limit);
                set_y_limit(y_left_limit, y_right_limit);
            }

            void set_xy_limit(std::string format) {
                auto range = __format_xy_range(format);
                set_x_limit(range.first);
                set_y_limit(range.second);
            }
        };

        template<typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class RandomCoordinate;

        template<typename T>
        class RandomCoordinateGen : public BasicGeometryGen<RandomCoordinate, T> {
        public:
            using Context = RandomCoordinate<T>;
            RandomCoordinateGen(Context& coordinate) : BasicGeometryGen<RandomCoordinate, T>(coordinate) {} 
        protected:
            virtual void __generate_geometry() override {
                _CONTEXT_GET_REF(x);
                _CONTEXT_GET_REF(y);
                _CONTEXT_GET(x_left_limit);
                _CONTEXT_GET(x_right_limit);
                _CONTEXT_GET(y_left_limit);
                _CONTEXT_GET(y_right_limit);
                x = rand_numeric::rand_int<T>(x_left_limit, x_right_limit);
                y = rand_numeric::rand_int<T>(y_left_limit, y_right_limit);
            }

        };

        template<typename T, typename>
        class RandomCoordinate : public Coordinate<T>, public LimitRange<T>, public _GeometryGenSwitch {
        protected:
            using _Self = RandomCoordinate<T>;
            _OUTPUT_FUNCTION(_Self)
        public:
            RandomCoordinate(T x_left_limit = 0, T x_right_limit = 0, T y_left_limit = 0, T y_right_limit = 0) :
                Coordinate<T>(), 
                LimitRange<T>(x_left_limit, x_right_limit, y_left_limit, y_right_limit),
                _GeometryGenSwitch() 
            {
                _GEOMETRY_DEFAULT
            }

            void gen() { 
                this->_generator->generate(); 
            }

            _OUTPUT_FUNCTION_SETTING(_Self)
        protected:
            _DEFAULT_GEOMETRY_GEN_FUNC(RandomCoordinate)
        };

    } // namespace rand_geometry
} // namespace generator

#endif // !_SGPCET_COORDINATE_H_
#ifndef _SGPCET_GRAPH_STRATEGY_H_
#define _SGPCET_GRAPH_STRATEGY_H_

#ifndef _SGPCET_TREE_H_
#include "tree.h"
#endif // !_SGPCET_TREE_H_

namespace generator {
    namespace rand_graph {
        namespace basic {

            template <template <typename, typename> class GraphType, typename NodeType, typename EdgeType>
            class BasicGraphGen : public tools::_BasicGen<GraphType<NodeType, EdgeType>> {
            protected:
                std::map<_BasicEdge, bool> _e;
            public:
                BasicGraphGen(GraphType<NodeType, EdgeType>& context) : tools::_BasicGen<GraphType<NodeType, EdgeType>>(context) {}
                virtual void generate() override {                  
                    __init();
                    __generate_graph(); 
                    __generate_nodes_weight();
                    _CONTEXT_GET_REF(edges)
                    shuffle(edges.begin(), edges.end());
                };

            protected :

                void __judge_setting_limit() {
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(edge_count)
                    if (node_count > _setting::node_limit) {
                        _msg::__fail_msg(_msg::_defl,
                            tools::string_format("node_count can't greater than node_limit(%d), but found %d.",
                            _setting::node_limit, node_count));
                    }
                    if (edge_count > _setting::edge_limit) {
                        _msg::__fail_msg(_msg::_defl,
                            tools::string_format("edge_count can't greater than edge_limit(%d), but found %d.",
                            _setting::edge_limit, edge_count));
                    }                  
                }

                virtual void __judge_upper_limit() {
                    auto upper = this->_context.max_edge_count();
                    _CONTEXT_GET(edge_count)
                    if (upper != _setting::edge_count_inf && edge_count > upper) {
                        _msg::__fail_msg(_msg::_defl, 
                            tools::string_format("edge_count must less than or equal to %lld, but found %d.",
                            upper, edge_count));
                    }                     
                }

                virtual void __judge_lower_limit() {
                    auto lower = this->_context.min_edge_count();
                    _CONTEXT_GET(edge_count)
                    if (edge_count < 0) {
                        _msg::__fail_msg(_msg::_defl, "edge_count must be a non-negative integer.");
                    }
                    if (lower != _setting::edge_count_inf && edge_count < lower) {
                        _msg::__fail_msg(_msg::_defl, 
                            tools::string_format("edge_count must greater than or equal to %lld, but found %d.",
                            lower, edge_count));
                    }
                }

                virtual void __judge_self_limit() {}

                void __judge_limits() {
                    __judge_setting_limit();
                    __judge_upper_limit();
                    __judge_lower_limit();
                    __judge_self_limit();
                }
                
                virtual void __self_init(){};
                
                void __init() {
                    __self_init();
                    this->_context.check_gen_function();
                    __judge_limits();
                    _CONTEXT_V_REF(edges).clear();
                    __clear_nodes_weight();
                    if (!_CONTEXT_V(multiply_edge)) _e.clear();          
                    _CONTEXT_GET(node_indices)
                    _CONTEXT_GET(node_count)
                    if ((int)node_indices.size() != node_count) {
                        _msg::__warn_msg(_msg::_defl, 
                            tools::string_format("size of node_indices %d is not equal to node_count %d, use default node_indices.",
                            node_indices.size(), node_count));
                        this->_context.default_node_indices();
                    }
                }
                
                bool __judge_self_loop(int u, int v) {
                    return !_CONTEXT_V(self_loop) && u == v;
                }

                bool __judge_multiply_edge(int u, int v) {
                    if (_CONTEXT_V(multiply_edge)) return false;
                    if (_e[{u, v}]) return true;
                    return false;
                }

                void __add_edge_into_map(int u, int v) {
                    if (!_CONTEXT_V(multiply_edge)) {
                        _e[{u, v}] = true;
                        if (!_CONTEXT_V(direction)) _e[{v, u}] = true;
                    }
                }
                
                void __add_edge(_Edge<EdgeType> edge) {
                    int u = edge.u();
                    int v = edge.v();
                    __add_edge_into_map(u, v);
                    _CONTEXT_V_REF(edges).emplace_back(edge);
                }
                
                template<typename T = EdgeType, _NotHasT<T> = 0>
                void __add_edge(int u, int v) {
                    __add_edge(_Edge<void>(u, v));
                }

                template<typename T = EdgeType, _HasT<T> = 0>
                void __add_edge(int u, int v) {
                    EdgeType w = this->_context.edges_weight_function()();
                    __add_edge(_Edge<EdgeType>(u, v, w));
                }

                template<typename T = NodeType, _NotHasT<T> = 0>
                void __generate_nodes_weight() { return; }
                
                template<typename T = NodeType, _HasT<T> = 0>
                void __generate_nodes_weight() {
                    for (int i = 0; i < _CONTEXT_V(node_count) ; i++) {
                        NodeType w = this->_context.nodes_weight_function()();
                        this->_context.nodes_weight_ref().emplace_back(w);
                    }
                }

                template<typename T = EdgeType, _NotHasT<T> = 0>
                _Edge<void> __convert_edge(int u, int v) {
                    return _Edge<void>(u, v);
                }

                template<typename T = EdgeType, _HasT<T> = 0>
                _Edge<EdgeType> __convert_edge(int u, int v) {
                    EdgeType w = this->_context.edges_weight_function()();
                    return _Edge<EdgeType>(u, v, w);
                }

                virtual _Edge<EdgeType> __rand_edge() {
                    _CONTEXT_GET(node_count)
                    int u, v;
                    do {
                        u = rnd.next(node_count);
                        v = rnd.next(node_count);
                    } while (__judge_self_loop(u, v) || __judge_multiply_edge(u, v));
                    return this->__convert_edge(u, v);
                }

                virtual void __generate_connect() {
                    _CONTEXT_GET(node_count)
                    Tree<void, void> tree(node_count, 0);
                    tree.gen();
                    std::vector <_Edge<void>>& edge = tree.edges_ref();
                    for (auto& e: edge) __add_edge(e.u(), e.v());
                }

                virtual void __generate_graph() {
                    int m = _CONTEXT_V(edge_count);
                    if (_CONTEXT_V(connect)) {
                        m -= _CONTEXT_V(node_count) - 1;
                        __generate_connect();
                    }
                    while (m--) {
                        __add_edge(__rand_edge());
                    }
                }

                template <typename T = NodeType, _NotHasT<T> = 0>
                void __clear_nodes_weight() { return; }

                template <typename T = NodeType, _HasT<T> = 0>
                void __clear_nodes_weight() {
                    this->_context.nodes_weight_ref().clear(); 
                }
            };

            class _GraphGenSwitch : public tools::_GenSwitch {
            public:
                void set_graph_generator(tools::_Gen* gen) {
                    __delete_generator();
                    _generator = gen;
                }
            };
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_GRAPH_STRATEGY_H_
#ifndef _SGPCET_FILE_H_
#define _SGPCET_FILE_H_

#ifndef _SGPCET_COMMON_H_
#include "basic/common.h"
#endif // !_SGPCET_COMMON_H_
#ifndef _SGPCET_ENUM_H_
#include "basic/enum.h"
#endif // !_SGPCET_ENUM_H_
#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif // !_SGPCET_LOGGER_H_
#ifndef _SGPCET_PATH_H_
#include "path.h"
#endif // !_SGPCET_PATH_H_

namespace generator {
    namespace io {
        static int original_stdin = -1;
        static int original_stdout = -1;
        static int original_stderr = -1;
        
        void __open_input_file(const char* file) {
            if (original_stdin == -1) {
                original_stdin = dup(fileno(stdin));  // 保存原始的 stdin
            }
            if (std::cin.eof()) std::cin.clear();
            if (freopen(file, "r", stdin) == nullptr) {
                _msg::__error_msg(_msg::_defl, tools::string_format("Fail to open file %s.", file));
            }
        }
        
        void __open_output_file(const char* file) {
            if (original_stdout == -1) {
                original_stdout = dup(fileno(stdout));  // 保存原始的 stdout
            }
            fflush(stdout);
            if (freopen(file, "w", stdout) == nullptr) {
                _msg::__error_msg(_msg::_defl, tools::string_format("Fail to open file %s.", file));
            }
        }
        
        void __open_error_file(const char* file) {
            if (original_stderr == -1) {
                original_stderr = dup(fileno(stderr));  // 保存原始的 stderr
            }
            fflush(stderr);
            if (freopen(file, "w", stderr) == nullptr) {
                _msg::__error_msg(_msg::_defl, tools::string_format("Fail to open file %s.", file));
            }
        }
        
        void __open_input_file(Path path) {
            __open_input_file(path.cname());
        }
        
        void __open_output_file(Path path) {
            __open_output_file(path.cname());
        }
        
        void __open_error_file(Path path) {
            __open_error_file(path.cname());
        }
        void __close_input_file_to_console() {
            if (original_stdin != -1) {
                dup2(original_stdin, fileno(stdin));  // 恢复 stdin
                close(original_stdin);
                original_stdin = -1;
            }
        }
        
        void __close_output_file_to_console() {
            fflush(stdout);
            if (original_stdout != -1) {
                dup2(original_stdout, fileno(stdout));  // 恢复 stdout
                close(original_stdout);
                original_stdout = -1;
            }
        }
        
        void __close_error_file_to_console() {
            fflush(stderr);
            if (original_stderr != -1) {
                dup2(original_stderr, fileno(stderr));  // 恢复 stderr
                close(original_stderr);
                original_stderr = -1;
            }
        } 

        char** __split_string_to_char_array(const char* input) {
            char** char_array = nullptr;
            char* cinput = const_cast<char*>(input);
            char* token = strtok(cinput, " ");
            int count = 0;

            while (token != nullptr) {
                char_array = (char**)realloc(char_array, (count + 1) * sizeof(char*));
                char_array[count] = strdup(token);
                ++count;
                token = strtok(nullptr, " ");
            }

            char_array = (char**)realloc(char_array, (count + 1) * sizeof(char*));
            char_array[count] = nullptr;
            return char_array;
        }

        void __free_char_array(char** char_array) {
            if (char_array != nullptr) {
                for (int i = 0; char_array[i] != nullptr; ++i) {
                    free(char_array[i]); 
                }
                free(char_array); 
            }
        }
        
        int __fake_argc(char** fake_argvs) {
            int fake_argc = 0;
            while (fake_argvs[fake_argc] != nullptr) {
                ++fake_argc;
            }
            return fake_argc;    
        }
        
        char** __fake_argv(std::string stage, std::string args = ""){
            args = stage + " " + args;
            return __split_string_to_char_array(args.c_str());
        }
        
        void init_gen(int argc,char* argv[]) {
            registerGen(argc, argv, 1);
        }

        void __set_generator_args(std::string args = "") {
            char** fake_argv = __fake_argv(_setting::_first_generator_argv, args);
            int fake_argc = __fake_argc(fake_argv);
            registerGen(fake_argc, fake_argv , 1);
            __free_char_array(fake_argv);
        }

        void init_gen() {
            __set_generator_args();
        }
        
        void init_checker(int argc,char* argv[]) {
            registerTestlibCmd(argc, argv);
        }

        void __set_checker_args(std::string args = "") {
            char** fake_argv = __fake_argv(_setting::_first_checker_argv, args);
            int fake_argc = __fake_argc(fake_argv);
            registerTestlibCmd(fake_argc, fake_argv);
            __free_char_array(fake_argv);
        }

        void init_checker() {
            __set_checker_args();
        }
        
        void init_validator(int argc,char* argv[]) {
            registerValidation(argc, argv);
        }

        void init_validator() {
            registerValidation();
        }

        void __set_validator_args(std::string args) {
            if (args.empty()) {
                registerValidation();
            }
            else {
                char** fake_argv = __fake_argv(_setting::_first_validator_argv, args);
                int fake_argc = __fake_argc(fake_argv);
                registerValidation(fake_argc, fake_argv);     
                __free_char_array(fake_argv);           
            }
        }
        
        void __set_default_args() {
            __set_generator_args("");
        }
        
        void __set_args(std::string args, _enum::_FuncProgramType type) {
            if (type == _enum::_GENERATOR) __set_generator_args(args);
            else if (type == _enum::_CHECKER) __set_checker_args(args);
            else if (type == _enum::_VALIDATOR) __set_validator_args(args);
            else __set_default_args();
        }
    }
}

#endif
#ifndef _SGPCET_POINT_H_
#define _SGPCET_POINT_H_

#ifndef _SGPCET_COORDINATE_H_
#include "coordinate.h"
#endif //!_SGPCET_COORDINATE_H_

namespace generator {
    namespace rand_geometry {

        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type> 
        class _2Points;

        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class Point : public Coordinate<T> {
        protected:
            using _Self = Point<T>;
            _OUTPUT_FUNCTION(_Self)
        
        public:
            Point() : Coordinate<T>(0, 0) {
                _DEFAULT_OUTPUT
            }

            Point(T x, T y) : Coordinate<T>(x, y) { 
                _DEFAULT_OUTPUT
            }

            Point(const Point<T>& p) : Coordinate<T>(p) {
                _DEFAULT_OUTPUT
            }
            Point(Point<T>&& p) noexcept : Coordinate<T>(std::move(p)) {
                _DEFAULT_OUTPUT
            }
            Point& operator=(const Point<T>& p) {
                if (this != &p) 
                    Coordinate<T>::operator=(p);
                return *this;
            }
            Point& operator=(Point<T>&& p) noexcept {
                if (this!= &p)
                    Coordinate<T>::operator=(std::move(p));
                return *this;
            }
            Point(const _2Points<T>& p) : Coordinate<T>(p.end() - p.start()) {
                _DEFAULT_OUTPUT
            }
            
            Point operator+(const Point& b) const { return Point(this->_x + b._x, this->_y + b._y); }
            Point& operator+=(const Point& b) {
                this->_x += b._x;
                this->_y += b._y;
                return *this;
            }
            Point operator-(const Point& b) const { return Point(this->_x - b._x, this->_y - b._y); }
            Point& operator-=(const Point& b) {
                this->_x -= b._x;
                this->_y -= b._y;
                return *this;
            }
            T& operator[](int idx) {
                if (idx == 0) return this->_x;
                if (idx == 1) return this->_y;
                _msg::__fail_msg(_msg::_defl, "index is out of range.");
            }
            T& operator[](char c) {
                if (c == 'x' || c == 'X') return this->_x;
                if (c == 'y' || c == 'Y') return this->_y;
                _msg::__fail_msg(_msg::_defl, "index is out of range.");

            }
            T& operator[](std::string s) {
                if(s.empty()) _msg::__fail_msg(_msg::_defl,"index s is an empty string.");
                return this->operator[](s[0]);
            }
            bool operator==(const Point<T>& p) const{ return this->_x == p._x && this->_y == p._y; }
            bool operator!=(const Point<T>& p) const{ return !(*this == p); }
            bool operator<(const Point<T>& p) const{ return this->_x < p._x || (this->_x == p._x && this->_y < p._y); }
            bool operator<=(const Point<T>& p) const{ return *this < p || *this == p; }
            bool operator>(const Point<T>& p) const { return !(*this <= p); }
            bool operator>=(const Point<T>& p) const { return !(*this < p); }

            _ResultTypeT<T> operator^(const Point& b) const{ 
                _ResultTypeT<T> x1 = this->x();
                _ResultTypeT<T> y1 = this->y();
                _ResultTypeT<T> x2 = b.x();
                _ResultTypeT<T> y2 = b.y();
                return x1 * y2 - y1 * x2;
            }
            
            _ResultTypeT<T> operator*(const Point& b) const{ 
                _ResultTypeT<T> x1 = this->x();
                _ResultTypeT<T> y1 = this->y();
                _ResultTypeT<T> x2 = b.x();
                _ResultTypeT<T> y2 = b.y();
                return x1 * x2 + y1 * y2;
            }

            _GEOMETRY_IN_RAND_FUNC(RandomCoordinate)
            _OUTPUT_FUNCTION_SETTING(_Self)
        protected:
            void __rand(RandomCoordinate<T>& c) {
                c.gen();
                this->_x = c.x();
                this->_y = c.y();
            }
        };

        _GEOMETRY_OUT_RAND_FUNC(rand_point, Point)        
    }    // namespace rand_geometry
}    // namespace generator
#endif // !_SGPCET_POINT_H_
#ifndef _SGPCET_GEN_GRAPH_H_
#define _SGPCET_GEN_GRAPH_H_

#ifndef _SGPCET_BASIC_TREE_GRAPH_H_
#include "basic_tree_graph.h"
#endif // !_SGPCET_BASIC_TREE_GRAPH_H_
#ifndef _SGPCET_GEN_FUNCTION_H_
#include "gen_function.h"
#endif // !_SGPCET_GEN_FUNCTION_H_
#ifndef _SGPCET_GRAPH_STRATEGY_H_
#include "graph_strategy.h"
#endif // !_SGPCET_GRAPH_STRATEGY_H_
#ifndef _SGPCET_LINK_FORWARD_H_
#include "link_forward.h"
#endif // !_SGPCET_LINK_FORWARD_H_
#ifndef _SGPCET_ARRAY_H_
#include "rand/array.h"
#endif // !_SGPCET_ARRAY_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class _RandomFuncGraph : public _BasicGraph, public _RandomFunction<NodeType, EdgeType> {
            protected:
                using _Self =  _RandomFuncGraph<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                std::vector<_Edge<EdgeType>> _edges;
                std::vector<_Node<NodeType>> _nodes_weight;          
            public:
                friend class _LinkImpl<NodeType, EdgeType>;
                friend class _TreeLinkImpl<NodeType, EdgeType>;
            public:
                _RandomFuncGraph() : 
                    _BasicGraph(0, 0, 1, false, false, false, false, false, true, true),
                    _RandomFunction<NodeType, EdgeType>(nullptr, nullptr) {}

                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                _RandomFuncGraph(int node_count, int edge_count, int begin_node,
                    bool direction, bool multiply_edge, bool self_loop, bool connect, bool swap_node,
                    NodeGenFunction nodes_weight_function,
                    EdgeGenFunction edges_weight_function) :
                    _BasicGraph(node_count, edge_count, begin_node,
                        direction, multiply_edge, self_loop, connect, swap_node, true, true),
                    _RandomFunction<NodeType, EdgeType>(nodes_weight_function, edges_weight_function)
                {
                    _DEFAULT_OUTPUT
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                _RandomFuncGraph(int node_count, int edge_count, int begin_node,
                    bool direction, bool multiply_edge, bool self_loop, bool connect, bool swap_node,
                    EdgeGenFunction edges_weight_function) :
                    _BasicGraph(node_count, edge_count, begin_node,
                        direction, multiply_edge, self_loop, connect, swap_node, true, true),
                    _RandomFunction<NodeType, EdgeType>(nullptr, edges_weight_function)
                {
                    _DEFAULT_OUTPUT
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                _RandomFuncGraph(int node_count, int edge_count, int begin_node,
                    bool direction, bool multiply_edge, bool self_loop, bool connect, bool swap_node,
                    NodeGenFunction nodes_weight_function) :
                    _BasicGraph(node_count, edge_count, begin_node,
                        direction, multiply_edge, self_loop, connect, swap_node, true, true),
                    _RandomFunction<NodeType, EdgeType>(nodes_weight_function, nullptr)
                {
                    _DEFAULT_OUTPUT
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                _RandomFuncGraph(int node_count, int edge_count, int begin_node,
                    bool direction, bool multiply_edge, bool self_loop, bool connect, bool swap_node) :
                    _BasicGraph(node_count, edge_count, begin_node,
                        direction, multiply_edge, self_loop, connect, swap_node, true, true),
                    _RandomFunction<NodeType, EdgeType>(nullptr, nullptr)
                {
                    _DEFAULT_OUTPUT
                }

                virtual ~_RandomFuncGraph() {}

                std::vector<_Edge<EdgeType>> edges() const { return __get_output_edges(); }
                std::vector<_Edge<EdgeType>>& edges_ref() { return _edges; }

                template<typename T = NodeType, _HasT<T> = 0>
                std::vector<_Node<NodeType>> nodes_weight() const { return _nodes_weight; }
                template<typename T = NodeType, _HasT<T> = 0>
                std::vector<_Node<NodeType>>& nodes_weight_ref() { return _nodes_weight; }
                
                void default_output(std::ostream& os) const {
                    std::vector<int> first_line_vec;
                    __format_output_node(first_line_vec);
                    if (_output_edge_count) {
                        first_line_vec.push_back(_edge_count);
                    }
                    std::vector<std::string> output_lines{join(first_line_vec)};
                    output_lines.push_back(__nodes_weight_format());
                    std::vector<_Edge<EdgeType>> output_edges = __get_output_edges();
                    for (auto &edge : output_edges) {
                        if (_swap_node && rand_numeric::rand_bool()) {
                            edge.set_swap_node(true);
                        }
                    }
                    output_lines.push_back(join(output_edges, "\n"));

                    output_lines.erase(std::remove(output_lines.begin(), output_lines.end(), ""), output_lines.end());
                    os << join(output_lines, "\n");
                }

                _OUTPUT_FUNCTION_SETTING(_Self)
            protected:

                template<typename T = EdgeType, _NotHasT<T> = 0>
                std::vector<_Edge<EdgeType>> __get_output_edges() const {
                    std::vector<_Edge<EdgeType>> output_edges;
                    for (const auto& edge : _edges) {
                        output_edges.emplace_back(_node_indices[edge.u()], _node_indices[edge.v()]);
                    }
                    return output_edges;
                }

                template<typename T = EdgeType, _HasT<T> = 0>
                std::vector<_Edge<EdgeType>> __get_output_edges() const {
                    std::vector<_Edge<EdgeType>> output_edges;
                    for (const auto& edge : _edges) {
                        output_edges.emplace_back(_node_indices[edge.u()], _node_indices[edge.v()], edge.w());
                    }
                    return output_edges;
                }

                template<typename T = NodeType, _NotHasT<T> = 0>
                std::string __nodes_weight_format() const {
                    return "";
                }

                template<typename T = NodeType, _HasT<T> = 0>
                std::string __nodes_weight_format() const {
                    return join(_nodes_weight);
                }

                virtual void __format_output_node(std::vector<int>& first_line) const {
                    if (_output_node_count) first_line.push_back(_node_count);
                }
            };

            template<typename NodeType, typename EdgeType>
            class _GenGraph : public _RandomFuncGraph<NodeType, EdgeType>, public _GraphGenSwitch {
            protected:
                using _Self = _GenGraph<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                using _GraphGenSwitch::set_graph_generator;
            public:
                _GenGraph() :  _RandomFuncGraph<NodeType, EdgeType>(), _GraphGenSwitch() {}

                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                _GenGraph(int node_count, int edge_count, int begin_node,
                    bool direction, bool multiply_edge, bool self_loop, bool connect, bool swap_node,
                    NodeGenFunction nodes_weight_function,
                    EdgeGenFunction edges_weight_function) :
                    _RandomFuncGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        direction, multiply_edge, self_loop, connect, swap_node,
                        nodes_weight_function, edges_weight_function),
                    _GraphGenSwitch() {}
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                _GenGraph(int node_count, int edge_count, int begin_node,
                    bool direction, bool multiply_edge, bool self_loop, bool connect, bool swap_node,
                    EdgeGenFunction edges_weight_function) :
                    _RandomFuncGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        direction, multiply_edge, self_loop, connect, swap_node,
                        edges_weight_function),
                    _GraphGenSwitch() {}
                
                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                _GenGraph(int node_count, int edge_count, int begin_node,
                    bool direction, bool multiply_edge, bool self_loop, bool connect, bool swap_node,
                    NodeGenFunction nodes_weight_function) :
                    _RandomFuncGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        direction, multiply_edge, self_loop, connect, swap_node,
                        nodes_weight_function),
                    _GraphGenSwitch() {}
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                _GenGraph(int node_count, int edge_count, int begin_node,
                    bool direction, bool multiply_edge, bool self_loop, bool connect, bool swap_node) :
                    _RandomFuncGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        direction, multiply_edge, self_loop, connect, swap_node),
                    _GraphGenSwitch() {}

                void gen() { this->_generator->generate(); }
            };

        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_GEN_GRAPH_H_
#ifndef _SGPCET_PROGRAM_H_
#define _SGPCET_PROGRAM_H_

#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif // !_SGPCET_LOGGER_H_
#ifndef _SGPCET_FILE_H_
#include "file.h"
#endif // !_SGPCET_FILE_H_

namespace generator {
    namespace io {       
        struct ReturnState {
            int exit_code;
            int time;
        };

        bool __is_error(int return_code) {
            return return_code == _setting::_error_return;
        }
        
        bool __is_success(int return_code) {
            return return_code == EXIT_SUCCESS;
        }

        bool __is_time_limit_inf(int time_limit) {
            return time_limit == _setting::time_limit_inf;
        }

        bool __time_limit_exceed(int time, int time_limit) {
            return !__is_time_limit_inf(time_limit) && time > time_limit;
        }

        int __time_limit_extend(int time_Limit) {
            if (__is_time_limit_inf(time_Limit)) return time_Limit;
            return time_Limit * _setting::time_limit_over_ratio;
        }

        class _Program {
        protected:
            std::string _args;
            bool _enable_default_args;
            std::string _name;
        public:
            _Program() : _args(""), _enable_default_args(true), _name(_setting::_empty_program_name) {}
            _Program(std::string args) : _args(args), _enable_default_args(false), _name(_setting::_empty_program_name) {}
            _Program(const _Program& other) : _args(other._args), _enable_default_args(other._enable_default_args), _name(other._name) {}
            _Program& operator=(const _Program& other) {
                if (this != &other) {
                    _args = other._args;
                    _enable_default_args = other._enable_default_args;
                    _name = other._name;
                }
                return *this;
            }
            _Program(_Program&& other) noexcept : _args(std::move(other._args)), _enable_default_args(other._enable_default_args), _name(std::move(other._name)) {}
            _Program& operator=(_Program&& other) noexcept {
                if (this != &other) {
                    _args = std::move(other._args);
                    _enable_default_args = other._enable_default_args;
                    _name = std::move(other._name);
                }
                return *this;
            }
        protected:
            void __terminate_process(void* process) {
            #ifdef ON_WINDOWS
                TerminateProcess(reinterpret_cast<HANDLE>(process), 0);           
            #else
                pid_t pid = static_cast<pid_t>(reinterpret_cast<long long>(process));
                kill(pid, SIGTERM);
            #endif
            }

            virtual int __run_child_program(Path input, Path output, Path error, _enum::_FuncProgramType type) = 0;

            virtual void __close_files(Path input, Path output, Path error) = 0;

        #ifdef ON_WINDOWS
            virtual ReturnState __run_child_process_program(Path input_file, Path output_file, Path error_file, int time_limit, _enum::_FuncProgramType func_type) = 0;
        #else
            ReturnState __run_child_process_program(Path input_file, Path output_file, Path error_file, int time_limit, _enum::_FuncProgramType func_type) {
                auto start_time = tools::now();
                pid_t pid = fork();         
                if (pid == 0) {
                    __set_default_args();
                    int exit_code = __run_child_program(input_file, output_file, error_file, func_type);
                    __close_files(input_file, output_file, error_file);
                    _exit(exit_code == 0 ? 0 : -1);
                } 
                else if (pid > 0) {
    
                    __set_default_args();
                    auto limit = std::chrono::milliseconds(time_limit);
    
                    int status;
                    
                    if (__is_time_limit_inf(time_limit)) {
                        waitpid(pid, &status, 0);
                    }
                    else {
                        auto result = waitpid(pid, &status, WNOHANG);
                        while (result == 0 && tools::duration_ms(start_time) < limit.count()) {
                            std::this_thread::sleep_for(std::chrono::milliseconds(10));
                            result = waitpid(pid, &status, WNOHANG);
                        }     
                        if (result == 0) {
                            __terminate_process(reinterpret_cast<void*>(pid));
                        }   
                        result = waitpid(pid, &status, WNOHANG);              
                    }
         
                    int exit_status = WEXITSTATUS(status);
                    if (WIFEXITED(status) && exit_status == -1) {     
                        _msg::__warn_msg(_msg::_defl, "Fail to run program or something error.");
                        return {_setting::_error_return, -1};
                    } else {
                        return {exit_status, (int)tools::duration_ms(start_time)};   
                    }    
                         
                } 
                else {
                    _msg::__warn_msg(_msg::_defl, "Fail to fork.");
                    return {_setting::_error_return, -1};
                }            
            }    
        #endif
        public:
            virtual bool __check_program_valid() = 0;

            template<typename T1, typename T2, typename T3>
            typename std::enable_if<
                IsPathConstructible<T1>::value &&
                IsPathConstructible<T2>::value &&
                IsPathConstructible<T3>::value, ReturnState>::type
            __run_program(T1 input_file, T2 output_file, T3 error_file, int time_limit, _enum::_FuncProgramType func_type) {
                if (!__check_program_valid()) return {_setting::_error_return, -1};
                Path input = Path(input_file);
                if (!input.__empty() && !input.__file_exist()) {
                    _msg::__error_msg(_msg::_defl, tools::string_format("Fail to open input file %s.", input.cname()));
                    return {_setting::_error_return, -1};
                }
                Path output = Path(output_file);
                output.__ensure_file_exist();
                Path error = Path(error_file);
                error.__ensure_file_exist();
                int run_time_limit = time_limit == _setting::time_limit_inf ? _setting::time_limit_inf : time_limit + _setting::_extra_run_time;
                return __run_child_process_program(input, output, error, run_time_limit, func_type);
            }

            virtual _Program* __clone() = 0;
            virtual _Program* __clone(const std::string& args) = 0;
            virtual std::string __default_name() = 0;
            virtual std::string __path_or_func() = 0;

            _SET_GET_VALUE(std::string, args)
            template <typename...Args>
            void add_args(const Args&... others) {
                _args = tools::string_join(" ", _args, others...);
            }         
            void clear_args() { _args.clear(); }
            _SET_GET_VALUE(bool, enable_default_args)

            void set_name(const std::string& name) { _name = name; }
            std::string name() {
                if (_name == _setting::_empty_program_name) _name = __default_name();
                return _name;
            }

            std::string get_argv_without_redirection() {
                std::string argv = "";
                int i = 0;
                while (i < _args.size()) {
                    __skip_spaces(_args, i);    
                    if (i >= _args.size()) break;

                    if (_args[i] == '2' && i + 1 < _args.size() && _args[i + 1] == '>') {
                        i += 2;
                        __skip_spaces(_args, i);
                        __parse_token(_args, i); 
                        continue;
                    }

                    if (_args[i] == '<' || _args[i] == '>') {
                        i++;
                        __skip_spaces(_args, i);
                        __parse_token(_args, i); 
                        continue;
                    }

                    std::string token = __parse_token(_args, i);
                   argv += token + " ";
                }
                return argv;
            }

        protected:
            void __skip_spaces(const std::string& s, int& i) {
                while (i < s.size() && std::isspace(s[i])) i++;
            }

            std::string __parse_token(const std::string& s, int& i) {
                std::string token;
                char quote = 0;

                while (i < s.size()) {
                    char c = s[i];

                    if (quote) {
                        if (c == quote) quote = 0; 
                        else token += c;
                    } else {
                        if (c == '\'' || c == '"') quote = c; 
                        else if (std::isspace(c)) break;
                        else token += c;
                    }
                    i++;
                }
                return token;
            }
        };

    } // namespace io
} // namespace generator

#endif // !_SGPCET_PROGRAM_H_
#ifndef _SGPCET_POINTS_H_
#define _SGPCET_POINTS_H_

#ifndef _SGPCET_POINT_H_
#include "point.h"
#endif //!_SGPCET_POINT_H_

namespace generator {
    namespace rand_geometry {

        template<template<typename, typename...> class GeoType, typename T>
        class BasicPolygonGen : public BasicGeometryGen<GeoType, T> {
        public:
            BasicPolygonGen(GeoType<T>& context) : BasicGeometryGen<GeoType, T>(context) {}  
        protected:
            virtual void __add_point(Point<T>& p) {
                _CONTEXT_GET_REF(points);
                points.push_back(p);
            }

            virtual void __judge_self_limit() override {
                _CONTEXT_GET(node_count);
                if (node_count <= 0) {
                    _msg::__fail_msg(_msg::_defl, 
                        tools::string_format("node_count should be greater than 0, but found %d.", node_count));                    
                }
                if (node_count > _setting::node_limit) {
                    _msg::__fail_msg(_msg::_defl,
                        tools::string_format("node_count should be less than node_limit(%d), but found %d.", _setting::node_limit, node_count));
                }
                if (!_CONTEXT_V(same_point)) __judge_max_node_count();
            }

            template<typename F = T, typename std::enable_if<std::is_floating_point<F>::value, int>::type = 0>
            void __judge_max_node_count() {}

            template<typename F = T, typename std::enable_if<is_signed_integral<F>::value, int>::type = 0>
            void __judge_max_node_count() {
                _CONTEXT_GET(node_count);
                _CONTEXT_GET(x_left_limit);
                _CONTEXT_GET(x_right_limit);
                _CONTEXT_GET(y_left_limit);
                _CONTEXT_GET(y_right_limit);
                T x_range = x_right_limit - x_left_limit + 1;
                T y_range = y_right_limit - y_left_limit + 1;
                if (x_range >= node_count || y_range >= node_count) return;
                T max_node_count = x_range * y_range;
                if (max_node_count >= node_count) return;
                _msg::__fail_msg(_msg::_defl,
                    tools::string_format("node_count should be less than or equal to %d, but found %d.", max_node_count, node_count));
            }
        };

        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class RandomPoints;

        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class RandomPointsGen : public BasicPolygonGen<RandomPoints, T> {
        protected:
            std::set<Point<T>> _p;
        public:
            using Context = RandomPoints<T>;
            using Super = BasicPolygonGen<RandomPoints, T>;
            RandomPointsGen(Context& points) : BasicPolygonGen<RandomPoints, T>(points) {}
        protected:
            virtual void __generate_geometry() override {
                _CONTEXT_GET(x_left_limit);
                _CONTEXT_GET(x_right_limit);
                _CONTEXT_GET(y_left_limit);
                _CONTEXT_GET(y_right_limit);
                _CONTEXT_GET(node_count);
                for (int i = 0; i < node_count; i++) {
                    Point<T> p;
                    do {
                        p = rand_point<T>(x_left_limit, x_right_limit, y_left_limit, y_right_limit);
                    } while (this->__judge_same_point(p));
                    this->__add_point(p);
                }
            }
        
            bool __judge_same_point(Point<T>& p) {
                if (_CONTEXT_V(same_point)) return false;
                return _p.find(p) != _p.end();
            }

            virtual void __add_point(Point<T>& p) override {
                if (!_CONTEXT_V(same_point)) _p.insert(p);
                Super::__add_point(p);
            }
            virtual void __self_init() override {
                _CONTEXT_GET_REF(points);
                points.clear();
                if (!_CONTEXT_V(same_point)) _p.clear();
            }
        };

        template <typename T, typename>
        class RandomPoints : public RandomCoordinate<T> {
        protected:
            int _node_count;
            std::vector<Point<T>> _points;
            bool _same_point;
            bool _output_node_count;
        public:
            using _Self = RandomPoints<T>;
            _OUTPUT_FUNCTION(_Self)
        public:
            RandomPoints(int node_count = 1, T x_left_limit = 0, T x_right_limit = 0, T y_left_limit = 0, T y_right_limit = 0) : 
                RandomCoordinate<T>(x_left_limit, x_right_limit, y_left_limit, y_right_limit), 
                _node_count(node_count), _same_point(false), _output_node_count(true)
            {
                _GEOMETRY_DEFAULT
            }
            
            _SET_GET_VALUE(int, node_count);
            _SET_GET_VALUE(bool, output_node_count);
            _SET_GET_VALUE(bool, same_point);
            _SET_GET_VALUE(std::vector<Point<T>>, points);

            void default_output(std::ostream& os) const {
                if (_output_node_count) {
                    os << _node_count << "\n";
                }
                int points_count = 0;
                for (auto p : _points) {
                    os << p;
                    if (++points_count < _node_count) {
                        os << "\n";
                    }
                }
            }

            _OUTPUT_FUNCTION_SETTING(_Self)
        protected:
            _DEFAULT_GEOMETRY_GEN_FUNC(RandomPoints)
        };
    } // namespace rand_geometry
} // namespace generator

#endif //!_SGPCET_POINTS_H_
#ifndef _SGPCET_GRAPH_H_
#define _SGPCET_GRAPH_H_

#ifndef _SGPCET_GEN_GRAPH_H_
#include "gen_graph.h"
#endif // !_SGPCET_GEN_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class Graph;

            template <typename NodeType, typename EdgeType>
            class GraphGen : public BasicGraphGen<Graph, NodeType, EdgeType> {
            protected:
                using Context = Graph<NodeType, EdgeType>;
            public:
                GraphGen(Context& graph) : BasicGraphGen<Graph, NodeType, EdgeType>(graph) {}
            };

            template <typename NodeType, typename EdgeType>
            class Graph : public _GenGraph<NodeType, EdgeType> {
            protected:
                using _Self =  Graph<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                Graph(int node_count = 1, int edge_count = 0, int begin_node = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, true,
                        nodes_weight_function, edges_weight_function) 
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                Graph(int node_count = 1, int edge_count = 0, int begin_node = 1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, true, 
                        edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                Graph(int node_count = 1, int edge_count = 0, int begin_node = 1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, true,
                        nodes_weight_function) 
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                Graph(int node_count = 1, int edge_count = 0, int begin_node = 1) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, true)
                {
                    _TREE_GRAPH_DEFAULT       
                }  
                _OUTPUT_FUNCTION_SETTING(_Self)
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(Graph)
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_GRAPH_H_
#ifndef _SGPCET_COMMAND_FUNC_H_
#define _SGPCET_COMMAND_FUNC_H_

#ifndef _SGPCET_PROGRAM_H_
#include "program.h"
#endif // !_SGPCET_PROGRAM_H_

namespace generator {
    namespace io {
        template<typename T>
        struct IsFunctionConvertible {
            static constexpr bool value = std::is_convertible<T, std::function<void()>>::value;
        };

        class CommandFunc : public _Program {
        private:
            std::function<void()> _func;
            static int _function_count;
        public:
            CommandFunc() : _func(nullptr), _Program() {}
            CommandFunc(CommandFunc&& other) noexcept : _func(other._func), _Program(std::move(other)) {}
            CommandFunc(const CommandFunc& other) : _func(other._func), _Program(other) {}
            CommandFunc& operator=(CommandFunc&& other) noexcept {
                if (this != &other) {
                    _Program::operator=(std::move(other));
                    _func = other._func;
                }
                return *this;
            }
            CommandFunc& operator=(const CommandFunc& other) {
                if (this != &other) {
                    _Program::operator=(other);
                    _func = other._func;
                }
                return *this;
            }

            template<typename T, typename = typename std::enable_if<IsFunctionConvertible<T>::value>::type>
            CommandFunc(T&& func) : _func(std::forward<T>(func)), _Program() {}
            template<typename T, typename = typename std::enable_if<IsFunctionConvertible<T>::value>::type>
            CommandFunc(T&& func, std::string args) : _func(std::forward<T>(func)), _Program(args) {}


        protected:
            virtual std::string __default_name() override {
                _function_count++;
                std::string name = "function" + std::to_string(_function_count);
                return name;
            }

            virtual void __close_files(Path input, Path output, Path error) override {
                if (!input.__empty()) __close_input_file_to_console();
                if (!output.__empty()) __close_output_file_to_console();
                if (!error.__empty()) __close_error_file_to_console();
            }

            virtual int __run_child_program(Path input, Path output, Path error, _enum::_FuncProgramType type) override {
                if (!input.__empty()) __open_input_file(input);
                if (!output.__empty()) __open_output_file(output);
                if (!error.__empty()) __open_error_file(error);
                __set_args(_args, type);
                _func();
                return EXIT_SUCCESS;
            }

        #ifdef ON_WINDOWS
            virtual ReturnState __run_child_process_program(Path input_file, Path output_file, Path error_file, int time_limit, _enum::_FuncProgramType func_type) override {
                __set_default_args();
                if (__is_time_limit_inf(time_limit)) {
                    auto start_time = tools::now();
                    int exit_code = __run_child_program(input_file, output_file, error_file, func_type);
                    __close_files(input_file, output_file, error_file);
                    return {exit_code, (int)tools::duration_ms(start_time)};
                } else {
                    _msg::__error_msg(_msg::_defl, "Unsupport running time limit function in Windows");
                    return {_setting::_error_return, -1};
                }
            }
        #endif // ON_WINDOWS
        
        public:
            _GET_VALUE(std::function<void()>, func)
            template <typename T>
            typename std::enable_if<IsFunctionConvertible<T>::value, void>::type
            set_func(T func) {
                _func = std::function<void()>(func);
            }

            virtual bool __check_program_valid() override {
                return true;
            }

            virtual _Program* __clone() override {
                return new CommandFunc(*this);
            }

            virtual _Program* __clone(const std::string& args) override {
                _Program* program = new CommandFunc(*this);
                program->add_args(args);
                return program;
            }

            virtual std::string __path_or_func() override {
                return "function";
            }

        };

        int CommandFunc::_function_count = 0;

    } // namespace io
    
} // namespace generator


#endif // !_SGPCET_COMMAND_FUNC_H_
#ifndef _SGPCET_COMMAND_PATH_H_
#define _SGPCET_COMMAND_PATH_H_

#ifndef _SGPCET_PROGRAM_H_
#include "program.h"
#endif // !_SGPCET_PROGRAM_H_

namespace generator {
    namespace io {
        class CommandPath : public _Program {
        protected:
            Path _path;
        public:
            CommandPath() : _path(Path()), _Program() {}
            CommandPath(CommandPath&& other) noexcept : _Program(std::move(other)), _path(std::move(other._path)) {}
            CommandPath(const CommandPath& other) : _Program(other), _path(other._path) {}
            CommandPath& operator=(const CommandPath& other) {
                if (this != &other) {
                    _Program::operator=(other);
                    _path = other._path;
                }
                return *this;
            }
            CommandPath& operator=(CommandPath&& other) noexcept {
                if (this != &other) {
                    _Program::operator=(std::move(other));
                    _path = std::move(other._path);
                }
                return *this;
            }

            template<typename T, typename = typename std::enable_if<IsPathConstructible<T>::value>::type>
            CommandPath(T&& s) : _path(std::forward<T>(s)), _Program() {}
            template<typename T, typename = typename std::enable_if<IsPathConstructible<T>::value>::type>
            CommandPath(T&& s, std::string args) : _path(std::forward<T>(s)), _Program(args) {}

        protected:
            virtual std::string __default_name() override {
                return _path.__file_name();
            }
            virtual void __close_files(Path input, Path output, Path error) override {
                return;
            }

            std::string __command() { return tools::string_join(" ", _path.full_path(), _args);}

            virtual int __run_child_program(Path input, Path output, Path error, _enum::_FuncProgramType type) override {
                std::string command = __command();
                if (_enable_default_args) {
                   if (!input.__empty()) command = tools::string_join(" ", command, "<", input);
                   if (!output.__empty()) command = tools::string_join(" ", command, ">", output);
                   if (!error.__empty()) command = tools::string_join(" ", command, "2>", error);
                }
                int code = std::system(command.c_str());
                return code;
            }

            
        #ifdef ON_WINDOWS
            virtual ReturnState __run_child_process_program(Path input_file, Path output_file, Path error_file, int time_limit, _enum::_FuncProgramType func_type) override {
                __set_default_args();
                auto start_time = tools::now();
                SECURITY_ATTRIBUTES sa;
                sa.nLength = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle = TRUE;       
                
                HANDLE hInFile = INVALID_HANDLE_VALUE;
                HANDLE hOutFile = INVALID_HANDLE_VALUE;
                HANDLE hErrorFile = INVALID_HANDLE_VALUE;

                if (!input_file.__empty()) {
                    if (!input_file.__file_exist())  return {_setting::_error_return, -1};
                    hInFile = CreateFileA(input_file.cname(),
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        &sa,
                        OPEN_EXISTING ,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );
                }
                
                if (!output_file.__empty()) {
                    hOutFile = CreateFileA(output_file.cname(),
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        &sa,
                        CREATE_ALWAYS ,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );                
                }

                if (!error_file.__empty()) {
                    hErrorFile = CreateFileA(error_file.cname(),
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        &sa,
                        CREATE_ALWAYS ,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );                
                }

                PROCESS_INFORMATION pi; 
                STARTUPINFOA si;
                BOOL ret = FALSE; 
                DWORD flags = CREATE_NO_WINDOW;

                ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
                ZeroMemory(&si, sizeof(STARTUPINFOA));
                si.cb = sizeof(STARTUPINFOA); 
                si.dwFlags |= STARTF_USESTDHANDLES;
                si.hStdInput = hInFile != INVALID_HANDLE_VALUE ? hInFile : NULL;
                si.hStdError = hErrorFile != INVALID_HANDLE_VALUE ? hErrorFile : NULL;
                si.hStdOutput = hOutFile != INVALID_HANDLE_VALUE ? hOutFile : NULL;
                ret = CreateProcessA(NULL, const_cast<char *>(__command().c_str()), NULL, NULL, TRUE, flags, NULL, NULL, &si, &pi);
                if (ret) 
                {
                    if (__is_time_limit_inf(time_limit))  WaitForSingleObject(pi.hProcess, INFINITE);
                    else if (WaitForSingleObject(pi.hProcess, time_limit) == WAIT_TIMEOUT) __terminate_process(pi.hProcess);
                    DWORD exitCode;
                    GetExitCodeProcess(pi.hProcess, &exitCode);
                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                    if (hInFile != INVALID_HANDLE_VALUE) CloseHandle(hInFile);
                    if (hOutFile != INVALID_HANDLE_VALUE) CloseHandle(hOutFile);
                    if (hErrorFile != INVALID_HANDLE_VALUE) CloseHandle(hErrorFile);
                    return {(int)exitCode, (int)tools::duration_ms(start_time)};
                }
                else {
                    if (hInFile != INVALID_HANDLE_VALUE) CloseHandle(hInFile);
                    if (hOutFile != INVALID_HANDLE_VALUE) CloseHandle(hOutFile);
                    if (hErrorFile != INVALID_HANDLE_VALUE) CloseHandle(hErrorFile);
                    return {_setting::_error_return, -1};
                }   
            }
        #endif
        
        public:
            _GET_VALUE(Path, path)
            template <typename T>
            typename std::enable_if<IsPathConstructible<T>::value, void>::type
            set_path(T path) {
                _path = Path(path);
            }

            virtual bool __check_program_valid() override {
                if (!_path.full_path().__file_exist()) {
                    _msg::__error_msg(_msg::_defl, tools::string_format("File %s not exist.", _path.cname()));
                    return false;
                }
                return true;
            }

            virtual _Program* __clone() override {
                return new CommandPath(*this);
            }

            virtual _Program* __clone(const std::string& args) override {
                _Program* program = new CommandPath(*this);
                program->add_args(args);
                return program;
            }
            
            virtual std::string __path_or_func() override {
                return _path.full_path().path();
            }

        };
    } // namespace io
} // namespace generator

#endif // _SGPCET_COMMAND_PATH_H_
#ifndef _SGPCET_LINE_SEGMENT_H_
#define _SGPCET_LINE_SEGMENT_H_

#ifndef _SGPCET_POINTS_H_
#include "points.h"
#endif //!_SGPCET_POINTS_H_

namespace generator {
    namespace rand_geometry {
        template <typename T, typename>
        class _2Points {
        protected:
            using _Self = _2Points<T>;
            _OUTPUT_FUNCTION(_Self)
            Point<T> _start, _end;
        public:
            _2Points() {
                _DEFAULT_OUTPUT
            }

            _2Points(const Point<T>& start, const Point<T>& end) : _start(start), _end(end) {
                _DEFAULT_OUTPUT
            }

            _SET_GET_VALUE(Point<T>, start)
            _SET_GET_VALUE(Point<T>, end)

            Point<T> to_vector() { return _end - _start; }

            _ResultTypeT<T> operator^(const Point<T>& b) const { return (_end - _start) ^ b; }
            _ResultTypeT<T> operator^(const _2Points<T>& l) const { return (_end - _start) ^ (l._end - l._start); }
            _ResultTypeT<T> operator*(const Point<T>& b) const { return (_end - _start) * b; }
            _ResultTypeT<T> operator*(const _2Points<T>& l) const { return (_end - _start) * (l._end - l._start); }        

            void default_output(std::ostream& os) const {
                os << _start << " " << _end;
            }

            _GEOMETRY_IN_RAND_FUNC(RandomPoints)
            _OUTPUT_FUNCTION_SETTING(_Self)
        protected:
            void __rand(RandomPoints<T>& p) {
                p.set_node_count(2);
                p.set_same_point(false);
                p.gen();
                auto points = p.points();
                _start = points[0];
                _end = points[1];
            }
        }; 

        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class Line : public _2Points<T> {
        protected:
            using _Self = Line<T>;
            _OUTPUT_FUNCTION(_Self)
        public:
            Line() : _2Points<T>() {
                _DEFAULT_OUTPUT
            }
            Line(const Point<T>& start, const Point<T>& end) : _2Points<T>(start, end) {
                _DEFAULT_OUTPUT
            }
            
            _OUTPUT_FUNCTION_SETTING(_Self)
        };

        _GEOMETRY_OUT_RAND_FUNC(rand_line, Line)
        
        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class Segment : public _2Points<T> {
        protected:
            using _Self = Segment<T>;
            _OUTPUT_FUNCTION(_Self)
        public:
            Segment() : _2Points<T>() {
                _DEFAULT_OUTPUT
            }
            Segment(const Point<T>& start, const Point<T>& end) : _2Points<T>(start, end) {
                _DEFAULT_OUTPUT
            }
            
            _OUTPUT_FUNCTION_SETTING(_Self)
        };

        _GEOMETRY_OUT_RAND_FUNC(rand_segment, Segment)
    } // namespace rand_geometry
} // namespace generator

#endif // !_SGPCET_LINE_SEGMENT_H_
#ifndef _SGPCET_LINK_H_
#define _SGPCET_LINK_H_

#ifndef _SGPCET_TREE_H_
#include "tree.h"
#endif // !_SGPCET_TREE_H_
#ifndef _SGPCET_GRAPH_H_
#include "graph.h"
#endif // !_SGPCET_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template <typename U>
            struct IsTreeOrGraph {
                template <typename V>
                static constexpr auto check(V *)
                -> decltype(std::declval<V>().edges(), std::true_type());

                template <typename V>
                static constexpr std::false_type check(...);

                static constexpr bool value =
                        decltype(check<U>(nullptr))::value;
            };

            template <typename NodeType, typename EdgeType>
            class Link;

            template <typename NodeType, typename EdgeType>
            class LinkGen : public BasicGraphGen<Link, NodeType, EdgeType> {
            protected:
                using Context = Link<NodeType, EdgeType>;
                std::vector<std::vector<_Edge<EdgeType>>> _source_edges;
                std::vector<std::vector<_Node<NodeType>>> _source_nodes_weight;
                std::vector<std::vector<int>> _source_node_indices;
                int _source_count;
                std::vector<int> _father;
                std::map<int, std::vector<int>> _connect_parts;
                std::map<std::pair<int, int>, int> _node_merge_map;
                std::vector<int> _source_node_count;
            public:
                LinkGen(Context& graph) : BasicGraphGen<Link, NodeType, EdgeType>(graph), _source_count(0) {}
                
                template<template<typename, typename> class TG>
                void set_target(TG<NodeType, EdgeType>& target) {
                    this->__set_target(target);
                }

                template<template<typename, typename> class TG>
                void add_source(TG<NodeType, EdgeType>& source) {
                    this->__add_source(source);
                }

                virtual void generate() override {
                    this->__merge_source();
                    if (_CONTEXT_V(extra_edges_count)) this->_context.check_edges_weight_function();
                    this->__judge_limits();
                    this->__generate_graph(); 
                    _CONTEXT_GET_REF(edges)
                    shuffle(edges.begin(), edges.end());
                };
            protected:
                template<template<typename, typename> class TG, typename T = NodeType, _HasT<T> = 0>
                void __reset_nodes_weight_function(TG<NodeType, EdgeType>& graph) {
                    auto func = graph.nodes_weight_function();
                    this->_context.set_nodes_weight_function(func);
                }
                
                template<template<typename, typename> class TG, typename T = NodeType, _NotHasT<T> = 0>
                void __reset_nodes_weight_function(TG<NodeType, EdgeType>&) {
                    return;
                }
                
                template<template<typename, typename> class TG, typename T = EdgeType, _HasT<T> = 0>
                void __reset_edges_weight_function(TG<NodeType, EdgeType>& graph) {
                    auto func = graph.edges_weight_function();
                    this->_context.set_edges_weight_function(func);
                }
                
                template<template<typename, typename> class TG, typename T = EdgeType, _NotHasT<T> = 0>
                void __reset_edges_weight_function(TG<NodeType, EdgeType>&) {
                    return;
                }

                void __set_target(_GenGraph<NodeType, EdgeType>& target) {
                   _CONTEXT_V_REF(direction) = target.direction();
                   _CONTEXT_V_REF(connect) = target.connect();
                   _CONTEXT_V_REF(multiply_edge) = target.multiply_edge();
                   _CONTEXT_V_REF(self_loop) = target.self_loop();
                   _CONTEXT_V_REF(output_edge_count) = target.output_edge_count();
                   this->__set_target_common(target);
                }

                void __set_target(_GenTree<NodeType, EdgeType>& target) {
                    _CONTEXT_V_REF(direction) = target.is_rooted();
                    this->__set_target_common(target);
                }

                template<template<typename, typename> class TG>
                void __set_target_common(TG<NodeType, EdgeType>& target) {
                    _CONTEXT_V_REF(swap_node) = target.swap_node();
                    _CONTEXT_V_REF(begin_node) = target.begin_node();
                    _CONTEXT_V_REF(output_node_count) = target.output_node_count();
                    this->__reset_nodes_weight_function(target);
                    this->__reset_edges_weight_function(target);
                }

                template<template<typename, typename> class TG, typename T = NodeType, _HasT<T> = 0>
                void __add_source_nodes_weight(TG<NodeType, EdgeType>& source) {
                    _source_nodes_weight.emplace_back(source.nodes_weight());
                }


                template<template<typename, typename> class TG, typename T = NodeType, _NotHasT<T> = 0>
                void __add_source_nodes_weight(TG<NodeType, EdgeType>&) {
                    return;
                }

                void __init_source(_GenGraph<NodeType, EdgeType>& source) {
                    if (!__is_generated(source)) source.gen();
                }

                void __init_source(_GenTree<NodeType, EdgeType>& source) {
                    if (!__is_generated(source)) source.gen();
                }
                
                template<typename T = NodeType, _NotHasT<T> = 0>
                bool __is_generated(_GenTree<NodeType, EdgeType>& source) {
                    if (source.node_count() - 1 != (int)source.edges_ref().size()) return false;
                    return true;
                }

                template<typename T = NodeType, _HasT<T> = 0>
                bool __is_generated(_GenTree<NodeType, EdgeType>& source) {
                    if (source.node_count() - 1 != (int)source.edges_ref().size()) return false;
                    if (source.node_count() != (int)source.nodes_weight_ref().size()) return false;
                    return true;
                }

                template<typename T = NodeType, _NotHasT<T> = 0>
                bool __is_generated(_GenGraph<NodeType, EdgeType>& source) {
                    if (source.edge_count() != (int)source.edges_ref().size()) return false;
                    return true;
                }

                template<typename T = NodeType, _HasT<T> = 0>
                bool __is_generated(_GenGraph<NodeType, EdgeType>& source) {
                    if (source.edge_count() != (int)source.edges_ref().size()) return false;
                    if (source.node_count() != (int)source.nodes_weight_ref().size()) return false;
                    return true;
                }

                template<template<typename, typename> class TG>
                void __add_source(TG<NodeType, EdgeType>& source) {
                    __init_source(source);
                    _source_edges.emplace_back(source.edges_ref());
                    _source_node_count.emplace_back(source.node_count());
                    _source_node_indices.emplace_back(source.node_indices());
                    __add_source_nodes_weight(source);
                    _source_count++;
                }

                void __generate_connect_part() {
                    std::vector<int> mark_indices;
                    for (auto it : _connect_parts) {
                        mark_indices.emplace_back(it.first);
                    }
                    Tree<void, void> tree(_connect_parts.size(), 0);
                    tree.gen();
                    std::vector<_Edge<void>> edges = tree.edges();
                    for (_Edge<void> edge : edges) {
                        int u = rnd.any(_connect_parts[mark_indices[edge.u()]]);
                        int v = rnd.any(_connect_parts[mark_indices[edge.v()]]);
                        this->__add_edge(u, v);
                    }
                }

                virtual void __generate_graph() override {
                    int m = _CONTEXT_V(extra_edges_count);
                    if (_CONTEXT_V(connect)) {
                        m -= _connect_parts.size() - 1;
                        __generate_connect_part();
                    }
                    while (m--){
                        this->__add_edge(this->__rand_edge());
                    }    
                }

                void __merge_source() {
                    __merge_node_indices();
                    __reset_node_count();
                    __merge_nodes_weight();
                    __merge_edges();
                    __reset_edge_count();
                    __divide_connection_part();
                }

                void __merge_node_indices() {
                    _node_merge_map.clear();    
                    _CONTEXT_GET(link_type); 
                    _CONTEXT_GET_REF(node_indices);
                    node_indices.clear();
                    if (link_type == _enum::LinkType::Dedupe) {
                        std::map<int, int> first_appear;
                        int cnt = 0;
                        for (int i = 0; i < _source_count; i++) {
                            for (int j = 0; j < _source_node_count[i]; j++ ) {
                                int x = _source_node_indices[i][j];
                                if (first_appear.find(x) == first_appear.end()) {
                                    node_indices.emplace_back(x);
                                    first_appear[x] = cnt;
                                    cnt++;
                                }
                                _node_merge_map[std::make_pair(i, j)] = first_appear[x];
                            }
                        }
                    }
                    else {
                        std::vector<int> p;
                        int cnt = 0;
                        for (int i = 0; i < _source_count; i++) {
                            for (int j = 0; j < _source_node_count[i]; j++) {
                                p.emplace_back(cnt);
                                cnt++;
                            }                            
                        }
                        if (link_type == _enum::LinkType::Shuffle) shuffle(p.begin(), p.end());
                        cnt = 0;
                        for (int i = 0; i < _source_count; i++) {
                            for (int j = 0; j < _source_node_count[i]; j++) {
                                _node_merge_map[std::make_pair(i, j)] = p[cnt];
                                cnt++;
                            }
                        }               
                        
                        if (link_type == _enum::LinkType::Direct) {
                            for (int i = 0; i < _source_count; i++) {
                                for (auto x : _source_node_indices[i]) {
                                    node_indices.emplace_back(x);
                                }
                            }
                        }
                        else {
                            cnt = _CONTEXT_V(begin_node);
                            for (int i = 0; i < _source_count; i++) {
                                for (int j = 0; j < _source_node_count[i]; j++) {
                                    node_indices.emplace_back(cnt);
                                    cnt++;
                                }
                            }
                        }
                    }                
                }   

                void __reset_node_count() {
                    _CONTEXT_V_REF(node_count) = _CONTEXT_V(node_indices).size();
                }   

                template<typename T = NodeType, _HasT<T> = 0>
                void __merge_nodes_weight() {
                    _CONTEXT_GET(link_type);
                    _CONTEXT_GET_REF(nodes_weight);
                    nodes_weight.clear();
                    if (link_type == _enum::LinkType::Dedupe) {
                        std::set<int> appear;
                        nodes_weight.resize(_CONTEXT_V(node_count));
                        for (auto& it : _node_merge_map) {
                            if (appear.find(it.second) == appear.end()) {
                                appear.insert(it.second);
                                nodes_weight[it.second] = _source_nodes_weight[it.first.first][it.first.second];
                            }
                        }
                    }
                    else {
                        nodes_weight.resize(_CONTEXT_V(node_count));
                        for (auto& it : _node_merge_map) {
                            nodes_weight[it.second] = _source_nodes_weight[it.first.first][it.first.second];
                        }
                    }
                }

                template<typename T = NodeType, _NotHasT<T> = 0>
                void __merge_nodes_weight() {
                    return;
                }

                void __merge_edges() {
                    _CONTEXT_GET_REF(edges);
                    edges.clear();
                    if (!_CONTEXT_V(multiply_edge)) this->_e.clear();
                    int ignore_edges = 0;
                    for (int i = 0; i < _source_count; i++) {
                        int sz = _source_edges[i].size();
                        for (int j = 0; j < sz; j++) {
                            _Edge<EdgeType> edge = _source_edges[i][j];
                            int& u = edge.u_ref();
                            int& v = edge.v_ref();
                            u = _node_merge_map[std::make_pair(i, u)];
                            v = _node_merge_map[std::make_pair(i, v)];
                            if (this->__judge_multiply_edge(u, v) || this->__judge_self_loop(u, v)) ignore_edges++;
                            else this->__add_edge(edge);
                        }
                    }
                    if (ignore_edges) {
                        _msg::__warn_msg(_msg::_defl, 
                            tools::string_format("ignore %d edge(s) due to the graph's attribute-based conditions.", ignore_edges));
                    }
                }

                void __reset_edge_count() {
                    _CONTEXT_V_REF(edge_count) = _CONTEXT_V(edges).size() + _CONTEXT_V(extra_edges_count);
                }    

                int __find(int x) {
                    if (_father[x] != x) {
                        _father[x] = __find(_father[x]);
                    }
                    return _father[x];
                }

                void __divide_connection_part() {
                    if (!_CONTEXT_V(connect)) { return; }
                    _father.clear();
                    _connect_parts.clear();
                    _CONTEXT_GET(node_count);
                    for (int i = 0; i < node_count; i++) {
                        _father.emplace_back(i);
                    }
                    for (auto edge : _CONTEXT_V_REF(edges)) {
                        int u = edge.u();
                        int v = edge.v();
                        int t1 = __find(u);
                        int t2 = __find(v);
                        if (t1 != t2) {
                            _father[t1] = t2;
                        }
                    }
                    for (int i = 0; i < node_count; i++) {
                        _connect_parts[__find(i)].emplace_back(i);
                    }
                }    
            };

            template <typename NodeType, typename EdgeType>
            class Link : public _GenGraph<NodeType, EdgeType> {
            protected:
                using _Self =  Link<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                int _extra_edges_count;
                _enum::LinkType _link_type;
            public:

                Link(int extra_edge_count = 0, _enum::LinkType link_type = _enum::LinkType::Shuffle) :
                    _GenGraph<NodeType, EdgeType>(), _extra_edges_count(extra_edge_count), _link_type(link_type) 
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<template<typename, typename> class TG, typename Gen = LinkGen<NodeType, EdgeType>>
                void set_target(TG<NodeType, EdgeType>& target) {
                    (dynamic_cast<Gen*>(this->_generator))->set_target(target);
                }

                template<template<typename, typename> class TG, typename Gen = LinkGen<NodeType, EdgeType>>
                void add_source(TG<NodeType, EdgeType>& source) {
                    (dynamic_cast<Gen*>(this->_generator))->add_source(source);
                }

                _SET_GET_VALUE(int, extra_edges_count);
                _SET_GET_VALUE(_enum::LinkType, link_type);

                _OUTPUT_FUNCTION_SETTING(_Self)
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(Link)
            };    
         
            template <typename NodeType, typename EdgeType>
            class TreeLink;          

            template <typename NodeType, typename EdgeType>
            class TreeLinkGen : public BasicTreeGen<TreeLink, NodeType, EdgeType> {
            protected:
                using Context = TreeLink<NodeType, EdgeType>;
                Link<NodeType, EdgeType> _link;
                int _source_count;   

            public:
                TreeLinkGen(Context& tree) : BasicTreeGen<TreeLink, NodeType, EdgeType>(tree), _link(), _source_count(0) {}
                
                void set_target(_GenTree<NodeType, EdgeType>& target) {
                    __set_target(target);
                }

                void add_source(_GenTree<NodeType, EdgeType>& source) {
                    _link.add_source(source);
                    _source_count++;
                }

                virtual void generate() override {
                    _msg::OutStream graph_log(false);
                    _msg::_defl.swap(graph_log);
                    _link.set_target(this->_context);
                    _link.set_extra_edges_count(_source_count -  1);
                    _link.set_link_type(__convert_to_link_type());
                    _link.set_connect(true);
                    _link.gen();
                    __dump_result();
                    _msg::_defl.swap(graph_log);
                };
            protected:
                template<template<typename, typename> class TG, typename T = NodeType, _HasT<T> = 0>
                void __reset_nodes_weight_function(TG<NodeType, EdgeType>& graph) {
                    auto func = graph.nodes_weight_function();
                    this->_context.set_nodes_weight_function(func);
                }
                
                template<template<typename, typename> class TG, typename T = NodeType, _NotHasT<T> = 0>
                void __reset_nodes_weight_function(TG<NodeType, EdgeType>&) {
                    return;
                }
                
                template<template<typename, typename> class TG, typename T = EdgeType, _HasT<T> = 0>
                void __reset_edges_weight_function(TG<NodeType, EdgeType>& graph) {
                    auto func = graph.edges_weight_function();
                    this->_context.set_edges_weight_function(func);
                }
                
                template<template<typename, typename> class TG, typename T = EdgeType, _NotHasT<T> = 0>
                void __reset_edges_weight_function(TG<NodeType, EdgeType>&) {
                    return;
                }

                template<template<typename, typename> class TG>
                void __set_target_common(TG<NodeType, EdgeType>& target) {
                    _CONTEXT_V_REF(swap_node) = target.swap_node();
                    _CONTEXT_V_REF(begin_node) = target.begin_node();
                    _CONTEXT_V_REF(output_node_count) = target.output_node_count();
                    this->__reset_nodes_weight_function(target);
                    this->__reset_edges_weight_function(target);
                }

                void __set_target(_GenTree<NodeType, EdgeType>& target) {
                    _CONTEXT_V_REF(is_rooted) = target.is_rooted();
                    if (_CONTEXT_V(is_rooted)) _CONTEXT_V_REF(root) = target.root_ref();
                    __set_target_common(target);
                } 

                void __set_target(_GenGraph<NodeType, EdgeType>& target) {
                    _CONTEXT_V_REF(is_rooted) = target.direction();
                    __set_target_common(target);
                } 

                _enum::LinkType __convert_to_link_type() {
                    _CONTEXT_GET(link_type);
                    if (link_type == _enum::TreeLinkType::Direct) return _enum::LinkType::Direct;
                    else if(link_type == _enum::TreeLinkType::Increase) return _enum::LinkType::Increase;
                    return _enum::LinkType::Shuffle;
                }

                template<typename T = NodeType, _NotHasT<T> = 0>
                void __dump_nodes_weight() {
                    return;
                }

                template<typename T = NodeType, _HasT<T> = 0>
                void __dump_nodes_weight() {
                    _CONTEXT_V_REF(nodes_weight) = _link.nodes_weight();
                }               
                void __dump_result() {
                    _CONTEXT_V_REF(node_count) = _link.node_count();
                    _CONTEXT_V_REF(node_indices) = _link.node_indices();
                    _CONTEXT_V_REF(begin_node) = _link.begin_node();
                    __dump_nodes_weight();
                    _CONTEXT_V_REF(edges) = _link.edges_ref();
                }
            };

            template <typename NodeType, typename EdgeType>
            class TreeLink : public _GenTree<NodeType, EdgeType> {
            protected:
                using _Self =  TreeLink<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                _enum::TreeLinkType _link_type;
            public:

                TreeLink(_enum::TreeLinkType link_type = _enum::TreeLinkType::Shuffle) :
                    _GenTree<NodeType, EdgeType>(), _link_type(link_type) 
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<template<typename, typename> class TG, typename Gen = TreeLinkGen<NodeType, EdgeType>>
                void set_target(TG<NodeType, EdgeType>& target) {
                    (dynamic_cast<Gen*>(this->_generator))->set_target(target);
                }

                template<template<typename, typename> class TG, typename Gen = TreeLinkGen<NodeType, EdgeType>>
                void add_source(TG<NodeType, EdgeType>& source) {
                    (dynamic_cast<Gen*>(this->_generator))->add_source(source);
                }


                _SET_GET_VALUE(_enum::TreeLinkType, link_type);

                _OUTPUT_FUNCTION_SETTING(_Self)
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(TreeLink)
            };

        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_LINK_H_
#ifndef _SGPCET_CHAIN_H_
#define _SGPCET_CHAIN_H_

#ifndef _SGPCET_TREE_H_
#include "tree.h"
#endif // !_SGPCET_TREE_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class Chain;

            template <typename NodeType, typename EdgeType>
            class ChainGen : public BasicRandomFatherGen<Chain, NodeType, EdgeType> {
            protected:
                using Context = Chain<NodeType, EdgeType>;
            public:
                ChainGen(Context& tree) : BasicRandomFatherGen<Chain, NodeType, EdgeType>(tree) {}
            protected:
                virtual void __random_father() override {
                    for (int i = 1; i < this->_context.node_count(); i++) {
                        this->__add_edge(this->_rank[i - 1], this->_rank[i]);
                    }                     
                }
            };

            template <typename NodeType, typename EdgeType>
            class Chain : public _GenTree<NodeType, EdgeType> {
            protected:
                using _Self =  Chain<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                Chain(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root,
                        nodes_weight_function, edges_weight_function) 
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                Chain(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                Chain(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root, nodes_weight_function) 
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                Chain(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root) 
                {
                    _TREE_GRAPH_DEFAULT       
                }  
                _OUTPUT_FUNCTION_SETTING(_Self)
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(Chain)
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_CHAIN_H_
#ifndef _SGPCET_FLOWER_H_
#define _SGPCET_FLOWER_H_

#ifndef _SGPCET_TREE_H_
#include "tree.h"
#endif // !_SGPCET_TREE_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class Flower;

            template <typename NodeType, typename EdgeType>
            class FlowerGen : public BasicRandomFatherGen<Flower, NodeType, EdgeType> {
            protected:
                using Context = Flower<NodeType, EdgeType>;
            public:
                FlowerGen(Context& tree) : BasicRandomFatherGen<Flower, NodeType, EdgeType>(tree) {}
            protected:
                virtual void __random_father() override {
                    for (int i = 1; i < this->_context.node_count(); i++) {
                        this->__add_edge(this->_rank[0], this->_rank[i]);
                    }                     
                }
            };

            template <typename NodeType, typename EdgeType>
            class Flower : public _GenTree<NodeType, EdgeType> {
            protected:
                using _Self =  Flower<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                Flower(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root,
                        nodes_weight_function, edges_weight_function) 
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                Flower(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                Flower(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root, nodes_weight_function) 
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                Flower(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root) 
                {
                    _TREE_GRAPH_DEFAULT       
                }  
                _OUTPUT_FUNCTION_SETTING(_Self)
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(Flower)
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_FLOWER_H_
#ifndef _SGPCET_CYCLE_GRAPH_H_
#define _SGPCET_CYCLE_GRAPH_H_

#ifndef _SGPCET_GRAPH_H_
#include "graph.h"
#endif // !_SGPCET_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class CycleGraph;

            template <typename NodeType, typename EdgeType>
            class CycleGraphGen : public BasicGraphGen<CycleGraph, NodeType, EdgeType> {
            protected:
                using Context = CycleGraph<NodeType, EdgeType>;
            public:
                CycleGraphGen(Context& graph) : BasicGraphGen<CycleGraph, NodeType, EdgeType>(graph) {}
            
            protected:
                virtual void __self_init() override {
                    this->_context.rand_edge_count();
                }

                virtual void __judge_self_limit() override {
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(edge_count)
                    if (node_count != edge_count) {
                        _msg::__fail_msg(_msg::_defl, 
                            "edge_count must equal to node_count, ",
                            tools::string_format("but found node_count = %d, edge_count = %d.", node_count, edge_count));
                    }
                }

                virtual void __judge_lower_limit() override {
                    _CONTEXT_GET(node_count)
                    if (node_count < 3) {
                        _msg::__fail_msg(_msg::_defl, 
                            "node_count must greater than or equal to 3, ",
                            tools::string_format("but found %d.", node_count));
                    }
                }

                virtual void __generate_graph() override {
                    _CONTEXT_GET(node_count)
                    std::vector<int> p = rnd.perm(node_count);
                    for (int i = 0; i < node_count; i++) {
                        this->__add_edge(p[i], p[(i + 1) % node_count]);
                    }
                }
            };

            template <typename NodeType, typename EdgeType>
            class CycleGraph : public _GenGraph<NodeType, EdgeType> {
            protected:
                using _Self =  CycleGraph<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                CycleGraph(int node_count = 3, int begin_node = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, node_count, begin_node,
                        true, false, false, false, false,
                        nodes_weight_function, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                CycleGraph(int node_count = 3, int begin_node = 1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, node_count, begin_node,
                        true, false, false, false, false, 
                        edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                CycleGraph(int node_count = 3, int begin_node = 1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, node_count, begin_node,
                        true, false, false, false, false,
                        nodes_weight_function)
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                CycleGraph(int node_count = 3, int begin_node = 1) :
                    _GenGraph<NodeType, EdgeType>(node_count, node_count, begin_node,
                        true, false, false, false, false)
                {
                    _TREE_GRAPH_DEFAULT       
                } 
                
                _DISABLE_CONNECT
                _DISABLE_MULTIPLY_EDGE
                _DISABLE_SELF_LOOP
                _DISABLE_EDGE_COUNT
                _OUTPUT_FUNCTION_SETTING(_Self)

                virtual long long min_edge_count() override {
                    return this->_node_count;
                }

                virtual long long max_edge_count() override {
                    return this->_node_count;
                }

            protected:
                _DEFAULT_GRAPH_GEN_FUNC(CycleGraph)
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_CYCLE_GRAPH_H_
#ifndef _SGPCET_NTT_H_
#define _SGPCET_NTT_H_

#ifndef _SGPCET_SETTING_H_
#include "basic/setting.h"
#endif //!_SGPCET_SETTING_H_
#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif //!_SGPCET_LOGGER_H_

namespace generator {
    namespace math {
        template <typename T = long long, T MOD = 998244353, T G = 3>
        class NTT {
        private:
            using i64 = int64_t;
        public:
            static i64 qpow(i64 a, i64 b) {
                i64 res = 1;
                while (b) {
                    if (b & 1) res = (res * a) % MOD;
                    a = (a * a) % MOD;
                    b >>= 1;
                }
                return res;
            }
        
            static i64 inv(i64 a) {
                return qpow(a, MOD - 2);
            }
        
            static void bit_reverse(std::vector<T>& a) {
                int n = a.size();
                for (int i = 1, j = 0; i < n; i++) {
                    int bit = n >> 1;
                    for (; j & bit; bit >>= 1)
                        j ^= bit;
                    j ^= bit;
                    if (i < j)
                        std::swap(a[i], a[j]);
                }
            }
        
            static void transform(std::vector<T>& a, bool inverse = false) {
                int n = a.size();
                bit_reverse(a);
        
                for (int len = 2; len <= n; len <<= 1) {
                    i64 wn = qpow(G, (MOD - 1) / len);
                    if (inverse) wn = inv(wn);
        
                    for (int i = 0; i < n; i += len) {
                        i64 w = 1;
                        for (int j = 0; j < len / 2; j++) {
                            i64 u = a[i + j];
                            i64 v = (w * a[i + j + len / 2]) % MOD;
                            a[i + j] = (u + v) % MOD;
                            a[i + j + len / 2] = (u - v + MOD) % MOD;
                            w = (w * wn) % MOD;
                        }
                    }
                }
        
                if (inverse) {
                    i64 inv_n = inv(n);
                    for (T& x : a) 
                        x = ((i64)x * inv_n) % MOD;
                }
            }
        
            static std::vector<T> multiply(const std::vector<T>& a, const std::vector<T>& b) {
                std::vector<T> fa(a.begin(), a.end()), fb(b.begin(), b.end());
                int n = 1;
                while (n < a.size() + b.size()) n <<= 1;
        
                fa.resize(n);
                fb.resize(n);
                transform(fa, false);
                transform(fb, false);
                for (int i = 0; i < n; i++) fa[i] = ((i64)fa[i] * fb[i]) % MOD;
                transform(fa, true);
                return fa;
            }

            static std::vector<T> square(const std::vector<T>& a) {
                std::vector<T> fa(a.begin(), a.end());
                int n = 1;
                while (n < a.size() * 2) n <<= 1;
                fa.resize(n);
                transform(fa, false);
                for (int i = 0; i < n; i++) fa[i] = ((i64)fa[i] * fa[i]) % MOD;
                transform(fa, true);
                return fa;
            }
        };
        
        template <typename T = long long,  T MOD1 = 998244353, T G1 = 3, T MOD2 = 985661441, T G2 = 3>
        class CrtMultiplier {
        private:
            using i64 = int64_t;
            // 预计算的CRT参数
            static constexpr i64 crt_mod = (i64)MOD1 * (i64)MOD2;
            static i64 m1_inv_m2; // MOD1在MOD2下的逆元
            
            class NTT1 : public NTT<T, MOD1, G1> {};
            class NTT2 : public NTT<T, MOD2, G2> {};
        public:
            CrtMultiplier() = default;
            static std::vector<T> multiply(const std::vector<T>& a, const std::vector<T>& b, i64 base = 10) {
                auto fa1 = NTT1::multiply(a, b);
                auto fa2 = NTT2::multiply(a, b);
                if (fa1.size() != fa2.size()) {
                    _msg::__error_msg(_msg::_defl, "NTT1 and NTT2 result size not equal, NTT1 size: %d, NTT2 size: %d", fa1.size(), fa2.size());
                }
                int n = fa1.size();
                std::vector<i64> res(n);
                for (int i = 0; i < n; i++) {
                    res[i] = crt(fa1[i], fa2[i]);
                }
                
                // 处理进位并规范化
                return normalize(res, base);
            }

            static std::vector<T> square(const std::vector<T>& a, i64 base = 10) {
                auto fa1 = NTT1::square(a);
                auto fa2 = NTT2::square(a);
                if (fa1.size()!= fa2.size()) {
                    _msg::__error_msg(_msg::_defl, "NTT1 and NTT2 result size not equal, NTT1 size: %d, NTT2 size: %d", fa1.size(), fa2.size()); 
                }
                int n = fa1.size();
                std::vector<i64> res(n);
                for (int i = 0; i < n; i++) {
                    res[i] = crt(fa1[i], fa2[i]);
                }
                // 处理进位并规范化
                return normalize(res, base); 
            }
        private:
            // 初始化CRT参数
            static void init_crt() {
                if (m1_inv_m2 == 0) {
                    i64 x, y;
                    exgcd(MOD1, MOD2, x, y);
                    m1_inv_m2 = (x % MOD2 + MOD2) % MOD2;
                }
            }

            // 扩展欧几里得算法
            static void exgcd(i64 a, i64 b, i64& x, i64& y) {
                if (b == 0) {
                    x = 1;
                    y = 0;
                    return;
                }
                exgcd(b, a % b, y, x);
                y -= a / b * x;
            }

            // 中国剩余定理
            static i64 crt(T r1, T r2) {
                init_crt();
                i64 diff = ((i64)r2 - (i64)r1) % MOD2;
                if (diff < 0) diff += MOD2;
                i64 k = (diff * m1_inv_m2) % MOD2;
                return (r1 + k * MOD1) % crt_mod;
            }

            // 规范化结果
            static std::vector<T> normalize(std::vector<i64>& num, i64 base) {
                std::vector<T> res;
                i64 carry = 0;
                for (i64 x : num) {
                    x += carry;
                    res.push_back(x % base);
                    carry = x / base;
                }
                while (carry > 0) {
                    res.push_back(carry % base);
                    carry /= base; 
                }
                while (res.size() > 1 && res.back() == 0) {
                    res.pop_back();
                }
                return res;
            }
        };
        template <typename T, T MOD1, T G1, T MOD2, T G2>
        int64_t CrtMultiplier<T, MOD1, G1, MOD2, G2>::m1_inv_m2 = 0;
    } // namespace math

} // namespace generator

#endif // !_SGPCET_NTT_H_
#ifndef _SGPCET_IO_INIT_H_
#define _SGPCET_IO_INIT_H_

#ifndef _SGPCET_COMMAND_PATH_H_
#include "command_path.h"
#endif // !_SGPCET_COMMAND_PATH_H_
#ifndef _SGPCET_COMMAND_FUNC_H_
#include "command_func.h"
#endif // !_SGPCET_COMMAND_FUNC_H_

namespace generator {
    namespace io {

        template<typename T>
        struct IsCommandPathConstructible {
            static constexpr bool value = std::is_constructible<T, CommandPath>::value;
        };
        
        template<typename T>
        struct IsCommandFuncConstructible {
            static constexpr bool value = std::is_constructible<T, CommandFunc>::value;
        };

        template<typename T>
        struct IsCommandPath {
            static constexpr bool value = std::is_same<T, CommandPath>::value;
        };
        
        template<typename T>
        struct IsCommandFunc {
            static constexpr bool value = std::is_same<T, CommandFunc>::value;
        }; 
        
        template<typename T>
        struct IsProgram {
            static constexpr bool value = std::is_base_of<_Program, T>::value;
        };
        
        template<typename T>
        struct IsProgramConstructible {
            static constexpr bool value = 
                IsCommandPathConstructible<T>::value || 
                IsCommandFuncConstructible<T>::value || 
                IsPathConstructible<T>::value || 
                IsFunctionConvertible<T>::value;
        };

        template<bool...> struct BoolPack;
        template<bool... Args> 
        using ArgsAllTrue = std::is_same<BoolPack<Args..., true>, BoolPack<true, Args...>>;

        void __ensure_file_folder(Path file) {
            __create_directories(file.__folder_path());
        }                           

        Path __testcases_folder() {
            return __path_join(__current_path(), _setting::testcase_folder);
        }

        std::string _file_end[_enum::_MAX_END] = {
            _setting::input_suffix,
            _setting::output_suffix,
            ".ans",
            ".log",
            ".logc",
            ".exe",
            ".val",
            ".check"
        };

        void __check_input_output_suffix() {
            if (_setting::input_suffix != _file_end[_enum::_IN]) _file_end[_enum::_IN] = _setting::input_suffix;
            if (_setting::output_suffix != _file_end[_enum::_OUT]) _file_end[_enum::_OUT] = _setting::output_suffix;
        }

        std::string __end_with(int x, _enum::_End end) {
            __check_input_output_suffix();
            return std::to_string(x) + _file_end[end];
        }
        
        std::string __end_with(const char* text, _enum::_End end) {
            __check_input_output_suffix();
            return std::string(text) + _file_end[end];
        }
        
        std::string __end_with(std::string text, _enum::_End end) {
            __check_input_output_suffix();
            return text + _file_end[end];
        }

        Path __input_file_path(Path folder, int x) {
            return __path_join(folder, __end_with(x, _enum::_IN));
        }
        
        Path __output_file_path(Path folder, int x) {
            return __path_join(folder, __end_with(x, _enum::_OUT));
        }

        Path __testcase_input_file_path(int x) {
            return __input_file_path(__testcases_folder(), x);
        }
        
        Path __testcase_output_file_path(int x) {
            return __output_file_path(__testcases_folder(), x);
        }

        bool __input_file_exists(Path folder, int x) {
            return __input_file_path(folder, x).__file_exist();
        }
        
        bool __output_file_exists(Path folder, int x) {
            return __output_file_path(folder, x).__file_exist();
        }

        bool __testcase_input_file_exists(int x) {
            return __testcase_input_file_path(x).__file_exist();
        }
        
        bool __testcase_output_file_exists(int x) {
            return __testcase_output_file_path(x).__file_exist();
        }

        std::vector<int> __get_all_inputs(std::string case_name = _setting::testcase_folder) {
            std::vector<int> inputs;
            Path folder_path = __path_join(__current_path(), case_name);
        #ifdef ON_WINDOWS
            WIN32_FIND_DATA findFileData;
            std::string inputs_format = "*" + _setting::input_suffix;
            HANDLE hFind = FindFirstFile(folder_path.join(inputs_format).cname(), &findFileData);

            if (hFind != INVALID_HANDLE_VALUE) {
                do {
                    Path file_path(__path_join(folder_path,findFileData.cFileName));
                    int num = std::stoi(file_path.__file_name());  
                    inputs.emplace_back(num);  
                } while (FindNextFile(hFind, &findFileData) != 0);

                FindClose(hFind);
            }
        #else
            DIR* dir = opendir(folder_path.cname());
            if (dir != nullptr) {
                struct dirent* entry;
                while ((entry = readdir(dir)) != nullptr) {
                    std::string file_name = entry->d_name;
                    size_t suffix_len = _setting::input_suffix.size();
                    if (file_name.size() >= suffix_len && file_name.substr(file_name.size() - suffix_len) == _setting::input_suffix) {
                        int num = std::stoi(file_name.substr(0, file_name.size() - suffix_len));
                        inputs.emplace_back(num);
                    }
                }
                closedir(dir);
            }
        #endif

            return inputs;
        } 

        template<typename T>
        typename std::enable_if<IsProgram<T>::value, _Program*>::type
        __program(T program) {
            return program.__clone();
        }

        template<typename T>
        typename std::enable_if<IsProgram<T>::value, _Program*>::type
        __program(T* program) {
            return program->__clone();
        }
        
        template<typename T>
        typename std::enable_if<IsFunctionConvertible<T>::value, _Program*>::type
        __program(const T& program) {
            return new CommandFunc(program);
        }
        
        template<typename T>
        typename std::enable_if<IsPathConstructible<T>::value, _Program*>::type
        __program(const T& program) {
            return new CommandPath(program);
        }

        template<typename T>
        _Program* __generator_program(T&& program, int x, bool hack = false) {
            _Program* p = __program(std::forward<T>(program));
            if (p->enable_default_args()) {
                if (hack) p->add_args(_setting::default_hack_stable_seed + std::to_string(x));
                else p->add_args(_setting::default_stable_seed + std::to_string(x));
            }
            return p;
        }

        template<typename T>
        _Program* __result_program(T&& program) {
            return __program(std::forward<T>(program));
        }

        template<typename T>
        struct IsDefaultChecker {
            static constexpr bool value = std::is_same<T, _enum::Checker>::value;
        };

        template<typename T>
        struct IsCheckerConstructible {
            static constexpr bool value = IsDefaultChecker<T>::value || IsProgramConstructible<T>::value;
        };

        std::string checker_name[_enum::MaxChecker] = {
          "lcmp",
          "yesno",
          "rcmp4",
          "rcmp6",
          "rcmp9",
          "wcmp"  
        };

        Path __get_default_checker_file(_enum::Checker checker) {
            Path folder_path(__full_path(__path_join(Path(__lib_path()).__folder_path(), _setting::_checker_folder)));
        #ifdef ON_WINDOWS
            Path checker_path(__path_join(folder_path, _setting::_sub_checker_folder, __end_with(checker_name[checker], _enum::_EXE)));
        #else
            Path checker_path(__path_join(folder_path, _setting::_sub_checker_folder, checker_name[checker]));
        #endif
            return checker_path;
        }

        template<typename T>
        typename std::enable_if<!IsDefaultChecker<T>::value, _Program*>::type
        __checker_program(T&& program) {
            return __program(std::forward<T>(program));
        }

        template<typename T>
        typename std::enable_if<IsDefaultChecker<T>::value, _Program*>::type
        __checker_program(T&& program) {
            _Program* func = new CommandPath(__get_default_checker_file(program));
            return func;
        }
        
        Path __compare_folder() {
            return __path_join(__current_path(), _setting::compare_folder);
        }

        Path __hack_folder() {
            return __path_join(__current_path(), _setting::hack_folder);
        }

        template<typename T>
        _Program* __validator_program(T&& program) {
            return __program(std::forward<T>(program));
        }
        
        Path __validate_folder(std::string case_name) {
            return __path_join(__current_path(), _setting::validate_folder, case_name);
        }

        int _judge_result_priority[__state_index(_enum::_JudgeState::_JUDGE_STATE_MAX)] = {
            0, // UNKNOWN
            1, // AC
            2, // WA
            6, // RE
            5, // TLE
            3, // TLE AC
            4  // TLE WA
        };

    } // namespace generator
} // namespace io

#endif // !_SGPCET_IO_INIT_H_
#ifndef _SGPCET_GEOMETRY_ALGORITHM_H_
#define _SGPCET_GEOMETRY_ALGORITHM_H_

#ifndef _SGPCET_POINT_H_
#include "point.h"
#endif //!_SGPCET_POINT_H_
#ifndef _SGPCET_LINE_SEGMENT_H_
#include "line_segment.h"
#endif //!_SGPCET_LINE_SEGMENT_H_

namespace generator {
    namespace rand_geometry {
    
    template <typename T>
    typename std::enable_if<is_point_type<T>::value, int>::type
    __quadrant(Point<T> p) {
        return ((p.y() < 0) << 1) | ((p.x() < 0) ^ (p.y() < 0));
    }

    template <typename T>
    typename std::enable_if<is_point_type<T>::value, void>::type        
    __polar_angle_sort(std::vector<Point<T>>& points, Point<T> o = Point<T>()) {
        std::sort(points.begin(), points.end(), [&](Point<T> a, Point<T> b) {
            Point<T> oa = a - o;
            Point<T> ob = b - o;
            int quadrant_a = __quadrant(oa);
            int quadrant_b = __quadrant(ob);
            if (quadrant_a == quadrant_b) {
                _ResultTypeT<T> cross = oa ^ ob;
                if (cross == 0) return a.x() < b.x();
                return cross > 0;
            }
            return quadrant_a < quadrant_b;
        });
    }

    template <typename T>
    _enum::PointDirection point_direction(Point<T> a, Point<T> b, Point<T> c) {
        b = b - a;
        c = c - a;
        _ResultTypeT<T> cross = b ^ c;
        if (cross > 0) return _enum::COUNTER_CLOCKWISE;
        if (cross < 0) return _enum::CLOCKWISE;
        if (b * c < 0) return _enum::ONLINE_BACK;
        if (b * b < c * c) return _enum::ONLINE_FRONT;
        return _enum::ON_SEGMENT;
    }
    
    template <typename T>
    _enum::PointDirection point_direction(Point<T> a, Segment<T> s) {
        return point_direction(a, s.start, s.end);
    }

    } // namespace rand_geometry
} // namespace generator

#endif // !_SGPCET_GEOMETRY_ALGORITHM_H_
#ifndef _SGPCET_START_REACHABLE_GRAPH_H_
#define _SGPCET_START_REACHABLE_GRAPH_H_

#ifndef _SGPCET_GRAPH_H_
#include "graph.h"
#endif // !_SGPCET_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template <typename NodeType, typename EdgeType>
            class StartReachableGraph;

            template <typename NodeType, typename EdgeType>
            class StartReachableGraphGen : public BasicGraphGen<StartReachableGraph, NodeType, EdgeType> {
            protected:
                using Context = StartReachableGraph<NodeType, EdgeType>;
            public: 
                StartReachableGraphGen(Context& context) : BasicGraphGen<StartReachableGraph, NodeType, EdgeType>(context) {}
            protected:
                virtual void __generate_connect() override {
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET_REF(start)
                    Tree<void, void> tree(node_count, 0, true, start + 1);
                    tree.gen();
                    std::vector <_Edge<void>>& edge = tree.edges_ref();
                    for (auto& e: edge) this->__add_edge(e.u(), e.v());                   
                }
            };

            template <typename NodeType, typename EdgeType>
            class StartReachableGraph : public _GenGraph<NodeType, EdgeType> {
            protected:
                using _Self = StartReachableGraph<NodeType, EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                int _start;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                StartReachableGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int start = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        true, false, false, true, false,
                        nodes_weight_function, edges_weight_function),
                    _start(start - 1)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                StartReachableGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int start = 1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        true, false, false, true, false,
                        edges_weight_function),
                    _start(start - 1)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                StartReachableGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int start = 1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        true, false, false, true, false,
                        nodes_weight_function),
                    _start(start - 1)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                StartReachableGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int start = 1) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        true, false, false, true, false),
                    _start(start - 1)
                {
                    _TREE_GRAPH_DEFAULT 
                }

                _GET_VALUE_REF(int, start)
                void set_start(int start) {
                    if (start < 1 || start > this->_node_count) {
                        _msg::__set_fail_msg(_msg::_defl, tools::string_format("start index should in range[1, %d], but found %d.", 
                            this->_node_count, start));
                        return;
                    }
                    _start = start - 1;
                }

                int start() { return this->_node_indices[_start];}

                _OUTPUT_FUNCTION_SETTING(_Self)
                _DISABLE_CONNECT
                _DISABLE_DIRECTION
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(StartReachableGraph)
            };
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // ! _SGPCET_START_REACHABLE_GRAPH_H_
#ifndef _SGPCET_SON_TREE_H_
#define _SGPCET_SON_TREE_H_

#ifndef _SGPCET_TREE_H_
#include "tree.h"
#endif // !_SGPCET_TREE_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template <typename NodeType, typename EdgeType>
            class SonTree;

            template <typename NodeType, typename EdgeType>
            class SonTreeGen : public BasicPrueferGen<SonTree, NodeType, EdgeType> {
            protected:
                using Context = SonTree<NodeType, EdgeType>;
            public:
                SonTreeGen(Context& tree) : BasicPrueferGen<SonTree, NodeType, EdgeType>(tree) {}
            protected:
                virtual void __generate_pruefer() override {
                    std::vector<int> times;
                    _CONTEXT_GET(sons)
                    _CONTEXT_GET_REF(root)
                    for (int i = 0; i < sons.size(); i++) {
                        if (i == root) times.emplace_back(sons[i] - 1);
                        else times.emplace_back(sons[i]); 
                    }
                    std::vector<int> pruefer = rand_array::shuffle_index(times);
                    this->__pruefer_decode(pruefer);
                }  

                virtual void __judge_self_limit() override {
                    int sum = 0;
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(sons)
                    for (auto& s : sons) sum += s; 
                    if (sum != node_count - 1) {
                        _msg::__fail_msg(_msg::_defl,
                            tools::string_format("the sum of sons should be %d, but found %d.", node_count - 1, sum)); 
                    }
                }

                virtual void __self_init() override {
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET_REF(sons)
                    _CONTEXT_GET_REF(root)
                    sons.resize(node_count, -1);
                    if (node_count == 1) {
                        if (sons[0] < 0) sons[0] = 0;
                        if (sons[0]!= 0)
                            _msg::__fail_msg(_msg::_defl, tools::string_format("the sons of 1 node tree should be 0, but found %d.", sons[0])); 
                        return;
                    } 
                    int sum = 0;
                    int cnt = 0;
                    int p = -1;
                    for (int i = 0; i < sons.size(); i++) {
                        auto s = sons[i];
                        if (s < 0) {
                            if (i == root) p = cnt;
                            cnt++;
                        }
                        else if (i == root && s == 0) 
                            _msg::__fail_msg(_msg::_defl, "the sons of root node can't be 0.");
                        else sum += s;
                    }
                    if (sum > node_count - 1) {
                        _msg::__fail_msg(_msg::_defl,
                            tools::string_format("the sum of sons can't be greater than %d, but found.", node_count - 1, sum)); 
                    }
                    int res = node_count - 1 - sum;
                    if (p != -1 && res == 0) 
                        _msg::__fail_msg(_msg::_defl, "the sons of root node can't be 0.");
                    std::vector<int> rand_sons = rand_array::rand_sum(cnt, res, 0);
                    if (p != -1) {
                        while(rand_sons[p] == 0) {
                            int v = rand_numeric::rand_int(cnt);
                            std::swap(rand_sons[p], rand_sons[v]);
                        }                        
                    }
                    int j = 0;
                    for (auto& s : sons) {
                        if (s < 0) {
                            s = rand_sons[j];
                            j++;                            
                        }
                    }
                }
            };

            template <typename NodeType, typename EdgeType>
            class SonTree : public _GenTree<NodeType, EdgeType> {
            protected:
                using _Self = SonTree<NodeType, EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                std::vector<int> _sons;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                SonTree(int node_count = 1, int begin_node = 1, int root = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node_count, begin_node, true, root, nodes_weight_function, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                SonTree(int node_count = 1, int begin_node = 1, int root = 1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node_count, begin_node, true, root, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                SonTree(int node_count = 1, int begin_node = 1, int root = 1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node_count, begin_node, true, root, nodes_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                SonTree(int node_count = 1, int begin_node = 1, int root = 1) :
                    _GenTree<NodeType, EdgeType>(node_count, begin_node, true, root)
                {
                    _TREE_GRAPH_DEFAULT
                }

                _OUTPUT_FUNCTION_SETTING(_Self)

                _SET_GET_VALUE(std::vector<int>, sons)

                void set_sons(int index, int son) {
                    if (index <= 0 && index > this->_node_count) {
                        _msg::__set_fail_msg(_msg::_defl, 
                            tools::string_format("the index should in range [1, %d], but found %d.", this->_node_count, index));
                        return;
                    }
                    if (_sons.size() < index) _sons.resize(this->_node_count, -1);
                    _sons[index - 1] = son; 
                }
            protected:

                _DEFAULT_GRAPH_GEN_FUNC(SonTree)
            };
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_SON_TREE_H_
#ifndef _SGPCET_DEGREE_TREE_H_
#define _SGPCET_DEGREE_TREE_H_

#ifndef _SGPCET_TREE_H_
#include "tree.h"
#endif // !_SGPCET_TREE_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template <typename NodeType, typename EdgeType>
            class DegreeTree;

            template <typename NodeType, typename EdgeType>
            class DegreeTreeGen : public BasicPrueferGen<DegreeTree, NodeType, EdgeType> {
            protected:
                using Context = DegreeTree<NodeType, EdgeType>; 
            public:
                DegreeTreeGen(Context& tree) : BasicPrueferGen<DegreeTree, NodeType, EdgeType>(tree) {}
            protected:
                virtual void __generate_pruefer() override {
                    std::vector<int> times;
                    _CONTEXT_GET(degrees)
                    for (auto& d : degrees) times.emplace_back(d - 1);
                    std::vector<int> pruefer = rand_array::shuffle_index(times);
                    this->__pruefer_decode(pruefer);
                }

                virtual void __judge_self_limit() override {
                    int sum = 0;
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(degrees)
                    for (auto&d : degrees) sum += d;
                    if (sum != 2 * node_count - 2) {
                        _msg::__fail_msg(_msg::_defl,
                            tools::string_format("the sum of degrees should be %d, but found %d.", 2 * node_count - 2, sum));
                    }
                }

                virtual void __self_init() override {
                   _CONTEXT_GET(node_count)
                   _CONTEXT_GET_REF(degrees)
                    degrees.resize(node_count, -1);
                    if (node_count == 1) {
                        if (degrees[0] < 0) degrees[0] = 0;
                        if (degrees[0] != 0) 
                            _msg::__fail_msg(_msg::_defl, tools::string_format("the degree of 1 node tree should be 0, but found %d.", degrees[0]));
                        return;
                    }
                    int sum = 0;
                    int cnt = 0;
                    for (auto& d : degrees) {
                        if (d < 0) cnt++;
                        else if (d == 0) _msg::__fail_msg(_msg::_defl, "the degree of node can't be 0.");
                        else sum += d;
                    }
                    if (sum > 2 * node_count - 2) {
                        _msg::__fail_msg(_msg::_defl, 
                            tools::string_format("the sum of degree can't be greater than %d, but found.", 2 * node_count - 2, sum));
                    }
                    std::vector<int> rand_degrees = rand_array::rand_sum(cnt, 2 * node_count - 2 - sum, 1);
                    int j = 0;
                    for (auto& d : degrees) {
                        if (d < 0) {
                            d = rand_degrees[j];
                            j++;
                        }
                    }
                }
            };

            template <typename NodeType, typename EdgeType>
            class DegreeTree : public _GenTree<NodeType, EdgeType> {
            protected:
                using _Self = DegreeTree<NodeType, EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                std::vector<int> _degrees;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                DegreeTree(int node_count = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node_count, begin_node, is_rooted, root,
                        nodes_weight_function, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                DegreeTree(int node_count = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    EdgeGenFunction edges_weight_function = nullptr):
                    _GenTree<NodeType, EdgeType>(node_count, begin_node, is_rooted, root, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                DegreeTree(int node_count = 1, int begin_node = 1, bool is_rooted = false, int root = 1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node_count, begin_node, is_rooted, root, nodes_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                DegreeTree(int node_count = 1, int begin_node = 1, bool is_rooted = false, int root = 1) :
                    _GenTree<NodeType, EdgeType>(node_count, begin_node, is_rooted, root)
                {
                    _TREE_GRAPH_DEFAULT
                }

                _OUTPUT_FUNCTION_SETTING(_Self)

                _SET_GET_VALUE(std::vector<int>, degrees)

                void set_degrees(int index, int degree) {
                    if (index <= 0 && index > this->_node_count) {
                        _msg::__set_fail_msg(_msg::_defl, 
                            tools::string_format("the index should in range [1, %d], but found %d.", this->_node_count, index));
                        return;
                    }
                    if (_degrees.size() < index) _degrees.resize(this->_node_count, -1);
                    _degrees[index - 1] = degree;
                }

            protected:


                _DEFAULT_GRAPH_GEN_FUNC(DegreeTree)
            };
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // _SGPCET_DEGREE_TREE_H_
#ifndef _SGPCET_FLOWER_CHAIN_H_
#define _SGPCET_FLOWER_CHAIN_H_

#ifndef _SGPCET_FLOWER_H_
#include "flower.h"
#endif //!_SGPCET_FLOWER_H_
#ifndef _SGPCET_CHAIN_H_
#include "chain.h"
#endif //!_SGPCET_CHAIN_H_
#ifndef _SGPCET_LINK_H_
#include "link.h"
#endif //!_SGPCET_LINK_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class FlowerChain;

            template <typename NodeType, typename EdgeType>
            class FlowerChainGen : public BasicTreeGen<FlowerChain, NodeType, EdgeType> {
            protected:
                TreeLink<NodeType, EdgeType> _link;
            public:
                using Context = FlowerChain<NodeType, EdgeType>;
                FlowerChainGen(Context& tree) : BasicTreeGen<FlowerChain, NodeType, EdgeType>(tree), _link() {}
            
            protected:
                template<template<typename, typename> class TG, typename T = NodeType, _HasT<T> = 0>
                void __reset_nodes_weight_function(TG<NodeType, EdgeType>& source) {
                    auto func = this->_context.nodes_weight_function();
                    source.set_nodes_weight_function(func);
                }
                
                template<template<typename, typename> class TG, typename T = NodeType, _NotHasT<T> = 0>
                void __reset_nodes_weight_function(TG<NodeType, EdgeType>&) {
                    return;
                }
                
                template<template<typename, typename> class TG, typename T = EdgeType, _HasT<T> = 0>
                void __reset_edges_weight_function(TG<NodeType, EdgeType>& source) {
                    auto func = this->_context.edges_weight_function();
                    source.set_edges_weight_function(func);
                }
                
                template<template<typename, typename> class TG, typename T = EdgeType, _NotHasT<T> = 0>
                void __reset_edges_weight_function(TG<NodeType, EdgeType>&) {
                    return;
                }

                virtual void __self_init() override {
                    _CONTEXT_GET_REF(flower_size);
                    _CONTEXT_GET_REF(chain_size);
                    _CONTEXT_GET(node_count);
                    if (flower_size == -1) flower_size = rand_numeric::rand_int(0, node_count);
                    chain_size = node_count - flower_size;
                }
                
                virtual void __judge_self_limit() override {
                    _CONTEXT_GET(flower_size);
                    _CONTEXT_GET(chain_size);
                    if (flower_size < 0) 
                        _msg::__fail_msg(_msg::_defl, tools::string_format("Flower size must greater than or equal to 0, but found %d.", flower_size));
                    if (chain_size < 0) 
                        _msg::__fail_msg(_msg::_defl, tools::string_format("Chain size must greater than or equal to 0, but found %d.", chain_size));
                }

                virtual void __generate_tree() override {
                    _CONTEXT_GET(flower_size);
                    _CONTEXT_GET(chain_size);
                    Flower<NodeType, EdgeType> flower(flower_size);
                    Chain<NodeType, EdgeType> chain(chain_size);
                    __reset_nodes_weight_function(flower);
                    __reset_edges_weight_function(flower);
                    __reset_nodes_weight_function(chain);
                    __reset_edges_weight_function(chain);
                    _link.set_target(this->_context);
                    if (flower_size != 0) {
                        _link.add_source(flower);
                    }
                    if (chain_size != 0) {
                        _link.add_source(chain);
                    }
                    _link.gen();
                    __dump_result();
                }

                void __dump_result() {
                    _CONTEXT_V_REF(node_indices) = _link.node_indices();
                    _CONTEXT_V_REF(edges) = _link.edges_ref();
                }
            };

            template <typename NodeType, typename EdgeType>
            class FlowerChain : public _GenTree<NodeType, EdgeType> {
            protected:
                using _Self = FlowerChain<NodeType, EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                int _flower_size;
                int _chain_size;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                FlowerChain(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1, int flower_size = -1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root,
                        nodes_weight_function, edges_weight_function),
                    _flower_size(flower_size)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                FlowerChain(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1, int flower_size = -1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root, edges_weight_function),
                    _flower_size(flower_size)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                FlowerChain(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1, int flower_size = -1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root, nodes_weight_function),
                    _flower_size(flower_size)
                {
                    _TREE_GRAPH_DEFAULT
                }

                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                FlowerChain(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1, int flower_size = -1) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root),
                    _flower_size(flower_size)
                {
                    _TREE_GRAPH_DEFAULT
                }

                _GET_VALUE(int, flower_size)
                _GET_VALUE(int, chain_size)

                void set_flower_size(int flower_size) {
                    _flower_size = flower_size;
                    _chain_size = this->_node_count - flower_size;
                }
                
                void set_chain_size(int chain_size) {
                    _chain_size = chain_size;
                    _flower_size = this->_node_count - _chain_size;
                }
                
                void set_flower_chain_size(int flower_size, int chain_size) {
                    _flower_size = flower_size;
                    _chain_size = chain_size;
                    if (flower_size + chain_size != this->_node_count) {
                        this->set_node_count(flower_size + chain_size);
                    }
                } 

                _OUTPUT_FUNCTION_SETTING(_Self)
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(FlowerChain)
            };
        } // namespace basic
    } // namespace rand_graph
} // namespace generator


#endif // !_SGPCET_FLOWER_CHAIN_H_
#ifndef _SGPCET_FOREST_H_
#define _SGPCET_FOREST_H_

#ifndef _SGPCET_LINK_H_
#include "link.h"
#endif // !_SGPCET_LINK_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class Forest;

            template <typename NodeType, typename EdgeType>
            class ForestGen : public BasicGraphGen<Forest, NodeType, EdgeType> {
            protected:
                Link<NodeType, EdgeType> _link;
            public:
                using Context = Forest<NodeType, EdgeType>;
                ForestGen(Context& tree) : BasicGraphGen<Forest, NodeType, EdgeType>(tree), _link() {}
            protected:

                template<template<typename, typename> class TG, typename T = NodeType, _HasT<T> = 0>
                void __reset_nodes_weight_function(TG<NodeType, EdgeType>& source) {
                    auto func = this->_context.nodes_weight_function();
                    source.set_nodes_weight_function(func);
                }
                
                template<template<typename, typename> class TG, typename T = NodeType, _NotHasT<T> = 0>
                void __reset_nodes_weight_function(TG<NodeType, EdgeType>&) {
                    return;
                }
                
                template<template<typename, typename> class TG, typename T = EdgeType, _HasT<T> = 0>
                void __reset_edges_weight_function(TG<NodeType, EdgeType>& source) {
                    auto func = this->_context.edges_weight_function();
                    source.set_edges_weight_function(func);
                }
                
                template<template<typename, typename> class TG, typename T = EdgeType, _NotHasT<T> = 0>
                void __reset_edges_weight_function(TG<NodeType, EdgeType>&) {
                    return;
                }

                virtual void __self_init() override {
                    this->_context.rand_edge_count();                
                }

                virtual void __generate_graph() override {
                    _link.set_target(this->_context);                        
                    Tree<NodeType, EdgeType> tree;
                    __reset_nodes_weight_function(tree);
                    __reset_edges_weight_function(tree);
                    for (int tree_size : _CONTEXT_V(trees_size)) {
                        tree.set_node_count(tree_size);
                        tree.default_node_indices();
                        tree.gen();
                        _link.add_source(tree);
                    }
                    _link.gen();
                    __dump_result();
                }

                void __dump_result() {
                    _CONTEXT_V_REF(node_indices) = _link.node_indices();
                    _CONTEXT_V_REF(edges) = _link.edges_ref();
                }
            };

            template <typename NodeType, typename EdgeType>
            class Forest : public _GenGraph<NodeType, EdgeType> {
            protected:
                using _Self = Forest<NodeType, EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                std::vector<int> _trees_size;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                Forest(
                    int node_count = 1, int edge_count = 0, int begin_node = 1, 
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, edge_count == node_count - 1, true,
                        nodes_weight_function, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT 
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                Forest(
                    int node_count = 1, int edge_count = 0, int begin_node = 1, 
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenGraph<NodeType, void>(node_count, edge_count, begin_node,
                        false, false, false, edge_count == node_count - 1, true,
                        nodes_weight_function)
                {
                    _TREE_GRAPH_DEFAULT 
                }

                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                Forest(
                    int node_count = 1, int edge_count = 0, int begin_node = 1, 
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<void, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, edge_count == node_count - 1, true,
                        edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT 
                }

                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                Forest(int node_count = 1, int edge_count = 0, int begin_node = 1) :
                    _GenGraph<void, void>(node_count, edge_count, begin_node,
                        false, false, false, edge_count == node_count - 1, true)
                {
                    _TREE_GRAPH_DEFAULT 
                }

                _GET_VALUE(std::vector<int>, trees_size)
                void add_tree_size(int tree_size) {
                    if (tree_size > 0) _trees_size.emplace_back(tree_size);
                    else _msg::__warn_msg(_msg::_defl, tools::string_format("Tree size must greater than 0, but found %d.", tree_size));
                }
                void set_trees_size(std::vector<int> trees_size) {
                    _trees_size.clear();
                    for (int tree_size : trees_size) add_tree_size(tree_size);
                    __reset_node_edge_count();
                }

                _DISABLE_DIRECTION
                _DISABLE_MULTIPLY_EDGE
                _DISABLE_SELF_LOOP
                _DISABLE_CONNECT
                _OUTPUT_FUNCTION_SETTING(_Self)

                virtual long long min_edge_count() override {
                    return 0;
                }

                virtual long long max_edge_count() override {
                    return this->_node_count - 1;
                }

                virtual void rand_edge_count(long long from = _setting::auto_edge_limit, long long to = _setting::auto_edge_limit) override {
                    if (!_trees_size.empty()) __reset_node_edge_count();
                    else {
                        _GenGraph<NodeType, EdgeType>::rand_edge_count(from, to);
                        int tree_count = this->_node_count - this->_edge_count;
                        set_trees_size(rand_array::rand_sum(tree_count, this->_node_count, 1));
                    }
                    __reset_connect();
                }
            
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(Forest)

                void __reset_connect() {
                    this->_connect = this->_node_count - 1 == this->_edge_count;
                }

                void __reset_node_edge_count() {
                    int n = this->_node_count;
                    int m = this->_edge_count;
                    int count = 0;
                    for (int tree_size : _trees_size) {
                        count += tree_size;
                    }
                    if (count != n) {
                        _msg::__warn_msg(_msg::_defl, tools::string_format(
                            "node_count will be changed because the sum of Trees' size %d is not equal to node count %d.",
                            count, n));
                        this->set_node_count(count);
                    }
                    int new_m = count - (int)_trees_size.size();
                    if (new_m != m) {
                        _msg::__warn_msg(_msg::_defl, tools::string_format(
                            "edge_count will be changed because the sum of Trees' edges %d is not equal to edge count %d.",
                            new_m, m));
                        this->set_edge_count(new_m);                       
                    }
                }
            };

        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_FOREST_H_
#ifndef _SGPCET_CACTUS_H_
#define _SGPCET_CACTUS_H_

#ifndef _SGPCET_CYCLE_GRAPH_H_
#include "cycle_graph.h"
#endif // !_SGPCET_CYCLE_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class Cactus;

            template <typename NodeType, typename EdgeType>
            class CactusGen : public BasicGraphGen<Cactus, NodeType, EdgeType> {
            protected:
                using Context = Cactus<NodeType, EdgeType>;
                std::vector<int> _rank;
            public:
                CactusGen(Context& graph) : BasicGraphGen<Cactus, NodeType, EdgeType>(graph) {}
            protected:
                virtual void __self_init() override{
                    _rank = rnd.perm(_CONTEXT_V(node_count));
                }

                template<typename T = EdgeType, _HasT<T> = 0>
                CycleGraph<void, EdgeType> __get_cycle_graph(int size) {
                    CycleGraph<void, EdgeType> cycle(size, 0, _CONTEXT_V(edges_weight_function));
                    return cycle;
                }

                template<typename T = EdgeType, _NotHasT<T> = 0>
                CycleGraph<void, void> __get_cycle_graph(int size) {
                    CycleGraph<void, void> cycle(size, 0);
                    return cycle;
                }

                virtual void __generate_graph() override {
                    std::vector<std::vector<int>> cycles;
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(edge_count)
                    int m = edge_count - (node_count - 1);
                    for (int i = 2; i <= 2 * m; i += 2) {
                        std::vector<int> pre;
                        if (i == 2) {
                            pre.emplace_back(0);
                        }
                        pre.emplace_back(i);
                        pre.emplace_back(i - 1);
                        cycles.emplace_back(pre);
                    }
                    int len = cycles.size();
                    int add = len == 0 ? 0 : rnd.next(0, node_count - (2 * m + 1));
                    for (int i = 2 * m + 1; i <= 2 * m + add; i++) {
                        int w = rnd.next(len);
                        cycles[w].emplace_back(i);
                    }
                    for (int i = 2 * m + add + (len != 0); i < node_count; i++) {
                        cycles.emplace_back(1, i);
                    }
                    shuffle(cycles.begin() + 1, cycles.end());
                    for(size_t i = 0; i < cycles.size(); i++) {
                        std::vector<int> current = cycles[i];
                        if (i != 0) {
                            int w = rnd.next(i);
                            current.push_back(rnd.any(cycles[w]));
                        }
                        if(current.size() == 1) {
                            continue;
                        }
                        else if(current.size() == 2) {
                            this->__add_edge(_rank[current[0]], _rank[current[1]]);
                        }
                        else {
                            CycleGraph<void, EdgeType> cycle = __get_cycle_graph(current.size());
                            cycle.gen();
                            std::vector<_Edge<EdgeType>> edge = cycle.edges();
                            for(_Edge<EdgeType>& e : edge) {
                                int& u = e.u_ref();
                                int& v = e.v_ref();
                                u = _rank[current[u]];
                                v = _rank[current[v]];
                                this->__add_edge(e);
                            }
                        }
                    }
                }
            };

            template <typename NodeType, typename EdgeType>
            class Cactus : public _GenGraph<NodeType, EdgeType> {
            protected:
                using _Self =  Cactus<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                Cactus(int node_count = 1, int edge_count = 0, int begin_node = 1, 
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                         false, false, false, true, true,
                        nodes_weight_function, edges_weight_function) 
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                Cactus(int node_count = 1, int edge_count = 0, int begin_node = 1, 
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                         false, false, false, true, true,
                         edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                Cactus(int node_count = 1, int edge_count = 0, int begin_node = 1, 
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, true, true,
                        nodes_weight_function) 
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                Cactus(int node_count = 1, int edge_count = 0, int begin_node = 1) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, true, true)
                {
                    _TREE_GRAPH_DEFAULT       
                }  

                _DISABLE_DIRECTION
                _DISABLE_CONNECT
                _DISABLE_SELF_LOOP
                _DISABLE_MULTIPLY_EDGE
                _OUTPUT_FUNCTION_SETTING(_Self)

                virtual long long max_edge_count() override {
                    long long n = this->_node_count;
                    return n - 1 + (n - 1) / 2;
                }
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(Cactus)
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_CACTUS_H_
#ifndef _SGPCET_PSEUDO_TREE_H_
#define _SGPCET_PSEUDO_TREE_H_

#ifndef _SGPCET_CYCLE_GRAPH_H_
#include "cycle_graph.h"
#endif // !_SGPCET_CYCLE_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class PseudoTree;

            template <template <typename, typename> class Type, typename NodeType, typename EdgeType>
            class PseudoTreeBasicGen : public BasicGraphGen<Type, NodeType, EdgeType> {
            protected:
                using Context = Type<NodeType, EdgeType>;
                std::vector<int> _rank;
            public:
                PseudoTreeBasicGen(Context& graph) : BasicGraphGen<Type, NodeType, EdgeType>(graph) {}
            
            protected:
                virtual void __self_init() override {
                    this->_context.rand_edge_count();
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET_REF(cycle)
                    _rank = rnd.perm(node_count, 0);
                    if (cycle == -1) {
                        cycle = rnd.next(3, node_count);
                    }
                }

                virtual void __judge_self_limit() override {
                    _CONTEXT_GET(cycle)
                    _CONTEXT_GET(node_count)
                    if (cycle < 3 || cycle > node_count) {
                        _msg::__fail_msg(_msg::_defl,
                        tools::string_format("cycle size must in range [3, %d], but found %d.",
                        node_count, cycle));
                    }
                }

                virtual void __judge_lower_limit() override {
                    _CONTEXT_GET(node_count)
                    if (node_count < 3) {
                        _msg::__fail_msg(_msg::_defl,
                        tools::string_format("node_count must greater than or equal to 3, but found %d.",
                        node_count));
                    }
                }

                template<typename T = EdgeType, _HasT<T> = 0>
                CycleGraph<void, EdgeType> __get_cycle_graph() {
                    CycleGraph<void, EdgeType> cycle(_CONTEXT_V(cycle), 0, _CONTEXT_V(edges_weight_function));
                    return cycle;
                }

                template<typename T = EdgeType, _NotHasT<T> = 0>
                CycleGraph<void, void> __get_cycle_graph() {
                    CycleGraph<void, void> cycle(_CONTEXT_V(cycle), 0);
                    return cycle;
                }

                void __generate_cycle() {
                    CycleGraph<void, EdgeType> cycle = __get_cycle_graph();
                    cycle.set_swap_node(_CONTEXT_V(swap_node));
                    cycle.gen(); 
                    std::vector <_Edge<EdgeType>> edge = cycle.edges();
                    for (_Edge<EdgeType>& e: edge) {
                        int& u = e.u_ref();
                        int& v = e.v_ref();
                        u = _rank[u];
                        v = _rank[v];
                        this->__add_edge(e);
                    }
                }

                virtual void __generate_other_edges() {
                    for (int i = _CONTEXT_V(cycle); i < _CONTEXT_V(node_count); i++) {
                        int f = rnd.next(i);
                        this->__add_edge(_rank[i], _rank[f]);
                    }
                }

                virtual void __generate_graph() override {
                    __generate_cycle();
                    __generate_other_edges();
                }       
            };

            template <typename NodeType, typename EdgeType>
            class PseudoTreeGen : public PseudoTreeBasicGen<PseudoTree, NodeType, EdgeType> {
            protected:
                using Context = PseudoTree<NodeType, EdgeType>;
            public:
                PseudoTreeGen(Context& graph) : PseudoTreeBasicGen<PseudoTree, NodeType, EdgeType>(graph) {}
            };

            template <typename NodeType, typename EdgeType>
            class PseudoTree : public _GenGraph<NodeType, EdgeType> {
            protected:
                using _Self =  PseudoTree<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                int _cycle;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                PseudoTree(int node_count = 3, int begin_node = 1, int cycle = -1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, node_count, begin_node,
                        false, false, false, true, true,
                        nodes_weight_function, edges_weight_function),
                    _cycle(cycle)
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                PseudoTree(int node_count = 3, int begin_node = 1, int cycle = -1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, node_count, begin_node,
                        false, false, false, true, true, 
                        edges_weight_function),
                    _cycle(cycle)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                PseudoTree(int node_count = 3, int begin_node = 1, int cycle = -1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, node_count, begin_node,
                        false, false, false, true, true,
                        nodes_weight_function),
                    _cycle(cycle)
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                PseudoTree(int node_count = 3, int begin_node = 1, int cycle = -1) :
                    _GenGraph<NodeType, EdgeType>(node_count, node_count, begin_node,
                        false, false, false, false, true),
                    _cycle(cycle)
                {
                    _TREE_GRAPH_DEFAULT       
                } 

                _SET_GET_VALUE(int, cycle)

                _DISABLE_EDGE_COUNT
                _DISABLE_CONNECT
                _DISABLE_DIRECTION
                _DISABLE_SELF_LOOP
                _DISABLE_MULTIPLY_EDGE
                _OUTPUT_FUNCTION_SETTING(_Self)

                virtual long long min_edge_count() override {
                    return this->_node_count;
                }

                virtual long long max_edge_count() override {
                    return this->_node_count;
                }

            protected:
                _DEFAULT_GRAPH_GEN_FUNC(PseudoTree)
            }; 

            template <typename NodeType, typename EdgeType>
            class PseudoInTree;

            template <typename NodeType, typename EdgeType>
            class PseudoInTreeGen : public PseudoTreeBasicGen<PseudoInTree, NodeType, EdgeType> {
            protected:
                using Context = PseudoInTree<NodeType, EdgeType>;
            public:
                PseudoInTreeGen(Context& graph) : PseudoTreeBasicGen<PseudoInTree, NodeType, EdgeType>(graph) {}
            };

            template <typename NodeType, typename EdgeType>
            class PseudoInTree : public PseudoTree<NodeType, EdgeType> {
            protected:
                using _Self =  PseudoInTree<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                PseudoInTree(int node_count = 3, int begin_node = 1, int cycle = -1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    PseudoTree<NodeType, EdgeType>(node_count, begin_node, cycle,
                        nodes_weight_function, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                    this->_direction = true;
                    this->_swap_node = false;       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                PseudoInTree(int node_count = 3, int begin_node = 1, int cycle = -1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    PseudoTree<NodeType, EdgeType>(node_count, begin_node, cycle,
                        edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                    this->_direction = true;
                    this->_swap_node = false;    
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                PseudoInTree(int node_count = 3, int begin_node = 1, int cycle = -1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    PseudoTree<NodeType, EdgeType>(node_count, begin_node, cycle,
                        nodes_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                    this->_direction = true;
                    this->_swap_node = false;         
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                PseudoInTree(int node_count = 3, int begin_node = 1, int cycle = -1) :
                    PseudoTree<NodeType, EdgeType>(node_count, begin_node, cycle)
                {
                    _TREE_GRAPH_DEFAULT
                    this->_direction = true;
                    this->_swap_node = false;        
                }   
                _OUTPUT_FUNCTION_SETTING(_Self)
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(PseudoInTree) 
            };

            template <typename NodeType, typename EdgeType>
            class PseudoOutTree;

            template <typename NodeType, typename EdgeType>
            class PseudoOutTreeGen : public PseudoTreeBasicGen<PseudoOutTree, NodeType, EdgeType> {
            protected:
                using Context = PseudoOutTree<NodeType, EdgeType>;
            public:
                PseudoOutTreeGen(Context& graph) : PseudoTreeBasicGen<PseudoOutTree, NodeType, EdgeType>(graph) {}
            protected:

                virtual void __generate_other_edges() override {
                    for (int i = _CONTEXT_V(cycle); i < _CONTEXT_V(node_count); i++) {
                        int f = rnd.next(i);
                        this->__add_edge(this->_rank[f], this->_rank[i]);
                    }
                }
            };

            template <typename NodeType, typename EdgeType>
            class PseudoOutTree : public PseudoTree<NodeType, EdgeType> {
            protected:
                using _Self =  PseudoOutTree<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                PseudoOutTree(int node_count = 3, int begin_node = 1, int cycle = -1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    PseudoTree<NodeType, EdgeType>(node_count, begin_node, cycle,
                        nodes_weight_function, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                    this->_direction = true;
                    this->_swap_node = false;       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                PseudoOutTree(int node_count = 3, int begin_node = 1, int cycle = -1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    PseudoTree<NodeType, EdgeType>(node_count, begin_node, cycle,
                        edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                    this->_direction = true;
                    this->_swap_node = false;    
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                PseudoOutTree(int node_count = 3, int begin_node = 1, int cycle = -1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    PseudoTree<NodeType, EdgeType>(node_count, begin_node, cycle,
                        nodes_weight_function)
                {
                    _TREE_GRAPH_DEFAULT
                    this->_direction = true;
                    this->_swap_node = false;         
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                PseudoOutTree(int node_count = 3, int begin_node = 1, int cycle = -1) :
                    PseudoTree<NodeType, EdgeType>(node_count, begin_node, cycle)
                {
                    _TREE_GRAPH_DEFAULT
                    this->_direction = true;
                    this->_swap_node = false;        
                }   
                _OUTPUT_FUNCTION_SETTING(_Self)
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(PseudoOutTree) 
            };
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_PSEUDO_TREE_H_
#ifndef _SGPCET_GRID_GRAPH_H_
#define _SGPCET_GRID_GRAPH_H_

#ifndef _SGPCET_GRAPH_H_
#include "graph.h"
#endif // !_SGPCET_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class GridGraph;

            template <typename NodeType, typename EdgeType>
            class GridGraphGen : public BasicGraphGen<GridGraph, NodeType, EdgeType> {
            protected:
                using Context = GridGraph<NodeType, EdgeType>;
                std::vector<int> _rank;
            public:
                GridGraphGen(Context& graph) : BasicGraphGen<GridGraph, NodeType, EdgeType>(graph) {}
            
            protected:

                virtual void __judge_self_limit() override {
                    _CONTEXT_GET(row)
                    _CONTEXT_GET(column)
                    if (row <= 0) {
                        _msg::__fail_msg(_msg::_defl, 
                            tools::string_format("row must greater than 0, but found %d.", row));
                    }
                    if (column <= 0) {
                        _msg::__fail_msg(_msg::_defl, 
                            tools::string_format("column must greater than 0, but found %d.", column));
                    }
                }

                virtual void __self_init() override {
                    _CONTEXT_GET(row)
                    if (row <= 0) this->_context.rand_row();
                    _CONTEXT_GET(node_count)
                    _rank = rnd.perm(node_count, 0);
                }

                virtual void __generate_connect() override {
                    _CONTEXT_GET(row)
                    _CONTEXT_GET(column)
                    _CONTEXT_GET(node_count)
                    for (int i = 0; i < row; i++) {
                        for (int j = 1; j < column; j++) {
                            int x = i * column + j, y = x - 1;
                            if (x >= node_count) continue;
                            this->__add_edge(_rank[x], _rank[y]);
                        }
                        int x = i * column, y = (i + 1) * column;
                        if (x < node_count && y < node_count) {
                            this->__add_edge(_rank[x], _rank[y]);
                        }
                    }
                }

                virtual _Edge<EdgeType> __rand_edge() override {
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(row)
                    _CONTEXT_GET(column)
                    int d[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
                    int pos, k, px, py, nxt;
                    do {
                        pos = rnd.next(node_count);
                        k = rnd.next(4);
                        px = pos / column + d[k][0];
                        py = pos % column + d[k][1];
                        nxt = px * column + py;
                    } while (px < 0 || px >= row || py < 0 || py >= column || nxt >= node_count ||
                             this->__judge_multiply_edge(_rank[pos], _rank[nxt]));
                    return this->__convert_edge(_rank[pos], _rank[nxt]);
                }
            };

            template <typename NodeType, typename EdgeType>
            class GridGraph : public _GenGraph<NodeType, EdgeType> {
            protected:
                using _Self =  GridGraph<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                int _row, _column;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                GridGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int row = -1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, true,
                        nodes_weight_function, edges_weight_function),
                    _row(row)
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                GridGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int row = -1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, true, 
                        edges_weight_function),
                    _row(row)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                GridGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int row = -1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, true,
                        nodes_weight_function),
                    _row(row)
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                GridGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int row = -1) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, true),
                    _row(row)
                {
                    _TREE_GRAPH_DEFAULT       
                } 
                
                void set_row(int row) {
                    _row = row; 
                    if (_row != 0) {
                        _column = (this->_node_count + _row - 1) / _row;
                    } 
                }

                void set_column(int column) {
                    _column = column;
                    if (_column != 0) {
                        _row = (this->_node_count + _column - 1) / _column;
                    }
                }

                void set_row_column(int row, int column, int ignore = 0) {
                    long long node = (long long)row * (long long)column - (long long)ignore;
                    if (ignore >= column) {
                        _msg::__set_fail_msg(_msg::_defl, 
                            tools::string_format("the ignored nodes should in range [0, %d), but found %d.",
                            column, ignore));
                        return;
                    }
                    if (node > _setting::node_limit) {
                        _msg::__set_fail_msg(_msg::_defl,
                            tools::string_format("node_count %d * %d - %d = %lld is greater than the node_limit(%d).",
                            row, column, ignore, node, _setting::node_limit));
                        return;
                    }
                    _row = row;
                    _column = column;
                    if (this->_node_count != node) this->set_node_count(node);                  
                }
                _GET_VALUE(int, row)
                _GET_VALUE(int, column)

                _DISABLE_SELF_LOOP
                _OUTPUT_FUNCTION_SETTING(_Self)

                virtual long long max_edge_count() override {
                    if (this->_node_count == 0) return 0;
                    if (this->_multiply_edge) return this->_node_count == 1 ? 0 : _setting::edge_count_inf;
                    if (_row <= 0 || _column <= 0) {
                        long long max_edge = 0;
                        for (int i = 1; i < this->_node_count; i++) {
                            max_edge = std::max(max_edge, __count_edge_count(i, __count_column(i)));
                        }
                        return max_edge;
                    } else {
                        return __count_edge_count(_row, _column);
                    }
                }

                virtual void rand_edge_count(long long from = _setting::auto_edge_limit, long long to = _setting::auto_edge_limit) override {
                    _GenGraph<NodeType, EdgeType>::rand_edge_count(from, to); 
                    if (_row <= 0) rand_row();
                }

                void rand_row() {
                    int n = this->_node_count;
                    if (this->_multiply_edge) _row = rand_numeric::rand_int(1, n);
                    else {
                        std::vector<long long> counts;
                        long long max_edge = __max_edge_count(counts);
                        max_edge = std::min(max_edge, (long long)_setting::edge_limit);
                        if (this->_edge_count > max_edge) {
                            _msg::__warn_msg(_msg::_defl,
                                tools::string_format("edge_count is large than the maximum possible, use upper edges limit %lld.",
                                max_edge));
                            this->_edge_count = max_edge;
                        }
                        std::vector<int> possible;
                        for (int i = 1; i < n; i++) {
                            if (counts[i] >= this->_edge_count) possible.push_back(i);
                        }
                        _row = rnd.any(possible);
                    }
                    _column = __count_column(_row);
                }

            protected:
                _DEFAULT_GRAPH_GEN_FUNC(GridGraph)

                long long __max_edge_count(std::vector<long long>& counts) {
                    long long max_edge = 0;
                    counts.resize(this->_node_count);
                    for (int i = 1; i < this->_node_count; i++) {
                        counts[i] = __count_edge_count(i, __count_column(i));
                        max_edge = std::max(max_edge, counts[i]);
                    }
                    return max_edge;
                }

                int __count_column(int row) {
                    if (row == 0) _msg::__error_msg(_msg::_defl, "row can't be 0.");
                    return (this->_node_count + row - 1) / row;
                }

                long long __count_edge_count(int row, int column) {
                    long long xl = row;
                    long long yl = column;
                    long long sum = xl * (yl - 1) + yl * (xl - 1) - 2 * (xl * yl - this->_node_count);
                    if (this->_direction) sum *= 2;
                    return sum;
                }
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_GRID_GRAPH_H_
#ifndef _SGPCET_WHEEL_GRAPH_H_
#define _SGPCET_WHEEL_GRAPH_H_

#ifndef _SGPCET_GRAPH_H_
#include "graph.h"
#endif // !_SGPCET_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class WheelGraph;

            template <typename NodeType, typename EdgeType>
            class WheelGraphGen : public BasicGraphGen<WheelGraph, NodeType, EdgeType> {
            protected:
                using Context = WheelGraph<NodeType, EdgeType>;
            public:
                WheelGraphGen(Context& graph) : BasicGraphGen<WheelGraph, NodeType, EdgeType>(graph) {}
            
            protected:
                virtual void __self_init() override {
                    this->_context.rand_edge_count();
                }

                virtual void __judge_self_limit() override {
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(edge_count)
                    if (2 * node_count - 2 != edge_count) {
                        _msg::__fail_msg(_msg::_defl, 
                            "edge_count must equal to 2 * node_count - 2, ",
                            tools::string_format("but found node_count = %d, edge_count = %d.", node_count, edge_count));
                    }
                }    

                virtual void __judge_lower_limit() override {
                    _CONTEXT_GET(node_count)
                    if (node_count < 4) {
                        _msg::__fail_msg(_msg::_defl, 
                            "node_count must greater than or equal to 4, ",
                            tools::string_format("but found %d.", node_count));
                    }
                }

                virtual void __generate_graph() override {
                    _CONTEXT_GET(node_count)
                    std::vector<int> p = rnd.perm(node_count);
                    for (int i = 0; i < node_count - 1; i++) {
                        this->__add_edge(p[i], p[(i + 1) % (node_count - 1)]);
                        this->__add_edge(p[i], p[node_count - 1]);
                    }
                }
            };

            template <typename NodeType, typename EdgeType>
            class WheelGraph : public _GenGraph<NodeType, EdgeType> {
            protected:
                using _Self =  WheelGraph<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                WheelGraph(int node_count = 4, int begin_node = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, 2 * node_count - 2, begin_node,
                        true, false, false, false, false,
                        nodes_weight_function, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                WheelGraph(int node_count = 4, int begin_node = 1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, 2 * node_count - 2, begin_node,
                        true, false, false, false, false, 
                        edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                WheelGraph(int node_count = 4, int begin_node = 1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, 2 * node_count - 2, begin_node,
                        true, false, false, false, false,
                        nodes_weight_function)
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                WheelGraph(int node_count = 4, int begin_node = 1) :
                    _GenGraph<NodeType, EdgeType>(node_count, 2 * node_count - 2, begin_node,
                        true, false, false, false, false)
                {
                    _TREE_GRAPH_DEFAULT       
                } 
                
                _DISABLE_CONNECT
                _DISABLE_MULTIPLY_EDGE
                _DISABLE_SELF_LOOP
                _DISABLE_EDGE_COUNT
                _OUTPUT_FUNCTION_SETTING(_Self)

                virtual long long min_edge_count() override {
                    return 2 * this->_node_count - 2;
                }

                virtual long long max_edge_count() override {
                    return 2 * this->_node_count - 2;
                }

            protected:
                _DEFAULT_GRAPH_GEN_FUNC(WheelGraph)
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_WHEEL_GRAPH_H_
#ifndef _SGPCET_DAG_H_
#define _SGPCET_DAG_H_

#ifndef _SGPCET_GRAPH_H_
#include "graph.h"
#endif // !_SGPCET_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class DAG;

            template <typename NodeType, typename EdgeType>
            class DAGGen : public BasicGraphGen<DAG, NodeType, EdgeType> {
            protected:
                using Context = DAG<NodeType, EdgeType>;
                std::vector<int> _rank;
            public:
                DAGGen(Context& graph) : BasicGraphGen<DAG, NodeType, EdgeType>(graph) {}
            
            protected:

                virtual void __self_init() override{
                    _rank = rnd.perm(_CONTEXT_V(node_count), 0);
                }

                virtual void __generate_connect() override{
                    for (int i = 1; i < _CONTEXT_V(node_count); i++) {
                        int f = rnd.next(i);
                        this->__add_edge(_rank[f], _rank[i]);
                    }
                }

                virtual _Edge<EdgeType> __rand_edge() override {
                    int u, v;
                    _CONTEXT_GET(node_count)
                    do {
                        u = rnd.next(node_count);
                        v = rnd.next(node_count);
                        if (u > v) std::swap(u, v);
                        u = _rank[u];
                        v = _rank[v];
                    } while (this->__judge_self_loop(u, v) || this->__judge_multiply_edge(u, v));
                    return this->__convert_edge(u, v);
                }
            };

            template <typename NodeType, typename EdgeType>
            class DAG : public _GenGraph<NodeType, EdgeType> {
            protected:
                using _Self =  DAG<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                DAG(int node_count = 1, int edge_count = 0, int begin_node = 1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        true, false, false, false, false,
                        nodes_weight_function, edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                DAG(int node_count = 1, int edge_count = 0, int begin_node = 1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        true, false, false, false, false, 
                        edges_weight_function)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                DAG(int node_count = 1, int edge_count = 0, int begin_node = 1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        true, false, false, false, false,
                        nodes_weight_function)
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                DAG(int node_count = 1, int edge_count = 0, int begin_node = 1) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        true, false, false, false, false)
                {
                    _TREE_GRAPH_DEFAULT       
                } 
                
                _DISABLE_SELF_LOOP
                _DISABLE_DIRECTION
                _OUTPUT_FUNCTION_SETTING(_Self)

                virtual long long max_edge_count() override {
                    if (this->_multiply_edge) {
                        return this->_node_count == 1 ? 0 : _setting::edge_count_inf;
                    } else {
                        long long n = this->_node_count;
                        return n * (n - 1) / 2;
                    }                   
                }
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(DAG)
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_DAG_H_
#ifndef _SGPCET_BIPARTITE_GRAPH_H_
#define _SGPCET_BIPARTITE_GRAPH_H_

#ifndef _SGPCET_GRAPH_H_
#include "graph.h"
#endif // !_SGPCET_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class BipartiteGraph;

            template <typename NodeType, typename EdgeType>
            class BipartiteGraphGen : public BasicGraphGen<BipartiteGraph, NodeType, EdgeType> {
            protected:
                using Context = BipartiteGraph<NodeType, EdgeType>;
                std::vector<int> _degree[2];
                std::vector<int> _part[2];
                int _d[2];
            public:
                BipartiteGraphGen(Context& graph) : BasicGraphGen<BipartiteGraph, NodeType, EdgeType>(graph) {}
            
            protected:

                void __remark_node_indices_by_part(std::vector<int>& part) {
                    int index = _CONTEXT_V(begin_node);
                    _CONTEXT_GET_REF(node_indices)
                    for(int x : part) {                   
                        node_indices[x] = index;
                        index++;
                    }
                }

                void __remark_node_indices() {
                    if (_CONTEXT_V(different_part)) {
                        if (_part[0].empty() && _part[1].empty()) {
                            return;
                        }
                        _CONTEXT_V_REF(node_indices).resize(_CONTEXT_V(node_count));
                        __remark_node_indices_by_part(_part[0]);
                        __remark_node_indices_by_part(_part[1]);
                    }
                    else {
                        this->_context.default_node_indices();
                    }
                }

                virtual void __self_init() override {
                    this->_context.rand_left();
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET_REF(left)
                    _CONTEXT_GET_REF(right)
                    right = node_count - left;
                    
                    for (int i = 0; i < 2; i++) {
                        _part[i].clear();
                        _degree[i].clear();
                    }
                    std::vector<int> p = rnd.perm(node_count);
                    for (int i = 0; i < left; i++) _part[0].push_back(p[i]);
                    for (int i = left; i < node_count; i++) _part[1].push_back(p[i]);
                    if (_CONTEXT_V(different_part)) __remark_node_indices();
                    if (_CONTEXT_V(connect)) {
                        _degree[0] = rand_array::rand_sum(left, node_count - 1, 1);
                        _degree[1] = rand_array::rand_sum(right, node_count - 1, 1);
                        _d[0] = node_count - 1;
                        _d[1] = node_count - 1;
                    }
                }

                virtual void __judge_self_limit() override {
                    _CONTEXT_GET(left)
                    _CONTEXT_GET(right)
                    if (left < 0) {
                        _msg::__fail_msg(_msg::_defl,
                            "left part size must greater than or equal to 0,",
                            tools::string_format("but found %d", left));
                    }
                    if (right < 0) {
                        _msg::__fail_msg(_msg::_defl,
                            "right part size must greater than or equal to 0,",
                            tools::string_format("but found %d", right));
                    }
                }

                virtual _Edge<EdgeType> __rand_edge() override{
                    int u, v;
                    do {
                        u = rnd.any(_part[0]);
                        v = rnd.any(_part[1]);
                    } while (this->__judge_multiply_edge(u, v));
                    return this->__convert_edge(u, v);
                }

                void __add_part_edge(int f, int i, int j) {
                    int u = _part[f][i];
                    int v = _part[f ^ 1][j];
                    if (f == 1) {
                        std::swap(u, v);
                    }
                    this->__add_edge(u, v);
                    _d[0]--;
                    _d[1]--;
                    _degree[f][i]--;
                    _degree[f ^ 1][j]--;
                } 

                virtual void __generate_connect() override {
                    int f = 0;
                    _CONTEXT_GET(left)
                    _CONTEXT_GET(right)
                    while (_d[0] + _d[1] > 0) {
                        for (int i = 0; i < (f == 0 ? left : right); i++) {
                            if (_degree[f][i] == 1) {
                                if (_d[f] == 1) {
                                    for (int j = 0; j < (f == 0 ? right : left); j++) {
                                        if (_degree[f ^ 1][j] == 1) {
                                            __add_part_edge(f, i, j);
                                        }
                                    }
                                } else {
                                    int j;
                                    do {
                                        j = rnd.next(f == 0 ? right : left);
                                    } while (_degree[f ^ 1][j] < 2);
                                    __add_part_edge(f, i, j);
                                }
                            }
                        }
                        f ^= 1;
                    }
                }  
            };

            template <typename NodeType, typename EdgeType>
            class BipartiteGraph : public _GenGraph<NodeType, EdgeType> {
            public:
                enum NodeOutputFormat {
                    Node,
                    LeftRight,
                    NodeLeft,
                    NodeRight
                };
            protected:
                int _left, _right;
                bool _different_part;
                NodeOutputFormat _node_output_format;
                using _Self =  BipartiteGraph<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                BipartiteGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int left = -1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, false,
                        nodes_weight_function, edges_weight_function),
                    _left(left), _different_part(false), _node_output_format(Node)
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                BipartiteGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int left = -1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, false, 
                        edges_weight_function),
                    _left(left), _different_part(false), _node_output_format(Node)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                BipartiteGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int left = -1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, false,
                        nodes_weight_function),
                    _left(left), _different_part(false), _node_output_format(Node)
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                BipartiteGraph(int node_count = 1, int edge_count = 0, int begin_node = 1, int left = -1) :
                    _GenGraph<NodeType, EdgeType>(node_count, edge_count, begin_node,
                        false, false, false, false, false),
                    _left(left), _different_part(false), _node_output_format(Node)
                {
                    _TREE_GRAPH_DEFAULT       
                }  

                _SET_GET_VALUE(bool, different_part)

                void set_left(int left) {
                    _left = left;
                    _right = this->_node_count - _left;
                }

                void set_right(int right) {
                    _right = right;
                    _left = this->_node_count - _right;
                }

                void set_left_right(int left, int right) {
                    if (left + right < 0) {
                        _msg::__set_fail_msg(_msg::_defl,
                            "number of left part nodes add right part nodes must greater than 0,",
                            tools::string_format("but found %d + %d = %d",
                            left, right, left + right));
                        return;
                    }
                    _left = left;
                    _right = right;
                    int node_count = left + right;
                    if (this->_node_count != node_count) {
                        _msg::__warn_msg(_msg::_defl,
                            tools::string_format("number of left part nodes add right part nodes is not equal to node_count(%d),", node_count),
                            tools::string_format("set node_count to %d + %d = %d.",
                            left, right, left + right));
                        this->set_node_count(node_count);
                    }                   
                }
                _GET_VALUE(int, left)
                _GET_VALUE(int, right)

                void set_node_output_format(NodeOutputFormat format) { _node_output_format = format; }
                void use_format_node() {  _node_output_format = Node; }
                void use_format_left_right() { _node_output_format = LeftRight; }
                void use_format_node_left() { _node_output_format = NodeLeft; }
                void use_format_node_right() { _node_output_format = NodeRight; }
                _GET_VALUE(NodeOutputFormat, node_output_format)
                
                _DISABLE_SELF_LOOP
                _DISABLE_DIRECTION
                _OUTPUT_FUNCTION_SETTING(_Self)

                virtual long long max_edge_count() override {
                    if (this->_node_count == 0) return 0;
                    if (this->_multiply_edge) return this->_node_count == 1 ? 0 : _setting::edge_count_inf;
                    if (_left < 0 || _right < 0) {
                        long long n = this->_node_count;
                        return __count_edge_by_left(n / 2);
                    } else {
                        return __count_edge_by_left(_left);
                    }
                }

                virtual void rand_edge_count(long long from = _setting::auto_edge_limit, long long to = _setting::auto_edge_limit) override {
                    _GenGraph<NodeType, EdgeType>::rand_edge_count(from, to); 
                    if (_left < 0) rand_left();
                }

                void rand_left() {
                    int n = this->_node_count;
                    int l = 0, r = n / 2, limit = -1;
                    if (this->_multiply_edge) {
                        limit = n == 1 ? 0 : 1;
                    } else {
                        while (l <= r) {
                            int mid = (l + r) / 2;
                            long long max_edge_count = __count_edge_by_left(mid);
                            if (max_edge_count < this->_edge_count) {
                                l = mid + 1;
                            } else {
                                limit = r;
                                r = mid - 1;
                            }
                        }
                    }
                    if (limit == -1) {
                        _msg::__fail_msg(_msg::_defl,
                            tools::string_format("can not find a left part size which can has a edge_count equal to %d.", this->_edge_count));
                    }                    
                    _left = rand_numeric::rand_int(limit, n - limit);
                    _right = n - _left;
                }

            protected:
                _DEFAULT_GRAPH_GEN_FUNC(BipartiteGraph)

                long long __count_edge_by_left(long long left) {
                    return left * (this->_node_count - left);
                }

                virtual void __format_output_node(std::vector<int>& first_line) const override {
                    if (this->_output_node_count) {
                        if (_node_output_format == Node) {
                            first_line.push_back(this->_node_count);
                        } else if (_node_output_format == LeftRight) {
                            first_line.push_back(_left);
                            first_line.push_back(_right);
                        } else if (_node_output_format == NodeLeft) {
                            first_line.push_back(this->_node_count);
                            first_line.push_back(_left);
                        } else if (_node_output_format == NodeRight) {
                            first_line.push_back(this->_node_count);
                            first_line.push_back(_right);
                        }
                    }
                }
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_BIPARTITE_GRAPH_H_
#ifndef _SGPCET_MAX_SON_TREE_H_
#define _SGPCET_MAX_SON_TREE_H_

#ifndef _SGPCET_TREE_H_
#include "tree.h"
#endif // !_SGPCET_TREE_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class MaxSonTree;

            template <typename NodeType, typename EdgeType>
            class MaxSonTreeGen : public BasicPrueferGen<MaxSonTree, NodeType, EdgeType> {
            protected:
                using Context = MaxSonTree<NodeType, EdgeType>;
            public:
                MaxSonTreeGen(Context& tree) : BasicPrueferGen<MaxSonTree, NodeType, EdgeType>(tree) {}
            protected:
                virtual void __generate_pruefer() override {
                    _CONTEXT_GET(max_son)
                    _CONTEXT_GET(node_count)
                    int max_degree = max_son + 1;
                    std::vector<int> times = rand_array::rand_sum(node_count, node_count - 2, 0, max_degree - 1);
                    _CONTEXT_GET_REF(root)
                    if (times[root] == max_degree - 1) {
                        int p;
                        do {
                            p = rnd.next(0, node_count - 1);
                        } while (p == root || times[p] == max_degree - 1);
                        std::swap(times[root], times[p]);
                    }
                    std::vector<int> pruefer = rand_array::shuffle_index(times);
                    this->__pruefer_decode(pruefer);
                }

                virtual void __self_init() override {
                    _CONTEXT_GET_REF(max_son)
                    _CONTEXT_GET(node_count)
                    if (max_son == -1) {
                        if (node_count == 1) max_son = 0;
                        else max_son = rnd.next(1, node_count - 1);
                    }
                }

                virtual void __judge_self_limit() override{
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(max_son)
                    if (max_son > node_count - 1) {
                        _msg::__warn_msg(_msg::_defl,
                            tools::string_format("the max_son limit %d is greater than node_count - 1(%d)", max_son, node_count),
                            ", equivalent to use Tree::use_pruefer()");
                    }
                    int max_son_limit = node_count == 1 ? 0 : 1;
                    
                    if (max_son < max_son_limit) {
                        _msg::__fail_msg(_msg::_defl,
                            tools::string_format("the max_son limit of %s node's tree is greater than or equal to %d, but found %d.",
                            node_count > 1 ? "2 or more" : std::to_string(node_count).c_str(),
                            max_son_limit, max_son));
                    }
                }

            };

            template <typename NodeType, typename EdgeType>
            class MaxSonTree : public _GenTree<NodeType, EdgeType> {
            protected:
                using _Self =  MaxSonTree<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                int _max_son;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                MaxSonTree(int node = 1, int begin_node = 1, int root = 1, int max_son = -1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, true, root,
                        nodes_weight_function, edges_weight_function),
                    _max_son(max_son)
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                MaxSonTree(int node = 1, int begin_node = 1, int root = 1, int max_son = -1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, true, root, edges_weight_function),
                    _max_son(max_son)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                MaxSonTree(int node = 1, int begin_node = 1, int root = 1, int max_son = -1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, true, root, nodes_weight_function),
                    _max_son(max_son)
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                MaxSonTree(int node = 1, int begin_node = 1, int root = 1, int max_son = -1) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, true, root),
                    _max_son(max_son)
                {
                    _TREE_GRAPH_DEFAULT       
                }  
                _OUTPUT_FUNCTION_SETTING(_Self)

                _SET_GET_VALUE(int, max_son)
                _MUST_IS_ROOTED
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(MaxSonTree)
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_MAX_SON_TREE_H_
#ifndef _SGPCET_MAX_DEGREE_TREE_H_
#define _SGPCET_MAX_DEGREE_TREE_H_

#ifndef _SGPCET_TREE_H_
#include "tree.h"
#endif // !_SGPCET_TREE_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class MaxDegreeTree;

            template <typename NodeType, typename EdgeType>
            class MaxDegreeTreeGen : public BasicPrueferGen<MaxDegreeTree, NodeType, EdgeType> {
            protected:
                using Context = MaxDegreeTree<NodeType, EdgeType>;
            public:
                MaxDegreeTreeGen(Context& tree) : BasicPrueferGen<MaxDegreeTree, NodeType, EdgeType>(tree) {}
            protected:
                virtual void __generate_pruefer() override {
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(max_degree)
                    std::vector<int> times = rand_array::rand_sum(node_count, node_count - 2, 0, max_degree - 1);
                    std::vector<int> pruefer = rand_array::shuffle_index(times);
                    this->__pruefer_decode(pruefer);
                }

                virtual void __self_init() override {
                    _CONTEXT_GET_REF(max_degree)
                    _CONTEXT_GET(node_count)
                    if (max_degree == -1) {
                        if (node_count == 1) max_degree = 0;
                        else if (node_count == 2) max_degree = 1;
                        else max_degree = rnd.next(2, node_count - 1);
                    }
                }

                virtual void __judge_self_limit() override{
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(max_degree)
                    if (max_degree > node_count - 1) {
                        _msg::__warn_msg(_msg::_defl,
                            tools::string_format("the max_degree limit %d is greater than node_count - 1(%d)", max_degree, node_count),
                            ", equivalent to use Tree::use_pruefer()");
                    }
                    int max_degree_limit = node_count == 1 ? 0 : (node_count == 2 ? 1 : 2);
                    
                    if (max_degree < max_degree_limit) {
                        _msg::__fail_msg(_msg::_defl,
                            tools::string_format("the max_degree limit of %s node's tree is greater than or equal to %d, but found %d.",
                            node_count > 2 ? "3 or more" : std::to_string(node_count).c_str(),
                            max_degree_limit, max_degree));
                    }
                }

            };

            template <typename NodeType, typename EdgeType>
            class MaxDegreeTree : public _GenTree<NodeType, EdgeType> {
            protected:
                using _Self =  MaxDegreeTree<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                int _max_degree;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                MaxDegreeTree(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1, int max_degree = -1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root,
                        nodes_weight_function, edges_weight_function),
                    _max_degree(max_degree)
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                MaxDegreeTree(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1, int max_degree = -1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root, edges_weight_function),
                    _max_degree(max_degree)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                MaxDegreeTree(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1, int max_degree = -1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root, nodes_weight_function),
                    _max_degree(max_degree)
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                MaxDegreeTree(int node = 1, int begin_node = 1, bool is_rooted = false, int root = 1, int max_degree = -1) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, is_rooted, root),
                    _max_degree(max_degree)
                {
                    _TREE_GRAPH_DEFAULT       
                }  
                _OUTPUT_FUNCTION_SETTING(_Self)

                _SET_GET_VALUE(int, max_degree)
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(MaxDegreeTree)
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_MAX_DEGREE_TREE_H_
#ifndef _SGPCET_HEIGHT_TREE_H_
#define _SGPCET_HEIGHT_TREE_H_

#ifndef _SGPCET_TREE_H_
#include "tree.h"
#endif // !_SGPCET_TREE_H_

namespace generator {
    namespace rand_graph {
        namespace basic {
            template<typename NodeType, typename EdgeType>
            class HeightTree;

            template <typename NodeType, typename EdgeType>
            class HeightTreeGen : public BasicRandomFatherGen<HeightTree, NodeType, EdgeType> {
            protected:
                using Context = HeightTree<NodeType, EdgeType>;
            public:
                HeightTreeGen(Context& tree) : BasicRandomFatherGen<HeightTree, NodeType, EdgeType>(tree) {}
            protected:
                virtual void __self_init() override {
                    _CONTEXT_GET_REF(height)
                    _CONTEXT_GET(node_count)
                    if (height == -1) {
                        height = rnd.next(node_count == 1 ? 1 : 2, node_count);
                    }
                }

                virtual void __judge_self_limit() override{
                    _CONTEXT_GET(node_count)
                    _CONTEXT_GET(height)
                    if (height > node_count || (node_count > 1 && height <= 1) || height < 1) {
                        _msg::__fail_msg(_msg::_defl, 
                            tools::string_format("limit of the height is [%d, %d], but found %d.", 
                            node_count == 1 ? 1 : 2, node_count, height));
                    }
                }

                virtual void __random_father() override {
                    _CONTEXT_GET(height)
                    _CONTEXT_GET(node_count)
                    std::vector<int> number(height, 1);
                    int w = node_count - height;
                    for (int i = 1; i <= w; i++) {
                        number[rnd.next(1, height - 1)]++;
                    }
                    int l = 0, r = 0, k = 0;
                    for (int i = 1; i < node_count; i++) {
                        if (r + number[k] == i) {
                            l = r;
                            r += number[k];
                            k++;
                        }
                        int f = rnd.next(l, r - 1);
                        this->__add_edge(this->_rank[f], this->_rank[i]);
                    }
                }
            };

            template <typename NodeType, typename EdgeType>
            class HeightTree : public _GenTree<NodeType, EdgeType> {
            protected:
                using _Self =  HeightTree<NodeType,EdgeType>;
                _OUTPUT_FUNCTION(_Self)
                _DEF_GEN_FUNCTION
                int _height;
            public:
                template<typename T = NodeType, typename U = EdgeType, _IsBothWeight<T, U> = 0>
                HeightTree(int node = 1, int begin_node = 1, int root = 1, int height = -1,
                    NodeGenFunction nodes_weight_function = nullptr,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, true, root,
                        nodes_weight_function, edges_weight_function),
                    _height(height)
                {
                    _TREE_GRAPH_DEFAULT       
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsEdgeWeight<T, U> = 0>
                HeightTree(int node = 1, int begin_node = 1,  int root = 1, int height = -1,
                    EdgeGenFunction edges_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, true, root, edges_weight_function),
                    _height(height)
                {
                    _TREE_GRAPH_DEFAULT        
                }

                template<typename T = NodeType, typename U = EdgeType, _IsNodeWeight<T, U> = 0>
                HeightTree(int node = 1, int begin_node = 1,  int root = 1, int height = -1,
                    NodeGenFunction nodes_weight_function = nullptr) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, true, root, nodes_weight_function),
                    _height(height)
                {
                    _TREE_GRAPH_DEFAULT        
                }
                
                template<typename T = NodeType, typename U = EdgeType, _IsUnweight<T, U> = 0>
                HeightTree(int node = 1, int begin_node = 1, int root = 1, int height = -1) :
                    _GenTree<NodeType, EdgeType>(node, begin_node, true, root),
                    _height(height)
                {
                    _TREE_GRAPH_DEFAULT       
                }  
                _OUTPUT_FUNCTION_SETTING(_Self)

                _SET_GET_VALUE(int, height)
                _MUST_IS_ROOTED
            protected:
                _DEFAULT_GRAPH_GEN_FUNC(HeightTree)
            };   
        } // namespace basic
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_HEIGHT_TREE_H_
#ifndef _SGPCET_BIG_INT_CALCULATOR_H_
#define _SGPCET_BIG_INT_CALCULATOR_H_

#ifndef _SGPCET_MACRO_H_
#include "basic/macro.h"
#endif //!_SGPCET_MACRO_H_
#ifndef _SGPCET_NTT_H_
#include "ntt.h"
#endif // !_SGPCET_NTT_H_

namespace generator {
    namespace math {
        template <typename TYPE>
        class BigIntCalculator {
        public:
            using i32 = int32_t;
            using i64 = int64_t;
            using u32 = uint32_t;
            using u64 = uint64_t;

            struct DivResult {
                TYPE quotient; // 商
                TYPE remainder; // 余数 

                DivResult() : quotient(0), remainder(0) {}
                DivResult(TYPE q, TYPE r) : quotient(q), remainder(r) {}
                TYPE first() { return quotient; }
                TYPE second() { return remainder; }
            };
        protected:
            bool _is_negative;
            std::vector<u32> _data;
        public:

            BigIntCalculator() {
                set_value(0);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            BigIntCalculator(T val) {
                set_value(val);
            }
            
            BigIntCalculator(const TYPE& other) : _data(other._data), _is_negative(other._is_negative) {}

            BigIntCalculator& operator=(const TYPE& other) {
                if (this != &other) {
                    _data = other._data;
                    _is_negative = other._is_negative;
                }
                return *this; 
            }

            BigIntCalculator(TYPE&& other) noexcept : _data(std::move(other._data)), _is_negative(other._is_negative) {}

            BigIntCalculator& operator=(TYPE&& other) noexcept {
                if (this!= &other) {
                    _data = std::move(other._data);
                    _is_negative = other._is_negative;
                }
                return *this; 
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE& set_value(T val) {
                _data.clear();
                u64 v = val < 0 ? -val : val;
                _is_negative = val < 0;
                if (val == 0) {
                    _data.push_back(0);
                    _is_negative = false;
                    return static_cast<TYPE&>(*this);
                }
                i32 base = static_cast<TYPE*>(this)->__base();
                while (v) {
                    _data.push_back(v % base);
                    v /= base; 
                }
                return static_cast<TYPE&>(*this);
            }

            size_t size() { return _data.size(); }
            size_t size() const { return _data.size(); }

            TYPE operator+() const {
                TYPE result(static_cast<const TYPE&>(*this));
                return result;
            }

            TYPE operator+(const TYPE& other) const {
                if ((_is_negative ^ other._is_negative) == 0) return TYPE::__add(static_cast<const TYPE&>(*this), other); // 同号
                else if (_is_negative) return TYPE::__sub(other, static_cast<const TYPE&>(*this)); // 负数 + 正数
                else return TYPE::__sub(static_cast<const TYPE&>(*this), other); // 正数 + 负数
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE operator+(const T& a) const {
                return (*this) + TYPE(a);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend TYPE operator+(const T& a, const TYPE& b) { 
                return b + a; 
            }

            TYPE operator+=(const TYPE& other) {
                *this = *this + other;
                return static_cast<TYPE&>(*this); 
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE operator+=(const T& a) {
                return operator+=(TYPE(a));
            }

            TYPE operator++() {
               *this = *this + 1;
               return static_cast<TYPE&>(*this); 
            }

            TYPE operator++(int) {
                TYPE result(static_cast<const TYPE&>(*this));
                *this = *this + 1;
                return result; 
            }

            TYPE operator-() const {
                TYPE result(static_cast<const TYPE&>(*this));
                if (result.__is_zero()) result._is_negative = false;
                else result._is_negative = !result._is_negative;
                return result;
            }

            TYPE operator-(const TYPE& other) const {
                if (_is_negative ^ other._is_negative) return TYPE::__add(static_cast<const TYPE&>(*this), other); // 异号
                else if (_is_negative) return TYPE::__sub(other, static_cast<const TYPE&>(*this)); // 负数 - 负数
                else return TYPE::__sub(static_cast<const TYPE&>(*this), other); // 正数 - 正数
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE operator-(const T& a) const {
                return (*this) - TYPE(a);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend TYPE operator-(const T& a, const TYPE& b) {
                return TYPE(a) - b;
            }

            TYPE operator-=(const TYPE& other) {
                *this = *this - other;
                return static_cast<TYPE&>(*this); 
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE operator-=(const T& a) {
                return operator-=(TYPE(a)); 
            }

            TYPE operator--() {
                *this = *this - 1;
                return static_cast<TYPE&>(*this); 
            }

            TYPE operator--(int) {
                TYPE result(static_cast<const TYPE&>(*this));
                *this = *this - 1;
                return result; 
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE operator*(const T& other) const {
                return (*this) * TYPE(other);
            }

            TYPE operator*(const TYPE& other) const {
                if (__is_zero() || other.__is_zero()) return TYPE();
                if (this == &other) return TYPE::__ntt_square(other);
                TYPE result(static_cast<const TYPE&>(*this));
                if (__one_size()) result = TYPE::__mul_int(other, _data[0]);
                if (other.__one_size()) result = TYPE::__mul_int(static_cast<const TYPE&>(*this), other._data[0]);
                if (this->size() + other.size() < _setting::ntt_threshold) result = TYPE::__simple_mul(static_cast<const TYPE&>(*this), other);
                else result = TYPE::__ntt_mul(static_cast<const TYPE&>(*this), other);
                result._is_negative = _is_negative ^ other._is_negative;
                return result;
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend TYPE operator*(const T& a, const TYPE& b) { 
                return b * a; 
            }

            TYPE operator*=(const TYPE& other) {
                *this = *this * other;
                return static_cast<TYPE&>(*this); 
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE operator*=(const T& a) {
                return operator*=(TYPE(a));
            }

            DivResult div_mod(const TYPE& other) const {
                TYPE zero;
                zero.__copy_status(other);
                zero.set_value(0);
                if (this == &other) return DivResult{TYPE(1), zero};
                if (other.__one_size()) {
                    DivResult result = TYPE::__div_int(static_cast<const TYPE&>(*this), (u32)other._data[0]);
                    if (other._is_negative) result.quotient._is_negative = !result.quotient._is_negative;
                    return result;
                }
                if (size() + other.size() < _setting::fast_div_threshold) return TYPE::__simple_div(static_cast<const TYPE&>(*this), other);
                else return TYPE::__fast_div(static_cast<const TYPE&>(*this), other);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            DivResult div_mod(const T& other) const {
                return div_mod(TYPE(other));
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE operator/(const T& other) {
                return div_mod(other).first();
            }

            TYPE operator/(const TYPE& other) {
                return div_mod(other).first(); 
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend TYPE operator/(const T& a, const TYPE& b) { 
                return TYPE(a) / b; 
            }

            TYPE operator/=(const TYPE& other) {
                *this = *this / other;
                return static_cast<TYPE&>(*this);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE operator/=(const T& a) {
                return operator/=(TYPE(a));
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE operator%(const T& other) {
                return div_mod(other).second();
            }

            TYPE operator%(const TYPE& other) {
                return div_mod(other).second();  
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend TYPE operator%(const T& a, const TYPE& b) {
                return TYPE(a) % b;
            }

            TYPE operator%=(const TYPE& other) {
                *this = *this % other;
                return static_cast<TYPE&>(*this); 
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE operator%=(const T& a) {
                return operator%=(TYPE(a));
            }

            explicit operator bool() const {
                return !__is_zero();
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            static TYPE pow(const TYPE& a, T b) {
                TYPE result(a);
                if (b < 0) {
                    if (a.__is_zero()) _msg::__error_msg(_msg::_defl, "Zero cannot be raised to a negative power.");
                    else if (a.__is_one()) result.set_value(1);
                    else result.set_value(0);
                    return result;
                }
                if (b == 0) {
                    result.set_value(1);
                    return result;
                }
                if (b == 1) return result;
                result.set_value(1);
                TYPE base(a);
                while (b) {
                    if (b & 1) result = result * base;
                    base = base * base;
                    b >>= 1;
                }
                return result;
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            static TYPE pow(T a, T b) {
                return pow(TYPE(a), b);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            TYPE& pow(T b) {
                *this = TYPE::pow(*this, b);
                return static_cast<TYPE&>(*this);
            }

            bool operator==(const TYPE& other) const {
                return TYPE::__equal(static_cast<const TYPE&>(*this), other);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            bool operator==(const T& other) const {
                TYPE r;
                r.__copy_status(static_cast<const TYPE&>(*this));
                r.set_value(other);
                return *this == r; 
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend bool operator==(const T& a, const TYPE& b) { 
                return b == a; 
            }

            bool operator!=(const TYPE& other) const {
                return !operator==(other);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            bool operator!=(const T& other) const {
                TYPE r;
                r.__copy_status(static_cast<const TYPE&>(*this));
                r.set_value(other);
                return *this != r;
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend bool operator!=(const T& a, const TYPE& b) {
                return b != a;
            }

            bool operator<(const TYPE& other) const {
                return TYPE::__less(static_cast<const TYPE&>(*this), other);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            bool operator<(const T& other) const {
                return *this < TYPE(other);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend bool operator<(const T& a, const TYPE& b) {
                return b > a;
            }

            bool operator<=(const TYPE& other) const {
                return operator<(other) || operator==(other); 
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            bool operator<=(const T& other) const {
                return *this <= TYPE(other);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend bool operator<=(const T& a, const TYPE& b) {
                return b >= a;
            }

            bool operator>(const TYPE& other) const {
                return !operator<=(other);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            bool operator>(const T& other) const {
                return *this > TYPE(other);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend bool operator>(const T& a, const TYPE& b) {
                return b < a;
            }

            bool operator>=(const TYPE& other) const {
                return !operator<(other);  
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            bool operator>=(const T& other) const {
                return *this >= TYPE(other);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            friend bool operator>=(const T& a, const TYPE& b) {
                return b <= a;
            }

            static TYPE abs(const TYPE& a) {
                TYPE result(a);
                result._is_negative = false;
                return result;
            }

            _SET_GET_VALUE(std::vector<u32>, data)
            _SET_GET_VALUE(bool, is_negative)
        protected:

            void __trim() {
                while (_data.size() > 1 && _data.back() == 0) _data.pop_back();
                if (_data.size() == 1 && _data.back() == 0) _is_negative = false;
            }

            bool __is_zero() {
                return _data.size() == 1 && _data[0] == 0;
            }

            bool __is_zero() const {
                return _data.size() == 1 && _data[0] == 0;
            }

            bool __is_one() {
                return _data.size() == 1 && _data[0] == 1;
            }

            bool __is_one() const {
                return _data.size() == 1 && _data[0] == 1; 
            }

            bool __one_size() {
                return _data.size() == 1;
            }

            bool __one_size() const {
                return _data.size() == 1; 
            }

            // 值相加，保证符号相同
            static TYPE __add(const TYPE& a, const TYPE& b) {
                TYPE result;
                result.__copy_status(a);
                result._is_negative = a._is_negative;
                result._data.resize(std::max(a.size(), b.size()), 0); 
                u64 add = 0;
                for (size_t i = 0; i < result.size(); i++) {
                    u64 sum = 0;
                    if (i < a.size()) sum += a._data[i];
                    if (i < b.size()) sum += b._data[i];
                    result.__carry(add, result._data[i], sum);
                }
                if (add) result._data.push_back(add);
                result.__trim();
                return result;
            }

            // 值相减
            static TYPE __sub(const TYPE& a, const TYPE& b) {
                TYPE result;
                result.__copy_status(a);
                result._data.resize(std::max(a.size(), b.size()), 0);
                i64 borrow = 0;
                for (size_t i = 0; i < result.size(); i++) {
                    i64 diff = 0;
                    if (i < a.size()) diff += a._data[i];
                    if (i < b.size()) diff -= b._data[i];
                    result.__borrow(borrow, result._data[i], diff); 
                }
                if (borrow) {
                    result._is_negative = true;
                    i64 add = 1;
                    i32 base = a.__base();
                    for (size_t i = 0; i < result.size(); i++) {
                        result.__carry(add, result._data[i], base - result._data[i] - 1);
                    }
                }
                result.__trim();
                return result;
            }

            // 值相乘
            static TYPE __mul_int(const TYPE& a, u32 b) {
                TYPE result;
                result.__copy_status(a);
                result._data.resize(a.size(), 0);
                u64 add = 0;
                for (size_t i = 0; i < result.size(); i++) {
                    result.__carry(add, result._data[i], (u64)a._data[i] * b); 
                }
                i32 base = a.__base();
                while (add) {
                    result._data.push_back(add % base);
                    add /= base;
                }
                result.__trim();
                return result;
            }
            
            static TYPE __simple_mul(const TYPE& a, const TYPE& b) {
                size_t len_a = a.size();
                size_t len_b = b.size();
                TYPE result;
                result.__copy_status(a);
                result._data.resize(len_a + len_b, 0); 
                for (size_t i = 0; i < len_a; i++) {
                    u64 add = 0, va = a._data[i]; 
                    for (size_t j = 0; j < len_b; j++) {
                        result.__carry(add, result._data[i + j], va * (u64)b._data[j] + result._data[i + j]); 
                    }
                    for (size_t k = i + len_b; add; k++) {
                        result.__carry(add, result._data[k], result._data[k]); 
                    }
                }
                result.__trim();
                return result;
            }

            static TYPE __ntt_mul(const TYPE& a, const TYPE& b) {
                TYPE result;
                result.__copy_status(a);
                i32 base = a.__base();
                auto data = CrtMultiplier<u32>::multiply(a._data, b._data, base);
                result._data = std::move(data);
                return result;
            }

            static TYPE __ntt_square(const TYPE& a) {
                TYPE result;
                result.__copy_status(a);
                if (a.__is_zero()) {
                    result.set_value(0);
                    return result;
                }
                i32 base = a.__base();
                auto data = CrtMultiplier<u32>::square(a._data, base); 
                result._data = std::move(data);
                result._is_negative = false;
                return result;
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            static int __log_pow2(T x) {
                int n = 0;
                while(x >>= 1) n++;
                return n;
            }

            static bool __is_pow2(i32 x) {
                return x && ((x & (x - 1)) == 0);
            }

            static TYPE __left_shift(const TYPE& a, i32 shift) {
                if (shift < 0) _msg::__error_msg(_msg::_defl, "Shift value cannot be negative.");
                if (shift == 0) return TYPE(a);
                int d = a.__digits();
                int sum = shift / d;
                int res = shift % d;
                TYPE result;
                result.__copy_status(a);
                result._is_negative = a._is_negative;
                result._data.resize(sum, 0);
                TYPE b(a);
                b = TYPE::__mul_int(a, TYPE::__radix_pow(a, res));
                result._data.insert(result._data.end(), b._data.begin(), b._data.end());
                result.__trim();
                return result;
            }

            static TYPE __left_shift_bits(const TYPE& a, i32 shift) {
                if (shift < 0) _msg::__error_msg(_msg::_defl, "Shift value cannot be negative.");
                if (shift == 0) return TYPE(a);
                int radix = a.__radix();
                if (radix == 2) return TYPE::__left_shift(a, shift);
                if (__is_pow2(radix)) { // 2的幂次
                    int log_radix = __log_pow2(radix);
                    TYPE result = TYPE::__left_shift(a, shift / log_radix);
                    return result * TYPE::pow(2, shift % log_radix);
                }
                else {
                    TYPE m = TYPE::pow(2, shift);
                    TYPE result(a);
                    return result * m;
                }
            }

            static TYPE __right_shift(const TYPE& a, i32 shift) {
                if (shift < 0) _msg::__error_msg(_msg::_defl, "Shift value cannot be negative.");
                if (shift == 0) return TYPE(a);
                TYPE result;
                result.__copy_status(a);
                if (shift > a.size() * a.__digits()) {
                    result.set_value(0);
                    return result;
                }
                int d = a.__digits();
                int sum = shift / d;
                int res = shift % d;
                result._is_negative = a._is_negative;
                result._data.insert(result._data.begin(), a._data.begin() + sum, a._data.end());
                result = TYPE::__div_int(result, TYPE::__radix_pow(a, res)).first();
                result.__trim();
                return result;
            }

            static TYPE __right_shift_bits(const TYPE& a, i32 shift) {
                if (shift < 0) _msg::__error_msg(_msg::_defl, "Shift value cannot be negative.");
                if (shift == 0) return TYPE(a);
                int radix = a.__radix();
                if (radix == 2) return TYPE::__right_shift(a, shift);
                if (__is_pow2(radix)) { // 2的幂次
                    int log_radix = __log_pow2(radix);
                    TYPE result = TYPE::__right_shift(a, shift / log_radix);
                    return result / TYPE::pow(2, shift % log_radix);
                }
                else {
                    TYPE m = TYPE::pow(2, shift);
                    TYPE result(a);
                    return result / m;
                } 
            }

            static DivResult __div_int(const TYPE& a, u32 b) {
                if (b == 0) _msg::__error_msg(_msg::_defl, "Division by zero.");
                TYPE zero;
                zero.__copy_status(a);
                zero.set_value(0);
                if (b == 1) return DivResult(TYPE(a), zero);
                if (a.__is_zero()) return DivResult(zero, zero);
                TYPE q; // 商
                q.__copy_status(a);
                u64 r = 0; // 余数
                q._data.resize(a.size(), 0);
                u64 base = (u64)a.__base();
                for (int i = a.size() - 1; i >= 0; i--) {
                    r = r * base + a._data[i];
                    q._data[i] = r / b;
                    r %= b;
                }
                q.__trim();
                q._is_negative = a._is_negative;
                TYPE result;
                result.__copy_status(a);
                result.set_value(r);
                result._is_negative = a._is_negative;
                return DivResult(q, result);
            }

            static DivResult __simple_div(const TYPE& a, const TYPE& b) {
                if (b.__is_zero()) _msg::__error_msg(_msg::_defl, "Division by zero.");
                TYPE zero;
                zero.__copy_status(a);
                zero.set_value(0);
                if (b.__is_one()) {
                    if (b._is_negative) return DivResult(TYPE(-a), zero);
                    else return DivResult(TYPE(a), zero);
                }
                if (a.__is_zero()) return DivResult(zero, zero);
                if (__abs_compare(a, b) < 0) return DivResult(zero, a);
                TYPE q, r; // 商和余数
                q.__copy_status(a);
                r.__copy_status(a);
                TYPE xa = TYPE::abs(a);
                TYPE xb = TYPE::abs(b);
                TYPE p; // 幂次
                p.__copy_status(a);
                p.set_value(1);
                while (xa >= xb) {
                    xb = TYPE::__mul_int(xb, 2);
                    p = TYPE::__mul_int(p, 2);
                }
                while (p >= 1) {
                    if (xa >= xb) {
                        xa -= xb;
                        q += p;
                    }
                    xb = TYPE::__div_int(xb, 2).first();
                    p = TYPE::__div_int(p, 2).first();
                }
                q._is_negative = a._is_negative ^ b._is_negative;
                q.__trim();
                r = a - q * b;
                return DivResult(q, r);
            }

            static TYPE __newton_inv(const TYPE& num, i32 n) {
                if (num == 0) _msg::__error_msg(_msg::_defl, "Division by zero.");
                if (n - num.size() <= _setting::newton_threshold) {
                    TYPE sum = TYPE::__left_shift(TYPE(1), n);
                    return TYPE::__simple_div(sum, num).first();
                }

                i32 k = (n - num.size() + 2) >> 1;
                i32 k2 = k > num.size() ? 0 : num.size() - k;
                TYPE x = TYPE::__right_shift(num, k2);
                i32 n2 = k + x.size();
                TYPE y = __newton_inv(x, n2);
                TYPE a = y + y;
                TYPE b = num * TYPE::__ntt_square(y);
                return TYPE::__left_shift(a, n - n2 - k2) - TYPE::__right_shift(b, (2 * (n2 + k2) - n)) - 1;
            }

            static DivResult __fast_div(const TYPE &a, const TYPE &b) {
                if (b.__is_zero()) _msg::__error_msg(_msg::_defl, "Division by zero.");
                TYPE zero;
                zero.__copy_status(a);
                zero.set_value(0);
                if (b.__is_one()) {
                    if (b._is_negative) return DivResult(TYPE(-a), zero);
                    else return DivResult(TYPE(a), zero);
                }
                if (a.__is_zero()) return DivResult(zero, zero);
                if (__abs_compare(a, b) < 0) return DivResult(zero, a);              
                TYPE xa = TYPE::abs(a);
                TYPE xb = TYPE::abs(b);
                i32 k = xa.size() - xb.size() + 2;
                i32 k2 = k > xb.size() ? 0 : xb.size() - k;
                TYPE adj = TYPE::__right_shift(xb, k2);
                if (k2 != 0) adj++;
                i32 n2 = k + adj.size();
                TYPE inv = __newton_inv(adj, n2);
                TYPE q = TYPE::__left_shift(xa * inv, n2 + k2);
                TYPE r = xa - q * xb;
                while (r >= xb) {
                    q++;
                    r -= xb;
                }
                q._is_negative = a._is_negative ^ b._is_negative;
                r._is_negative = a._is_negative;
                q.__trim();
                r.__trim();
                return DivResult(q, r);
            }

            // -1 : a < b; 
            // 0  : a == b; 
            // 1  : a > b;
            static int __abs_compare(const TYPE& a, const TYPE& b) {
                if (a.size() != b.size()) return a.size() < b.size() ? -1 : 1;
                for (size_t i = a.size(); i-- > 0;) {
                    if (a._data[i] != b._data[i]) return a._data[i] < b._data[i] ? -1 : 1;
                }
                return 0;
            }

            static bool __equal(const TYPE& a, const TYPE& b) {
               return a._is_negative == b._is_negative && __abs_compare(a, b) == 0; 
            }

            static bool __less(const TYPE& a, const TYPE& b) {
                if (a._is_negative != b._is_negative) return a._is_negative;
                return a._is_negative? __abs_compare(a, b) > 0 : __abs_compare(a, b) < 0; 
            }

            static i64 __radix_pow(const TYPE& a, i32 b) {
                static std::unordered_map<i32, std::vector<i64>> radix_pow;
                int radix = a.__radix();
                if (radix_pow.find(radix) == radix_pow.end()) {
                    radix_pow.insert({radix, std::vector<i64>({1})}); 
                }
                auto &v = radix_pow[radix];
                int os = v.size();
                if (v.size() <= b) {
                    i64 base = v.back();
                    v.resize(b + 1);
                    for (size_t i = os; i <= b; i++) {
                        base *= radix;
                        v[i] = base;
                    }
                }
                return v[b];
            }

        };
    } // namespace math
} // namespace generator

#endif // !_SGPCET_BIG_INT_CALCULATOR_H_
#ifndef _SGPCET_CHECKER_H_
#define _SGPCET_CHECKER_H_

#ifndef _SGPCET_PROGRAM_H_
#include "program.h"
#endif // !_SGPCET_PROGRAM_H_
#ifndef _SGPCET_IO_INIT_H_
#include "io_init.h"
#endif // !_SGPCET_IO_INIT_H_

namespace generator {
    namespace io {
        class _Checker {
        protected:
            _Program* _checker;
            Path _input;
            Path _std_output;
            Path _ans_output;
            Path _testlib_output;
            _enum::_JudgeState _result;
            int _time_limit;
        public:
            _Checker() : _checker(nullptr), _result(_enum::_JudgeState::_UNKNOWN), _time_limit(_setting::time_limit_inf) {}

            template<typename T>
            _Checker(T&& checker) : _checker(nullptr), _result(_enum::_JudgeState::_UNKNOWN), _time_limit(_setting::time_limit_inf) {
                __set_checker(std::forward<T>(checker));
            }

            ~_Checker() {
                if (_checker != nullptr) delete _checker;
            }

            _GET_VALUE(_Program*, checker);
            _SET_GET_VALUE(Path, input);
            _SET_GET_VALUE(Path, std_output);
            _SET_GET_VALUE(Path, ans_output);
            _SET_GET_VALUE(Path, testlib_output);
            _SET_GET_VALUE(_enum::_JudgeState, result);
            _SET_GET_VALUE(int, time_limit);

            void __change_case(Path input, Path std_output, Path ans_output, Path testlib_output) {
                _input = input;
                _std_output = std_output;
                _ans_output = ans_output;
                _testlib_output = testlib_output;
            }

            template<typename T>
            void __set_checker(T&& checker) {
                if (_checker != nullptr) delete _checker;
                _checker = __checker_program(std::forward<T>(checker));
            }

            void __check_result() {
                _result = _enum::_JudgeState::_UNKNOWN;
                std::string testlib_output_content = "";
                _Program* p;
                if (_checker->enable_default_args()) 
                    p = _checker->__clone(tools::string_join(" ", _input, _ans_output, _std_output));
                else 
                    p = _checker->__clone();
                ReturnState res = p->__run_program(_setting::_default_path, _setting::_default_path, _testlib_output, _time_limit, _enum::_FuncProgramType::_CHECKER);
                if (__is_error(res.exit_code)) {
                    _result = _enum::_JudgeState::_ERROR;
                    return;
                }
                std::ifstream checker_stream(_testlib_output.path());
                std::string line;
                while(checker_stream >> line){
                    testlib_output_content += line;
                    testlib_output_content += " ";
                }
                checker_stream.close();
                if (testlib_output_content.substr(0, 2) == "ok") _result = _enum::_JudgeState::_AC;
                else _result = _enum::_JudgeState::_WA;
                delete p;
            }
        };
    } // namespace io
} // namespace generator

#endif // _SGPCET_CHECKER_H_
#ifndef _SGPCET_REPORTER_H_
#define _SGPCET_REPORTER_H_

#ifndef _SGPCET_IO_INIT_H_
#include "io_init.h"
#endif // !_SGPCET_IO_INIT_H_

namespace generator {
    namespace io {

        class _Reporter {
        protected:
            static _msg::_ColorMsg _ac_msg;
            static _msg::_ColorMsg _wa_msg;
            static _msg::_ColorMsg _tle_msg;
            static _msg::_ColorMsg _run_error_msg;
            static _msg::_ColorMsg _checker_return_msg;
            static _msg::_ColorMsg _empty_msg;
            static _msg::_ColorMsg _success_msg;
            static _msg::_ColorMsg _fail_msg;
            static _msg::_ColorMsg _error_msg;
        protected:
            _msg::_ColorMsg __state_msg(_enum::_JudgeState state, bool consider_tle) {
                if (_enum::__is_run_error(state)) return _run_error_msg;
                if (consider_tle && _enum::__has_tle(state)) return _tle_msg;
                else if (_enum::__has_ac(state)) return _ac_msg;
                else if (_enum::__has_wa(state)) return _wa_msg;
                else return _empty_msg;
            }

            void __state_msg(_msg::OutStream &out, _enum::_JudgeState state) {
                out.print(__state_msg(state, true));
                if (_enum::__is_combine_state(state)) {
                    out.print("(");
                    out.print(__state_msg(state, false));
                    out.print(")");
                }
            }

            std::string __ratio_msg(int part, int total, std::string end = "") {
                return tools::string_format("%d / %d%s", part, total, end.c_str());
            }

            void __pass_ratio_msg(_msg::OutStream&out, int passed, int total) {
                out.print( _success_msg, " : ", __ratio_msg(passed, total, ", "));
                out.print(_fail_msg, " : ", __ratio_msg(total - passed, total));
                out.println();
            }

            void __show_files(_msg::OutStream& out, std::vector<Path>& files, int indent = 2) {
                for (auto& file : files) {
                    out.println(tools::string_format("%*s%s", indent, "", file.cname()));
                }
            }

            void __all_pass(_msg::OutStream& out) {
                out.println(_msg::_ColorMsg("All Success", _enum::Color::Green));
            }

            void __meets_error(_msg::OutStream& out) {
                out.print("Meets ", _error_msg, " in :");
            }

            void __meets_error_endl(_msg::OutStream& out) {
                __meets_error(out);
                _msg::__endl(out);
            }

            void __meets_error_files(_msg::OutStream& out, std::vector<Path>& files) {
                __meets_error_endl(out);
                __show_files(out, files);
            }

            void __meets_error_files(_msg::OutStream& out, std::vector<int>& files, int total) {
                __pass_ratio_msg(out, total - files.size(), total);
                std::string file = join(files, ", ");
                __meets_error(out);
                out.println(tools::string_format(" {%s}", file.c_str()));
            }

            void __run_time_msg(_msg::OutStream& out, int time_used) {
                out.println(tools::string_format("Runtime = %dms", time_used));
            }

        };

        _msg::_ColorMsg _Reporter::_ac_msg = _msg::_ColorMsg("AC", _enum::Color::Green);
        _msg::_ColorMsg _Reporter::_wa_msg = _msg::_ColorMsg("WA", _enum::Color::Red);
        _msg::_ColorMsg _Reporter::_tle_msg = _msg::_ColorMsg("TLE", _enum::Color::Yellow);
        _msg::_ColorMsg _Reporter::_run_error_msg = _msg::_ColorMsg("RE", _enum::Color::Red);
        _msg::_ColorMsg _Reporter::_checker_return_msg = _msg::_ColorMsg("checker return :", _enum::Color::Red);
        _msg::_ColorMsg _Reporter::_empty_msg = _msg::_ColorMsg("", _enum::Color::Default);
        _msg::_ColorMsg _Reporter::_success_msg = _msg::_ColorMsg("Success", _enum::Color::Green);
        _msg::_ColorMsg _Reporter::_fail_msg = _msg::_ColorMsg("Fail", _enum::Color::Red);
        _msg::_ColorMsg _Reporter::_error_msg = _msg::_ColorMsg("ERROR", _enum::Color::Red);

        class _Table {
        protected:
            using Msg = _msg::_ColorMsg;
            using Cell = std::vector<Msg>;
            using Row = std::vector<Cell>;
            _msg::OutStream& _out;
            std::vector<Row> _rows;
            int _column_count;
        public:
            _Table(_msg::OutStream& out) : _out(out), _column_count(0) {}

            void new_row() {
                _rows.emplace_back();
                _rows.back().resize(_column_count);
            }

            template<typename T>
            void add_titles(const std::vector<T>& titles) {
                for (auto& title : titles) {
                    new_row();
                    add_cell(_rows.size() - 1, 0, Cell({Msg(title)}));
                }
            }
            
            template<typename T>
            void add_titles(std::initializer_list<T> titles) {
                add_titles(std::vector<T>(titles));
            }

            void add_cell(int row, int col, Cell cell) {
                if (_rows.size() <= row) _rows.resize(row + 1);
                if (_rows[row].size() <= col) {
                    _rows[row].resize(col + 1);
                    _column_count = std::max(_column_count, col + 1);
                }
                _rows[row][col] = cell;
            }

            template<typename T>
            void add_cell(int row, int col, T&& cell) {
                add_cell(row, col, Cell({Msg(std::forward<T>(cell))}));
            }

            void push_cell(Cell cell) {
                if (_rows.empty()) new_row();
                add_cell(_rows.size() - 1, _rows.back().size(), cell);
            }

            void add_msg(int row, int col, Msg msg) {
                if (_rows.size() <= row) _rows.resize(row + 1);
                if (_rows[row].size() <= col) {
                    _rows[row].resize(col + 1);
                    _column_count = std::max(_column_count, col + 1);
                }
                _rows[row][col].push_back(msg);
            }

            void add_msg(int row, int col, const std::string& msg) {
                add_msg(row, col, Msg(msg));
            }

            void add_msg(int row, int col, const char* msg) {
                add_msg(row, col, Msg(msg));
            }

            template<typename T>
            void push_msg(T&& msg) {
                add_msg(_rows.size() - 1, _rows.back().size(), std::forward<T>(msg));
            }

            int cell_size(Cell& cell) {
                int size = 0;
                for (auto& msg : cell) size += msg.size();
                return size;
            }

            int row_size(Row& row) {
                int size = 0;
                for (auto& cell : row) size = std::max(size, cell_size(cell));
                return size;
            }

            void draw() {
                std::vector<int> lens;
                for (auto& row : _rows) {
                    row.resize(_column_count);
                    lens.push_back(row_size(row));
                }
                for (int i = 0; i < _column_count * 2 + 1; i++) {
                    if (i % 2 == 0) {
                        _out.print("+");
                        for (auto& len : lens) {
                            for (int j = 0; j < len; j++) _out.print("-");
                            _out.print("+");
                        }
                    } else {
                        _out.print("|");              
                        for (int j = 0; j < _rows.size(); j++) {
                            Cell& cell = _rows[j][i / 2];
                            int size = cell_size(cell);
                            for(auto&msg : cell) _out.print(msg);
                            _out.print(tools::string_format("%*s", lens[j] - size, ""));
                            _out.print("|");
                        }
                    }
                    _out.println();
                }
            }
        };

    } // namespace io
} // namespace generator

#endif // !_SGPCET_REPORTER_H_
#ifndef _SGPCET_CONVEX_HULL_H_
#define _SGPCET_CONVEX_HULL_H_

#ifndef _SGPCET_POINTS_H_
#include "points.h"
#endif //!_SGPCET_POINTS_H_
#ifndef _SGPCET_GEOMETRY_ALGORITHM_H_
#include "geometry_algorithm.h"
#endif //!_SGPCET_GEOMETRY_ALGORITHM_H_

namespace generator {
    namespace rand_geometry {
    
        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class ConvexHull;

        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class ConvexHullGen : public BasicPolygonGen<ConvexHull, T> {
        public:
            using Context = ConvexHull<T>;
            using Super = BasicPolygonGen<ConvexHull, T>;
            ConvexHullGen(Context& points) : BasicPolygonGen<ConvexHull, T>(points) {}
        protected:
            virtual void __judge_self_limit() override {
                Super::__judge_self_limit();
                __judge_max_try();
            }

            void __judge_max_try() {
                _CONTEXT_GET(max_try);
                if (max_try <= 0) {
                    _msg::__fail_msg(_msg::_defl,
                        tools::string_format("max_try should be greater than 0, but found %d.", max_try));
                }
            }

            void __rand_pool_to_vector(std::vector<T>& pool, std::vector<T>& vec) {
                _CONTEXT_GET(node_count);
                std::sort(pool.begin(), pool.end());
                T min = pool.front();
                T max = pool.back();
                T lower = min;
                T upper = min;
                for (int i = 1; i < node_count - 1; i++) {
                    T val = pool[i];
                    if (rand_numeric::rand_bool()) {
                        vec.emplace_back(val - lower);
                        lower = val;
                    }
                    else {
                        vec.emplace_back(upper - val);
                        upper = val;
                    }
                }
                vec.emplace_back(max - lower);
                vec.emplace_back(upper - max);
            }

            virtual void __generate_geometry() override {
                _CONTEXT_GET(max_try)
                int try_time = 0;
                bool success = false;
                while(try_time < max_try) {
                    try_time++;
                    success = __try_generate_once();
                    if (success) break;
                }
                if (!success) {
                    _msg::__fail_msg(_msg::_defl,
                        tools::string_format("Tried %d times, found no convex hull satisfied the condition.", max_try));
                }
            }

            bool __try_generate_once() {
                _CONTEXT_GET(node_count)
                std::vector<T> x_pool;
                std::vector<T> y_pool;
                for (int i = 0; i < node_count; i++) {
                    x_pool.emplace_back(this->__rand_x());
                    y_pool.emplace_back(this->__rand_y());
                }
                std::vector<T> x_vec;
                std::vector<T> y_vec;
                __rand_pool_to_vector(x_pool, x_vec);
                __rand_pool_to_vector(y_pool, y_vec);
                if (__zero_count_overflow(x_vec, y_vec)) return false;
                std::vector<Point<T>> vec = __rand_no_origin_points(x_vec, y_vec);
                __polar_angle_sort(vec);
                T min_x = std::numeric_limits<T>::max();
                T max_x = std::numeric_limits<T>::min();
                T min_y = std::numeric_limits<T>::max();
                T max_y = std::numeric_limits<T>::min();
                std::vector<Point<T>> hull;
                Point<T> o;
                for (auto& v : vec) {
                    o += v;
                    hull.emplace_back(o);
                    min_x = std::min(min_x, o.x());
                    max_x = std::max(max_x, o.x());
                    min_y = std::min(min_y, o.y());
                    max_y = std::max(max_y, o.y());
                }
                Point<T> move = __rand_move_point(min_x, max_x, min_y, max_y);
                _CONTEXT_GET_REF(points)
                for (auto &v : hull) {
                    points.emplace_back(v + move);
                }
                return true;
            }

            bool __zero_count_overflow(std::vector<T>& x_vec, std::vector<T>& y_vec) {
                _CONTEXT_GET(node_count)
                int count = 0;
                for (auto p : x_vec) count += (p == 0);
                for (auto p : y_vec) count += (p == 0);
                return count > node_count;
            }

            int __find_none_zero_index(std::vector<T>& vec) {
                for (int i = 0; i < vec.size(); i++) {
                    if (vec[i] != 0) return i;
                }
                return vec.size();
            }

            std::vector<Point<T>> __rand_no_origin_points(std::vector<T>& x_vec, std::vector<T>& y_vec) {
                std::vector<Point<T>> points;
                auto __sort_zero = [](T a, T b) {
                    return a == 0 && b != 0;
                };
                std::sort(x_vec.begin(), x_vec.end(), __sort_zero);
                std::sort(y_vec.begin(), y_vec.end(), __sort_zero);
                int p_x = __find_none_zero_index(x_vec);
                int p_y = __find_none_zero_index(y_vec);
                shuffle(x_vec.begin() + p_x, x_vec.end());
                shuffle(y_vec.begin() + p_y, y_vec.end());
                std::reverse(y_vec.begin(), y_vec.end());
                for (int i = 0; i < x_vec.size(); i++) {
                    points.emplace_back(x_vec[i], y_vec[i]);
                }
                return points;
            }
            
            Point<T> __rand_move_point(T min_x, T max_x, T min_y, T max_y) {
               _CONTEXT_GET(x_left_limit)
               _CONTEXT_GET(x_right_limit)
               _CONTEXT_GET(y_left_limit)
               _CONTEXT_GET(y_right_limit)
               T x_min_move = x_left_limit - min_x;
               T x_max_move = x_right_limit - max_x;
               T y_min_move = y_left_limit - min_y;
               T y_max_move = y_right_limit - max_y;
               return rand_point(x_min_move, x_max_move, y_min_move, y_max_move);
            }

        };

        template <typename T, typename>
        class ConvexHull : public RandomPoints<T> {
        protected:
            int _max_try; 
        public:
            using _Self = ConvexHull<T>;
            _OUTPUT_FUNCTION(_Self)
        public:
            ConvexHull(int node_count = 1, T x_left_limit = 0, T x_right_limit = 0, T y_left_limit = 0, T y_right_limit = 0) :
                RandomPoints<T>(node_count, x_left_limit, x_right_limit, y_left_limit, y_right_limit), _max_try(10)
            {
                _GEOMETRY_DEFAULT
            }

            _DISABLE_SAME_POINT
            _SET_GET_VALUE(int, max_try)

            _OUTPUT_FUNCTION_SETTING(_Self)
        protected:
            _DEFAULT_GEOMETRY_GEN_FUNC(ConvexHull)
        };
    } // namespace rand_geometry
} // namespace generator

#endif //!_SGPCET_CONVEX_HULL_H_
#ifndef _SGPCET_ALL_TREE_GRAPH_H_
#define _SGPCET_ALL_TREE_GRAPH_H_

#ifndef _SGPCET_TREE_H_
#include "tree.h"
#endif // !_SGPCET_TREE_H_
#ifndef _SGPCET_CHAIN_H_
#include "chain.h"
#endif // !_SGPCET_CHAIN_H_
#ifndef _SGPCET_FLOWER_H_
#include "flower.h"
#endif // !_SGPCET_FLOWER_H_
#ifndef _SGPCET_HEIGHT_TREE_H_
#include "height_tree.h"
#endif // !_SGPCET_HEIGHT_TREE_H_
#ifndef _SGPCET_MAX_DEGREE_TREE_H_
#include "max_degree_tree.h"
#endif // !_SGPCET_MAX_DEGREE_TREE_H_
#ifndef _SGPCET_MAX_SON_TREE_H_
#include "max_son_tree.h"
#endif // !_SGPCET_MAX_SON_TREE_H_
#ifndef _SGPCET_GRAPH_H_
#include "graph.h"
#endif // !_SGPCET_GRAPH_H_
#ifndef _SGPCET_BIPARTITE_GRAPH_H_
#include "bipartite_graph.h"
#endif // !_SGPCET_BIPARTITE_GRAPH_H_
#ifndef _SGPCET_DAG_H_
#include "dag.h"
#endif // !_SGPCET_DAG_H_
#ifndef _SGPCET_CYCLE_GRAPH_H_
#include "cycle_graph.h"
#endif // !_SGPCET_CYCLE_GRAPH_H_
#ifndef _SGPCET_WHEEL_GRAPH_H_
#include "wheel_graph.h"
#endif // !_SGPCET_WHEEL_GRAPH_H_
#ifndef _SGPCET_GRID_GRAPH_H_
#include "grid_graph.h"
#endif // !_SGPCET_GRID_GRAPH_H_
#ifndef _SGPCET_PSEUDO_TREE_H_
#include "pseudo_tree.h"
#endif // !_SGPCET_PSEUDO_TREE_H_
#ifndef _SGPCET_CACTUS_H_
#include "cactus.h"
#endif // !_SGPCET_CACTUS_H_
#ifndef _SGPCET_LINK_H_
#include "link.h"
#endif // !_SGPCET_LINK_H_
#ifndef _SGPCET_FOREST_H_
#include "forest.h"
#endif // !_SGPCET_FOREST_H_
#ifndef _SGPCET_FLOWER_CHAIN_H_
#include "flower_chain.h"
#endif // !_SGPCET_FLOWER_CHAIN_H_
#ifndef _SGPCET_DEGREE_TREE_H_
#include "degree_tree.h"
#endif //!_SGPCET_DEGREE_TREE_H_
#ifndef _SGPCET_SON_TREE_H_
#include "son_tree.h"
#endif //!_SGPCET_SON_TREE_H_
#ifndef _SGPCET_START_REACHABLE_GRAPH_H_
#include "start_reachable_graph.h"
#endif //!_SGPCET_START_REACHABLE_GRAPH_H_

#endif // !_SGPCET_ALL_TREE_GRAPH_H_
#ifndef _SGPCET_CHAR_SET_CHECK_H_
#define _SGPCET_CHAR_SET_CHECK_H_

#ifndef _SGPCET_SETTING_H_
#include "basic/setting.h"
#endif //!_SGPCET_SETTING_H_
#ifndef _SGPCET_COLOR_H_
#include "log/color.h"
#endif //!_SGPCET_COLOR_H_
#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif //!_SCPCET_LOGGER_H_
#ifndef _SGPCET_TOOLS_H_
#include "basic/tools.h"
#endif //!_SGPCET_TOOLS_H_

namespace generator {
    namespace _setting {
        class CharSetCheck {
        private:
            static _msg::_ColorMsg _func;
        public:
            CharSetCheck() = default;
            static void enable_default_write() {
                if (_setting::BigNumberSetting::has_empty_or_same_label()) {
                    _msg::__fail_msg(_msg::_defl, 
                        "Can't use default write when BigNumberSetting has empty or same labels.\n",
                        "Using ", _func, " to see the detail.");
                }
            }
            static void enable_default_read() {
                if (_setting::BigNumberSetting::has_empty_or_same_label() && !_setting::BigNumberSetting::is_single_label()) {
                    _msg::__fail_msg(_msg::_defl, 
                        "Can't use default read when BigNumberSetting has multiply labels, has empty labels or has same labels.\n",
                        "Using ", _func, " to see the detail.");
                }
            }

            static void enable_base(int base) {
                if (base <= 1) {
                    _msg::__fail_msg(_msg::_defl, "base must greater or equal to 2, but found %d.", base);
                }
                int size = _setting::BigNumberSetting::labels().size();
                if (size < base) {
                    _msg::__fail_msg(_msg::_defl, tools::string_format(
                        "BigNumberSetting can only represent numbers in up to base %d, but require is %d.", size, base));
                }
            }

            static void detail() {
                std::map<std::string, std::vector<int>> same;
                std::vector<std::pair<int, std::string>> nsingle;
                std::vector<int> empty;
                bool has_same = false;
                auto& labels = _setting::BigNumberSetting::labels();
                _msg::__info_msg(_msg::_defl, tools::string_format(
                    "The BigNumberSetting can represent numbers in up to base %d.", labels.size()));
                for (int i = 0; i < labels.size(); i++) {
                    auto label = labels[i];
                    if (label.empty()) empty.emplace_back(i);
                    else {
                        if (label.size() >= 2) nsingle.emplace_back(i, label);
                        same[label].emplace_back(i);
                        if (same[label].size() >= 2) has_same = true;
                    }
                }
                if (has_same) {
                    _msg::__endl(_msg::_defl);
                    _msg::__info_msg(_msg::_defl, "There are character(s) in the BigNumberSetting that represent multiple digits:");
                    for (auto& s : same) {
                        if (s.second.size() >= 2) {
                            _msg::__info_msg(_msg::_defl, tools::string_format(
                                "%s : %s", s.first.c_str(), join(s.second.begin(), s.second.end(), ", ").c_str()));
                        }
                    }   
                }
                if (empty.size() >= 1) {
                    _msg::__endl(_msg::_defl);
                    _msg::__info_msg(_msg::_defl, "There are empty string in the BigNumberSetting that represent digits:");
                    _msg::__info_msg(_msg::_defl, join(empty.begin(), empty.end(), ", ") );
                }
                if (nsingle.size() >= 1) {
                    _msg::__endl(_msg::_defl);
                    _msg::__info_msg(_msg::_defl, "There are strings in the BigNumberSetting that are not single characters:"); 
                    for (auto& s : nsingle) {
                        _msg::__info_msg(_msg::_defl, tools::string_format(
                            "%d : %s", s.first, s.second.c_str()));
                    }
                }

            }

        };

        _msg::_ColorMsg CharSetCheck::_func = _msg::_ColorMsg("CharSetCheck::detail()", _enum::Color::Green);
        
    } // namespace _setting
} // namespace generator

#endif //!_SGPCET_CHAR_SET_CHECK_H_
#ifndef _SGPCET_BIG_INT_BASE_H_
#define _SGPCET_BIG_INT_BASE_H_

#ifndef _SGPCET_BIG_INT_CALCULATOR_H_
#include "math/big_int_calculator.h"
#endif //!_SGPCET_BIG_INT_CALCULATOR_H_

namespace generator {
    namespace math {
        class BigIntBase : public BigIntCalculator<BigIntBase> {
        public:
            friend class BigIntCalculator<BigIntBase>;
            const static i32 MAX_BASE = 1 << 15;
        protected:
            i32 _radix;
            i32 _base;
            i32 _digits;
        public:

            BigIntBase() {
                set_radix(10);
                set_value(0);
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            BigIntBase(T val) {
                set_radix(10);
                set_value(val);
            }

            BigIntBase(const BigIntBase& other) : 
                BigIntCalculator<BigIntBase>(other),
                _digits(other._digits), _radix(other._radix), _base(other._base) {}
            
            BigIntBase& operator=(const BigIntBase& other) {
                if (this != &other) {
                    BigIntCalculator<BigIntBase>::operator=(other);
                    _digits = other._digits;
                    _radix = other._radix;
                    _base = other._base; 
                }
                return *this;
            }

            BigIntBase(BigIntBase&& other) noexcept : 
                BigIntCalculator<BigIntBase>(std::move(other)), 
                _digits(other._digits), _radix(other._radix), _base(other._base) {}

            BigIntBase& operator=(BigIntBase&& other) noexcept {
                if (this != &other) {
                    BigIntCalculator<BigIntBase>::operator=(std::move(other));
                    _digits = other._digits;
                    _radix = other._radix;
                    _base = other._base;
                } 
                return *this;
            }

            void set_radix(i32 radix) {
                _radix = radix;
                _base = radix;
                for (_digits = 1; _base * radix <= MAX_BASE; _digits++, _base *= radix);
            }

            i32 digits() const {
                return _digits;
            }
        protected:
            template <typename T1, typename T2, typename T3>
            void __carry(T1& add, T2& basic_val, T3 new_val) {
                add += (T1)new_val;
                basic_val = add % (T1)_base;
                add /= (T1)_base;
            } 

            template <typename T1, typename T2, typename T3>
            void __borrow(T1& add, T2& basic_val, T3 new_val) {
               add += (T1)new_val - (T1)_base + 1;
               basic_val = add % (T1)_base + (T1)_base - 1;
               add /= (T1)_base; 
            }

            i32 __base() const { return _base; }
            i32 __radix() const { return _radix; }
            i32 __digits() const { return _digits; }

            void __copy_status(const BigIntBase& other) {
                _digits = other._digits;
                _radix = other._radix;
                _base = other._base;
            }
        };
    } // namespace math
} // namespace generator

#endif // !_SGPCET_BIG_INT_BASE_H_
#ifndef _SGPCET_HACK_H_
#define _SGPCET_HACK_H_

#ifndef _SGPCET_REPORTER_H_
#include "reporter.h"
#endif // _SGPCET_REPORTER_H_
#ifndef _SGPCET_CHECKER_H_
#include "checker.h"
#endif // _SGPCET_CHECKER_H_

namespace generator {
    namespace io {
        class _Hack : public _Reporter {
        protected:
            using Name = std::string;
            struct _HackSetting {
                int _max_try;
                int _start_index;
                bool _stop_when_wrong;
                bool _should_skip;
                
                _HackSetting(int max_try, int start_index, bool stop_when_wrong)
                    : _max_try(max_try), _start_index(start_index), _stop_when_wrong(stop_when_wrong), _should_skip(false) {}
            };
            struct _Comparer {
                _Program* _program;
                std::vector<_HackSetting> _cases;
                int _last_index;
                std::set<int> _indices;

                _Comparer(_Program* program = nullptr)
                    : _program(program), _last_index(1) {}

                ~_Comparer() {
                    if (_program != nullptr)
                        delete _program;
                }

                _Comparer(const _Comparer& other)
                    : _program(other._program ? other._program->__clone() : nullptr),
                    _cases(other._cases),
                    _last_index(other._last_index),
                    _indices(other._indices) {}
    
                _Comparer& operator=(const _Comparer& other) {
                    if (this != &other) {
                        delete _program;
                        _program = other._program ? other._program->__clone() : nullptr;
                        _cases = other._cases;
                        _last_index = other._last_index;
                        _indices = other._indices;
                    }
                    return *this;
                }
    
                _Comparer(_Comparer&& other) noexcept
                    : _program(other._program),
                    _cases(std::move(other._cases)),
                    _last_index(other._last_index),
                    _indices(std::move(other._indices)) {
                    other._program = nullptr;
                }
    
                _Comparer& operator=(_Comparer&& other) noexcept {
                    if (this != &other) {
                        delete _program;
                        _program = other._program;
                        other._program = nullptr;
                        _cases = std::move(other._cases);
                        _last_index = other._last_index;
                        _indices = std::move(other._indices);
                    }
                    return *this;
                }

                void set_program(_Program* program) {
                    if (_program != nullptr) delete _program;
                    _program = program;
                }

                void add_cases(int max_try, int start_index, bool stop_when_wrong) {
                    _last_index = std::max(_last_index, start_index + max_try);
                    _cases.push_back(_HackSetting(max_try, start_index, stop_when_wrong));
                    for (int i = start_index; i < start_index + max_try; i++)
                        _indices.insert(i);
                }
            };
            std::map<Name, _Comparer> _comparers;
            _Checker _checker;
            _Program* _generator;
            _Program* _std;

            _Program* _validator;
            int _time_limit;
            int _time_limit_for_std;
            int _time_limit_for_generator;
            int _time_limit_for_checker;
            int _time_limit_for_validator;

            bool _copy_wrong_to_testcase;
            bool _delete_correct;

            std::string _sub_folder_name;

            enum class State {
                UNKNOWN,
                SKIP,
                AC,
                WA,
                TLE,
                RE,
                STD_TLE,
                STD_RE,
                GEN_FAIL,
                VAL_FAIL,
                CHECK_FAIL
            };
            using TestResult = std::pair<State, int>;
            using TestCase = std::pair<Name, int>;
            std::map<TestCase, TestResult> _states;
            std::map<int, int> _move_path;
            std::map<int, std::set<Name>> _testcases;

        public:
            _Hack() : _checker(), _generator(nullptr), _std(nullptr), _validator(nullptr),
                _time_limit(_setting::time_limit_inf), _time_limit_for_std(_setting::time_limit_inf),
                _time_limit_for_generator(_setting::time_limit_inf), _time_limit_for_checker(_setting::time_limit_inf),
                _time_limit_for_validator(_setting::time_limit_inf), _copy_wrong_to_testcase(false), _delete_correct(false) {}

            template<typename T1, typename T2, typename T3>
            _Hack(T1&& generator, T2&& std, T3&& checker,
                int time_limit, int time_limit_for_std, bool copy_wrong_to_testcase, bool delete_correct)
                : _checker(std::forward<T3>(checker)), 
                _generator(nullptr), _std(nullptr), _validator(nullptr),
                _time_limit(time_limit),
                _time_limit_for_std(time_limit_for_std),
                _time_limit_for_generator(_setting::time_limit_inf),
                _time_limit_for_checker(_setting::time_limit_inf),
                _time_limit_for_validator(_setting::time_limit_inf),
                _copy_wrong_to_testcase(copy_wrong_to_testcase),
                _delete_correct(delete_correct),
                _sub_folder_name(_setting::_empty_program_name) {
                    __set_generator(std::forward<T1>(generator));
                    __set_std(std::forward<T2>(std));
                }

            ~_Hack() {
                if (_generator != nullptr) delete _generator;
                if (_std != nullptr) delete _std;
            }

            _GET_VALUE(_Checker, checker);
            _GET_VALUE(_Program*, generator);
            _GET_VALUE(_Program*, std);
            _GET_VALUE(_Program*, validator);
            _SET_GET_VALUE(int, time_limit);
            _SET_GET_VALUE(int, time_limit_for_std);
            _SET_GET_VALUE(int, time_limit_for_generator);
            _SET_GET_VALUE(int, time_limit_for_checker);
            _SET_GET_VALUE(int, time_limit_for_validator);
            _SET_GET_VALUE(bool, copy_wrong_to_testcase);
            _SET_GET_VALUE(bool, delete_correct);
            _SET_GET_VALUE(std::string, sub_folder_name);

            template<typename T>
            void __set_checker(T&& checker) {
                _checker.__set_checker(std::forward<T>(checker));
            }

            template<typename T>
            void __set_generator(T&& generator) {
                if (_generator != nullptr) delete _generator;
                _generator = __program(generator);
            }

            template<typename T>
            void __set_std(T&& std) {
                if (_std != nullptr) delete _std;
                _std = __result_program(std);
            }

            template<typename T>
            void __add_comparer(T&& comparer, int max_try, int start_index, bool stop_when_wrong) {
                if (max_try <= 0) _msg::__fail_msg(_msg::_defl, "At least try once.");
                _Program* program = __result_program(comparer);
                Name name = program->name();
                if (_comparers.find(name) == _comparers.end()) _comparers[name] = _Comparer(program);
                else delete program;
                _comparers[name].add_cases(max_try, start_index, stop_when_wrong);
            }

            template<typename T>
            void __add_comparer(T&& comparer, int max_try, bool stop_when_wrong) {
                if (max_try <= 0) _msg::__fail_msg(_msg::_defl, "At least try once.");
                _Program* program = __result_program(comparer);
                Name name = program->name();
                if (_comparers.find(name) == _comparers.end()) _comparers[name] = _Comparer(program);
                else delete program;
                int last_index = _comparers[name]._last_index;
                _comparers[name].add_cases(max_try, last_index, stop_when_wrong);
            }

            template<typename T>
            void __set_validator(T&& validator) {
                if (_validator != nullptr) delete _validator;
                _validator = __result_program(validator);
            }

            Path __case_hack_folder() {
                if (_sub_folder_name == _setting::_empty_program_name) return __hack_folder();
                return __path_join(__hack_folder(), _sub_folder_name);
            }

            State __generate(int index) {
                Path input = __path_join(__case_hack_folder(), __end_with(index, _enum::_IN));
                _Program* gen = __generator_program(_generator, index, true);
                ReturnState result = gen->__run_program(_setting::_default_path, input, _setting::_default_path, _time_limit_for_generator, _enum::_FuncProgramType::_GENERATOR);
                delete gen;
                if (!__is_success(result.exit_code)) return State::GEN_FAIL;
                return State::UNKNOWN;
            }

            State __validate(int index) {
                if (_validator == nullptr) return State::UNKNOWN;
                Path input = __path_join(__case_hack_folder(), __end_with(index, _enum::_IN));
                Path log = __path_join(__case_hack_folder(), __end_with(index, _enum::_VAL));
                ReturnState result = _validator->__run_program(input, _setting::_default_path, log, _time_limit_for_validator, _enum::_FuncProgramType::_VALIDATOR);
                if (!__is_success(result.exit_code)) return State::VAL_FAIL;
                return State::UNKNOWN;
            }

            State __run_std(int index) {
                Path input = __path_join(__case_hack_folder(), __end_with(index, _enum::_IN));
                Path output = __path_join(__case_hack_folder(), __end_with(index, _enum::_OUT));
                ReturnState result = _std->__run_program(input, output, _setting::_default_path, _time_limit_for_std, _enum::_FuncProgramType::_RESULT);
                if (!__is_success(result.exit_code)) return State::STD_RE;
                if (__time_limit_exceed(result.time, _time_limit)) return State::STD_TLE;
                return State::UNKNOWN;
            }
            
            void __prepare_comparers() {
                _states.clear();
                _testcases.clear();
                for (auto& comparer : _comparers) {
                    Name name = comparer.first;
                    for (auto& index : comparer.second._indices) {
                        {
                            _states[TestCase(name, index)] = TestResult(State::UNKNOWN, 0);
                            _testcases[index].insert(name);
                        }
                    }
                }
            }

            bool __should_skip(const _HackSetting& setting, int index) {
                if (setting._should_skip) return true;
                if (index < setting._start_index || index >= setting._start_index + setting._max_try) return true;
                return false;
            }

            bool __should_skip(const _Comparer& comparer, int index) {
                bool skip = true;
                for (auto& setting : comparer._cases) {
                    skip &= __should_skip(setting, index);
                }
                return skip;
            }
            
            bool __should_skip(const Name& name, int index) {
                return __should_skip(_comparers[name], index);
            }

            bool __should_skip(int index) {
                bool skip = true;
                for (auto& name : _testcases[index]) {
                    skip &= __should_skip(_comparers[name], index);
                }
                return skip;
            }

            void __stop_hack(const Name& name, int index) {
                for (auto& testcase : _comparers[name]._cases) {
                    if (!testcase._stop_when_wrong) continue; 
                    if (index < testcase._start_index || index >= testcase._start_index + testcase._max_try) continue;
                    testcase._should_skip = true;
                    auto& state = _states[TestCase(name, index)];
                }
            }

            TestResult __run_user(const Name& name, int index) {
                Path input = __path_join(__case_hack_folder(), __end_with(index, _enum::_IN));
                Path user = __path_join(__case_hack_folder(), name, __end_with(index, _enum::_ANS));
                ReturnState result = _comparers[name]._program->__run_program(input, user, _setting::_default_path, _time_limit, _enum::_FuncProgramType::_RESULT);
                if (!__is_success(result.exit_code)) return {State::RE, 0};
                if (__time_limit_exceed(result.time, _time_limit)) return {State::TLE, result.time};
                return {State::UNKNOWN, result.time};
            }

            State __check(const Name& name, int index) {
                Path input = __path_join(__case_hack_folder(), __end_with(index, _enum::_IN));
                Path output = __path_join(__case_hack_folder(), __end_with(index, _enum::_OUT));
                Path user = __path_join(__case_hack_folder(), name, __end_with(index, _enum::_ANS));
                Path check_log = __path_join(__case_hack_folder(), name, __end_with(index, _enum::_CHECK_RESULT));
                _checker.__change_case(input, output, user, check_log);
                _checker.__check_result();
                _enum::_JudgeState result = _checker.result();
                if (result == _enum::_JudgeState::_AC) return State::AC;
                if (result == _enum::_JudgeState::_WA) return State::WA;
                return State::CHECK_FAIL;
            }

            bool __is_user_correct(State& state) {
                return state == State::AC;
            }

            bool __is_skip(State& state) {
                return state == State::SKIP;
            }

            bool __is_user_uncorrect(State& state) {
                return state == State::WA ||
                    state == State::RE ||
                    state == State::TLE;
            }

            bool __is_program_error(State& state) {
                return state != State::AC &&
                    state != State::UNKNOWN &&
                    !__is_user_uncorrect(state);
            }

            bool __has_runtime(State& state) {
                return state == State::AC ||
                    state == State::WA ||
                    state == State::TLE;
            }

            int __find_next_not_exist_inputs(int start) {
                for (int i = start; ; i++) {
                    if (i > _setting::test_case_limit) return -1;
                    if (!__testcase_input_file_exists(i)) return i;
                }
            }

            void __copy_uncorrect_cases() {
                if (!_copy_wrong_to_testcase) return;
                __create_directories(__testcases_folder());
                _move_path.clear();
                int next_input = 1;
                for (auto& testcase : _testcases) {
                    int index = testcase.first;
                    bool should_copy = false;
                    for (auto& name : testcase.second) {
                        should_copy |= __is_user_uncorrect(_states[TestCase(name, index)].first);
                        if (should_copy) break;
                    }
                    if (!should_copy) continue;
                    Path input = __path_join(__case_hack_folder(), __end_with(index, _enum::_IN));
                    Path output = __path_join(__case_hack_folder(), __end_with(index, _enum::_OUT));
                    next_input = __find_next_not_exist_inputs(next_input);
                    if (next_input == -1) {
                        _msg::__warn_msg(_msg::_defl, tools::string_format("Testcases are over the test_case_limit(%d).", _setting::test_case_limit));
                        break;
                    }
                    _move_path[index] = next_input;
                    Path testcase_input = __testcase_input_file_path(next_input);
                    Path testcase_output = __testcase_output_file_path(next_input);
                    __copy_file(input, testcase_input);
                    __copy_file(output, testcase_output);
                }
            }

            void __delete_files(int index) {
                if (!_delete_correct) return ;
                bool all_correct = true;
                for (auto& name : _testcases[index]) {
                    State& state = _states[TestCase(name, index)].first;
                    if (__is_user_correct(state)) {
                        Path user = __path_join(__case_hack_folder(), name, __end_with(index, _enum::_ANS));
                        Path check_log = __path_join(__case_hack_folder(), name, __end_with(index, _enum::_CHECK_RESULT));
                        user.__delete_file();
                        check_log.__delete_file(); 
                    } else {
                        all_correct = false;
                    }
                }
                if (!all_correct) return;
                Path input = __path_join(__case_hack_folder(), __end_with(index, _enum::_IN));
                Path output = __path_join(__case_hack_folder(), __end_with(index, _enum::_OUT));
                Path val_log = __path_join(__case_hack_folder(), __end_with(index, _enum::_VAL));
                input.__delete_file();
                output.__delete_file();
                val_log.__delete_file();
            }

            void __hack() {
                __prepare_comparers();
                if (_testcases.empty()) return;
                _checker.set_time_limit(_time_limit_for_checker);
                __create_directories(__case_hack_folder());
                int count = 1;
                int sum = _testcases.size();
                for (auto it = _testcases.begin(); it != _testcases.end();) {
                    int index = it->first;
                    if (__should_skip(index)) {
                        for (auto& name : _testcases[index]) {
                            auto& state = _states[TestCase(name, index)].first;
                            if (state == State::UNKNOWN) state = State::SKIP;
                        }
                        it = _testcases.erase(it);
                        continue;
                    }
                    _msg::__flash_msg(_msg::_defl, "Hack : ", __ratio_msg(count, sum));
                    count++;
                    State state = State::UNKNOWN;
                    state = __generate(index);
                    if (state == State::UNKNOWN) state = __validate(index);
                    if (state == State::UNKNOWN) state = __run_std(index);
                    for (auto& name : it->second) {
                        __create_directories(__path_join(__case_hack_folder(), name));
                        TestCase testcase(name, index);
                        if (_states.find(testcase) == _states.end()) continue;
                        if (__should_skip(name, index)) {
                            _states[testcase].first = State::SKIP;
                            continue;
                        }
                        if (state != State::UNKNOWN) {
                            _states[testcase].first = state;
                            continue;
                        }
                        auto& result = _states[testcase];
                        result = __run_user(name, index);
                        if (result.first == State::UNKNOWN) result.first = __check(name, index);
                        if (__is_user_uncorrect(result.first)) __stop_hack(name, index);     
                    }
                    __delete_files(index);
                    it++;
                }
                __copy_uncorrect_cases();
                _msg::__endl(_msg::_defl);
            }

            void __short_summary(_msg::OutStream& out) {
                for (auto& comparer : _comparers) {
                    Name name = comparer.first;
                    int fail = 0;
                    int program_error = 0;
                    int sum = 0;
                    for (auto& index : comparer.second._indices) {
                        State& state = _states[TestCase(name, index)].first;
                        if (__is_skip(state)) continue;
                        if (__is_user_uncorrect(state)) fail++;
                        else if (__is_program_error(state)) program_error++;
                        sum++;
                    }
                    out.print(tools::string_format("Hack %s : ", name.c_str()));
                    if (fail == 0 && program_error == 0) __all_pass(out);
                    else {
                        out.print(_fail_msg, " : ", __ratio_msg(fail, sum, ", "));
                        out.println(_error_msg, " : ", __ratio_msg(program_error, sum));         
                    }
                }
                if (_move_path.size() > 0) {
                    out.println("Move case : ");
                    std::vector<int> from, to;
                    for (auto& move : _move_path) {
                        from.push_back(move.first);
                        to.push_back(move.second);
                    }
                    std::string from_str = join(from, ", ");
                    std::string to_str = join(to, ", ");
                    out.println(tools::string_format("  {%s} -> {%s}", from_str.c_str(), to_str.c_str()));
                }
            }

            _msg::_ColorMsg __state_msg(State state) {
                switch (state) {
                    case State::SKIP: return _msg::_ColorMsg("Skip", _enum::Color::Default);
                    case State::AC: return _ac_msg;
                    case State::WA: return _wa_msg;
                    case State::RE: return _run_error_msg;
                    case State::TLE: return _tle_msg;
                    case State::STD_TLE: return _msg::_ColorMsg("std TLE", _enum::Color::Yellow);
                    case State::STD_RE: return _msg::_ColorMsg("std RE", _enum::Color::Red);
                    case State::GEN_FAIL: return _msg::_ColorMsg("generate ERROR", _enum::Color::Red);
                    case State::VAL_FAIL: return _msg::_ColorMsg("validate ERROR", _enum::Color::Red);
                    case State::CHECK_FAIL: return _msg::_ColorMsg("check ERROR", _enum::Color::Red);
                    default: return _msg::_ColorMsg("UNKNOWN", _enum::Color::Red);
                }
            }

            void __detail_summary(_msg::OutStream& out) {
                _Table table(out);
                _msg::__info_msg(out, tools::string_format("Generator Name : %s", _generator->name().c_str()));
                table.add_cell(0, 0, "Hack Case Id");
                table.add_cell(1, 0, "Seed");
                std::map<Name, int> table_indices;
                int row = 2;
                for (auto& comparer : _comparers) {
                    Name name = comparer.first;
                    table.add_cell(row, 0, name);
                    table_indices[name] = row;
                    row++;
                }
                if (_move_path.size() > 0) table.add_cell(row, 0, "Move Path");
                int case_count = 1;
                for (auto& testcase : _testcases) {
                    int index = testcase.first;
                    table.add_cell(0, case_count, std::to_string(index));
                    _Program* gen = __generator_program(_generator, index, true);
                    table.add_cell(1, case_count, gen->get_argv_without_redirection());
                    delete gen;
                    for(auto& program : _comparers) {
                        Name name = program.first;
                        int table_index = table_indices[name];
                        TestCase case_index(name, index);
                        if (_states.find(case_index) == _states.end()) {
                            table.add_cell(table_index, case_count, "N/A");
                            continue;
                        }
                        TestResult result = _states[case_index];
                        table.add_cell(table_index, case_count, __state_msg(result.first));
                        if (__has_runtime(result.first)) table.add_msg(table_index, case_count, tools::string_format(" %dms", result.second));
                    }
                    if (_move_path.size() > 0) {
                        if (_move_path.find(index) != _move_path.end())
                            table.add_cell(row, case_count, __testcase_input_file_path(_move_path[index]).path());
                    }
                    case_count++;
                }
                table.draw();
            }

            bool __empty() {
                return _comparers.empty();
            }
             int __size() {
                return _comparers.size();
            }
        };

        template<typename T1, typename T2, typename T3, typename T4>
        typename std::enable_if<
            IsProgramConstructible<T1>::value &&
            IsProgramConstructible<T2>::value &&
            IsProgramConstructible<T3>::value &&
            IsCheckerConstructible<T4>::value
        >::type
        hack(T1&& generator_program, T2&& std_program, 
            T3&& compare_program, T4&& checker_program, 
            int time_limit, bool limit_std_runtime = false,
            int max_try = 100, bool stop_when_wrong = true, 
            bool copy_wrong_to_testcase = true, bool delete_correct = true) {
                _Hack hack(
                    std::forward<T1>(generator_program), 
                    std::forward<T2>(std_program), 
                    std::forward<T4>(checker_program), 
                    time_limit, 
                    limit_std_runtime ? time_limit : _setting::time_limit_inf,
                    copy_wrong_to_testcase, delete_correct);
                hack.__add_comparer(std::forward<T3>(compare_program), max_try, stop_when_wrong);
                hack.__hack();
                hack.__detail_summary(_msg::_defl);
            }
    } // namespace io
} // namespace generator

#endif // _SGPCET_HACK_H_
#ifndef _SGPCET_COMPARE_H_
#define _SGPCET_COMPARE_H_

#ifndef _SGPCET_REPORTER_H_
#include "reporter.h"
#endif // _SGPCET_REPORTER_H_
#ifndef _SGPCET_CHECKER_H_
#include "checker.h"
#endif // _SGPCET_CHECKER_H_

namespace generator {
    namespace io {
        class _Compare : public _Reporter {
        protected:
            using Name = std::string;
            using TestCase = std::pair<Name, int>;
            using TestResult = std::pair<_enum::_JudgeState, int>;
            _Checker _checker;
            int _time_limit;
            int _time_limit_for_checker;
            std::map<Name, _Program*> _name;
            std::map<Name, std::set<int>> _testcases;
            std::map<TestCase, TestResult> _results;
        public:
            _Compare() : _checker(), _time_limit(_setting::time_limit_inf), _time_limit_for_checker(_setting::time_limit_inf) {}    

            template<typename T>
            _Compare(T&& checker, int time_limit) : _checker(std::forward<T>(checker)), _time_limit(time_limit), _time_limit_for_checker(_setting::time_limit_inf) {}

            template<typename T>
            void __set_checker(T&& checker) {
                _checker.__set_checker(std::forward<T>(checker));
            }

            _SET_GET_VALUE(int, time_limit)
            _SET_GET_VALUE(int, time_limit_for_checker)

            ~_Compare() {
                for (auto& name : _name) {
                    if (name.second != nullptr) delete name.second;
                }
            }

            template<typename T>
            void __add_testcase(T&& program, const std::vector<int>& cases) {
                _Program* p = __program(std::forward<T>(program));
                std::string name = p->name();
                if (_name.find(name) == _name.end()) _name[name] = p;
                else delete p;
                for (auto& case_id : cases) {
                    if (__testcase_input_file_exists(case_id) && __testcase_output_file_exists(case_id))
                        _testcases[name].insert(case_id);
                }
            }

            template<typename T>
            void __add_testcase(T&& program, int start, int end) {
                std::vector<int> cases;
                for (int i = start; i <= end; i++) cases.push_back(i);
                __add_testcase(std::forward<T>(program), cases);
            }

            template<typename T>
            void __add_testcase(T&& program) {
                __add_testcase(std::forward<T>(program), __get_all_inputs());
            }

            bool __enable_judge_ans(int runtime, int time_limit, _enum::_JudgeState& result) {
                if (!__time_limit_exceed(runtime, time_limit)) return true;
                result = _enum::_JudgeState::_TLE;
                return runtime <= time_limit * _setting::time_limit_check_ratio;
            }

            void __run_case(Name name) {
                Path ans_folder = __path_join(__compare_folder(), name);
                __create_directories(ans_folder);
                int count = 1;
                int sum = _testcases[name].size();
                _Program* p = _name[name];
                if (!p->__check_program_valid())  return;
                for (auto& case_id : _testcases[name]) {
                    TestCase test_case(name, case_id);
                    TestResult& result = _results[test_case];
                    _msg::__flash_msg(_msg::_defl, tools::string_format("Compare program %s : ", name.c_str()), __ratio_msg(count, sum));
                    count++;
                    Path input = __testcase_input_file_path(case_id);
                    Path output = __testcase_output_file_path(case_id);
                    Path answer = __path_join(ans_folder, __end_with(case_id, _enum::_ANS));
                    Path check_result = __path_join(ans_folder, __end_with(case_id, _enum::_CHECK_RESULT));
                    auto res = p->__run_program(input, answer, _setting::_default_path, __time_limit_extend(_time_limit), _enum::_FuncProgramType::_RESULT);
                    
                    if (!__is_success(res.exit_code)) {
                        result.first = _enum::_JudgeState::_ERROR;
                        continue;
                    }
                    result.second = res.time;
                    if (__enable_judge_ans(res.time, _time_limit, result.first)) {
                        _checker.__change_case(input, output, answer, check_result);
                        _checker.__check_result();
                        _enum::_JudgeState check_result = _checker.result();
                        if (_enum::__is_run_error(check_result)) result.first = check_result;
                        else result.first |= check_result;
                    }
                }
                _msg::__endl(_msg::_defl);
            }

            void __compare() {
                if (_testcases.empty()) return;
                _checker.set_time_limit(_time_limit_for_checker);
                _results.clear();
                for (auto& name : _name) {
                    for (auto& case_id : _testcases[name.first]) 
                        _results[{name.first, case_id}] = {_enum::_JudgeState::_UNKNOWN, 0};
                    __run_case(name.first);
                }
            }

            int __get_total_success(Name name) {
                int total = 0;
                for (auto& case_id : _testcases[name]) {
                    TestCase test_case(name, case_id);
                    auto result = _results[test_case].first;
                    if (_enum::__is_consider_state(result)) total++;
                }
                return total;
            }

            TestResult __get_test_result(Name name) {
                TestResult total = {_enum::_JudgeState::_UNKNOWN, 0};
                for (auto& case_id : _testcases[name]) {
                    TestCase test_case(name, case_id);
                    auto result = _results[test_case].first;
                    auto time = _results[test_case].second;
                    if (_judge_result_priority[__state_index(result)] > _judge_result_priority[__state_index(total.first)]) 
                        total.first = result;
                    if (_enum::__is_consider_state(result)) 
                        total.second = std::max(total.second, time);
                    
                }
                return total;
            }

            void __push_state(_Table& table, int row, int col, _enum::_JudgeState state) {
                table.add_msg(row, col, __state_msg(state, true));
                if (_enum::__is_combine_state(state)) {
                    table.add_msg(row, col, "(");
                    table.add_msg(row, col, __state_msg(state, false));
                    table.add_msg(row, col, ")");
                }
            }

            void __push_time(_Table& table, int row, int col, TestResult result, std::string space = "") {
                if (_enum::__is_consider_state(result.first)) {
                    table.add_msg(row, col, space);
                    table.add_msg(row, col, tools::string_format("%dms", result.second));
                }   
            }

            void __short_summary(_msg::OutStream& out) {
                _Table table(out);
                table.add_titles({"Program Name", "Run Success", "State", "RunTime"});
                int count = 1;
                for (auto& testcase : _name) {
                    Name name = testcase.first;
                    TestResult result = __get_test_result(name);
                    int success = __get_total_success(name);
                    int sum = _testcases[name].size();
                    table.add_cell(0, count, name);
                    table.add_cell(1, count, __ratio_msg(success, sum));
                    __push_state(table, 2, count, result.first);
                    __push_time(table, 3, count, result);
                    count++;
                }
                table.draw();
            }

            void __detail_summary(_msg::OutStream& out) {
                _Table table(out);
                table.add_cell(0, 0, "Case \\ Name");
                std::set<int> all_case_ids;
                for (auto& testcase : _name) {
                    for (auto& case_id : _testcases[testcase.first]) {
                        all_case_ids.insert(case_id);
                    }
                }
                int column = 1;
                for (auto& case_id : all_case_ids) {
                    table.add_cell(0, column, std::to_string(case_id));
                    column++;
                }
                table.add_cell(0, column, "Total");
                int row = 1;
                for (auto& testcase : _name) {
                    Name name = testcase.first;
                    TestResult total_result = __get_test_result(name);
                    table.add_cell(row, 0, name);
                    int len = 1;
                    for (auto& case_id : all_case_ids) {
                        TestCase test_case(name, case_id);
                        if (_results.find(test_case) == _results.end()) {
                            table.add_cell(row, len, "N/A");
                        } else {
                            TestResult result = _results[test_case];
                            __push_state(table, row, len, result.first);
                            __push_time(table, row, len, result, " ");
                        }
                        len++;
                    }
                    __push_state(table, row, len, total_result.first);
                    __push_time(table, row, len, total_result, " ");
                    row++;
                }
                table.draw();
            }

            bool __empty() {
                return _name.empty();
            }
                int __size() {
                return _name.size();
            }
        };

        void __add_compare_program(_Compare& , int , int ) {
            return;
        }

        void __add_compare_program(_Compare&) {
            return;
        }

        template<typename T, typename... Args>
        typename std::enable_if<IsProgramConstructible<T>::value, void>::type
        __add_compare_program(_Compare& compare, int start, int end, T first, Args... args) {
            compare.__add_testcase(first, start, end);
            __add_compare_program(compare, start, end, args...);
        }

        template<typename T, typename... Args>
        typename std::enable_if<IsProgramConstructible<T>::value, void>::type
        __add_compare_program(_Compare& compare, T first, Args... args) {
            compare.__add_testcase(first);
            __add_compare_program(compare, args...);
        }

        template<typename T, typename... Args>
        typename std::enable_if<IsCheckerConstructible<T>::value, void>::type
        compare(int start, int end, int time_limit, T&& checker, Args... args) {
            _Compare compare(std::forward<T>(checker), time_limit);
            __add_compare_program(compare, start, end, args...);
            compare.__compare();
            compare.__detail_summary(_msg::_defl);
        }

        template<typename T, typename... Args>
        typename std::enable_if<IsCheckerConstructible<T>::value, void>::type
        compare(int time_limit, T&& checker, Args... args) {
            _Compare compare(std::forward<T>(checker), time_limit);
            __add_compare_program(compare, args...);
            compare.__compare();
            compare.__detail_summary(_msg::_defl);
        }
    } // namespace io
} // namespace generator

#endif // _SGPCET_COMPARE_H_
#ifndef _SGPCET_VALIDATE_H_
#define _SGPCET_VALIDATE_H_

#ifndef _SGPCET_REPORTER_H_
#include "reporter.h"
#endif // _SGPCET_REPORTER_H_

namespace generator {
    namespace io {
        class _Validate : public _Reporter {
        protected:
            using TestResults = std::map<int, ReturnState>;
            _Program* _validator;
            TestResults _states;
            bool _default_judge;
            std::string _case_name;
            int _time_limit;
        public:
            _Validate() : _Reporter(), _validator(nullptr), _default_judge(true), _case_name(_setting::testcase_folder), _time_limit(_setting::time_limit_inf) {}

            template<typename T>
            _Validate(T&& validator, const std::string& case_name = _setting::testcase_folder, bool default_judge = true) : _Reporter(), _validator(nullptr), _default_judge(default_judge), _case_name(case_name) {
                __set_validator(std::forward<T>(validator));
            }
            ~_Validate() {
                if (_validator) delete _validator;
            }

            _GET_VALUE(_Program*, validator);
            _GET_VALUE(TestResults, states); 
            _SET_GET_VALUE(bool, default_judge);
            _SET_GET_VALUE(std::string, case_name);
            _SET_GET_VALUE(int, time_limit);

            template<typename T>
            void __set_validator(T&& validator) {
                if (_validator) delete _validator;
                _validator = __result_program(std::forward<T>(validator));
            }

            void __add_validate(int id) {
                if (!__testcase_input_file_exists(id)) return;
                _default_judge = false;
                _states[id] = ReturnState();
            }

            void __add_validate(int start, int end) {
                for (int i = start; i <= end; i++) __add_validate(i);
            }

            void __run() {
                _validator->__check_program_valid();
                Path folder = __validate_folder(_case_name);
                __create_directories(folder);
                if (_default_judge) {
                    for (auto& it : __get_all_inputs())
                        _states[it] = ReturnState();
                }
                int id = 1;
                for (auto& it : _states) {
                    Path log = __path_join(folder, __end_with(it.first, _enum::_VAL));
                    Path input = __input_file_path(__path_join(__current_path(), _case_name), it.first);
                    _msg::__flash_msg(_msg::_defl, "Validate : ", __ratio_msg(id, _states.size()));
                    id++;
                    it.second = _validator->__run_program(input, _setting::_default_path, log, _time_limit, _enum::_VALIDATOR);
                }
                _msg::__endl(_msg::_defl);
            }

            void __short_summary(_msg::OutStream& out) {
                std::vector<int> error_files;
                for (auto& state : _states) {
                    if (!__is_success(state.second.exit_code) || __time_limit_exceed(state.second.time, _time_limit))
                        error_files.push_back(state.first);
                }
                if (error_files.empty()) __all_pass(out);
                else __meets_error_files(out, error_files, _states.size());
            }

            _msg::_ColorMsg __state_msg(ReturnState state) {
                if (!__is_success(state.exit_code)) return _fail_msg;
                if (__time_limit_exceed(state.time, _time_limit)) return _tle_msg;
                return _success_msg;
            }

            void __detail_summary(_msg::OutStream& out) {
                _Table table(out);
                int fail_count = 0;
                for (auto& state : _states) {
                    if (!__is_success(state.second.exit_code))
                        fail_count++;
                }
                table.add_titles({"Case ID", "State", "RunTime"});
                if (fail_count) table.add_cell(3, 0, "Fail Message");
                int count = 0;
                for (auto& state: _states) {
                    count++;
                    table.add_cell(0, count, std::to_string(state.first));
                    table.add_cell(1, count, __state_msg(state.second));
                    if (!__is_success(state.second.exit_code)) 
                        table.add_cell(3, count, __get_fail_message(state.first));
                    else 
                        table.add_cell(2, count, tools::string_format(" %dms", state.second.time));
                }
                table.draw();
            }

            std::string __get_fail_message(int id) {
                Path folder = __validate_folder(_case_name);
                Path log = __path_join(folder, __end_with(id, _enum::_VAL));
                std::ifstream val_stream(log.path());
                std::string line;
                std::string result = "";
                while(val_stream >> line){
                    result += line;
                    result += " ";
                }
                val_stream.close();
                return result;
            }
        };

        template<typename T>
        typename std::enable_if<IsProgramConstructible<T>::value, void>::type
        validate(int start, int end, T program, std::string case_name = _setting::testcase_folder) {
            _Validate validator(std::forward<T>(program), case_name);
            validator.__add_validate(start, end);
            validator.__run();
            validator.__detail_summary(_msg::_defl);
        }

        template<typename T>
        typename std::enable_if<IsProgramConstructible<T>::value, void>::type
        validate(T program, std::string case_name = _setting::testcase_folder) {
            _Validate validator(std::forward<T>(program), case_name);
            validator.__run();
            validator.__detail_summary(_msg::_defl);
        }
    } // namespace io
} // namespace generator

#endif // !_SGPCET_VALIDATE_H_
#ifndef _SGPCET_OUTPUT_H_
#define _SGPCET_OUTPUT_H_

#ifndef _SGPCET_REPORTER_H_
#include "reporter.h"
#endif // _SGPCET_REPORTER_H_

namespace generator {
    namespace io {
        class _Output : public _Reporter {
        protected:
            using TestResults = std::map<int, ReturnState>;
            _Program* _std;
            TestResults _states;
            bool _cover_exist;
            int _time_limit;
        public:
            _Output() : _Reporter(), _std(nullptr), _cover_exist(true), _time_limit(_setting::time_limit_inf) {}

            template<typename T>
            _Output(T&& std, bool cover_exist = true, int time_limit = _setting::time_limit_inf) : _Reporter(), _std(nullptr), _cover_exist(cover_exist), _time_limit(time_limit) {
                __set_std(std::forward<T>(std));
            }

            ~_Output() {
                if (_std) delete _std;
            }

            _GET_VALUE(_Program*, std);
            _GET_VALUE(TestResults, states);
            _SET_GET_VALUE(bool, cover_exist);
            _SET_GET_VALUE(int, time_limit);

            template<typename T>
            void __set_std(T&& std) {
                if (_std) delete _std;
                _std = __result_program(std::forward<T>(std));
            }

            void __add_output(int id) {
                if (!__testcase_input_file_exists(id)) return;
                if (!_cover_exist && __testcase_output_file_exists(id)) return;
                _states[id] = ReturnState();
            }

            void __add_output(int start, int end) {
                for (int i = start; i <= end; i++) __add_output(i);
            }

            void __fill_output() {
                for (auto& it : __get_all_inputs()) __add_output(it);
            }

            void __run() {
                _std->__check_program_valid();
                int id = 1;
                for (auto& it : _states) {
                    Path input = __testcase_input_file_path(it.first);
                    Path output = __testcase_output_file_path(it.first);
                    _msg::__flash_msg(_msg::_defl, "Generate(Outputs) : ", __ratio_msg(id, _states.size()));
                    id++;
                    it.second = _std->__run_program(input, output, _setting::_default_path, _time_limit, _enum::_FuncProgramType::_RESULT);
                }
                _msg::__endl(_msg::_defl);
            }

            void __short_summary(_msg::OutStream& out) {
                std::vector<int> error_files;
                int run_time = 0;
                for (auto& state : _states) {
                    if (!__is_success(state.second.exit_code) || __time_limit_exceed(state.second.time, _time_limit))
                        error_files.push_back(state.first);
                    run_time = std::max(run_time, state.second.time);
                }
                __run_time_msg(out, run_time);
                if (error_files.empty()) __all_pass(out);
                else __meets_error_files(out, error_files, _states.size());
            }

            _msg::_ColorMsg __state_msg(ReturnState state) {
                if (!__is_success(state.exit_code)) return _run_error_msg;
                if (__time_limit_exceed(state.time, _time_limit)) return _tle_msg;
                return _success_msg;
            }

            void __detail_summary(_msg::OutStream& out) {
                _Table table(out);
                table.add_titles({"Case ID", "State", "RunTime"});
                int count = 0;
                for (auto& state: _states) {
                    count++;
                    table.add_cell(0, count, std::to_string(state.first));
                    table.add_cell(1, count, __state_msg(state.second));
                    if (!__is_success(state.second.exit_code)) continue;
                    table.add_cell(2, count, tools::string_format(" %dms", state.second.time));
                }
                table.draw();
            }
        };

        template<typename T>
        typename std::enable_if<IsProgramConstructible<T>::value, void>::type
        make_outputs(int start, int end, T program, int time_limit = _setting::time_limit_inf) {
            _Output output(program, true, time_limit);
            output.__add_output(start, end);
            output.__run();
            output.__detail_summary(_msg::_defl);
        }

        template<typename T>
        typename std::enable_if<!IsProgramConstructible<T>::value, void>::type
        make_outputs(int index, T program, int time_limit = _setting::time_limit_inf) {
            make_outputs(index, index, program, time_limit);
        }

        template<typename T>
        typename std::enable_if<IsProgramConstructible<T>::value, void>::type
        fill_outputs(T program, bool cover_exist = true, int time_limit = _setting::time_limit_inf) {
            _Output output(program, cover_exist, time_limit);
            output.__fill_output();
            output.__run();
            output.__detail_summary(_msg::_defl);
        }

    } 
}

#endif // _SGPCET_OUTPUT_H_
#ifndef _SGPCET_INPUT_H_
#define _SGPCET_INPUT_H_

#ifndef _SGPCET_REPORTER_H_
#include "reporter.h"
#endif // _SGPCET_REPORTER_H_

namespace generator {
    namespace io {
        class _Input : public _Reporter {
        protected:
            using TestResults = std::map<int, ReturnState>;
            std::map<int, _Program*> _gens;
            TestResults _states;
            int _time_limit;
        public:

            _Input() : _Reporter(), _time_limit(_setting::time_limit_inf) {}

            ~_Input() {
                for (auto& gen : _gens) {
                    delete gen.second;
                }
            }

            _GET_VALUE(TestResults, states);
            _SET_GET_VALUE(int, time_limit);
            
            template<typename T>
            void __add_input(int id, T&& gen) {
                _gens[id] = __generator_program(std::forward<T>(gen), id);
            }

            template<typename T>
            void __add_input(std::vector<int>& ids, T&& gen) {
                for (auto& id : ids) __add_input(id, std::forward<T>(gen));
            }

            template<typename T>
            void __fill_input(int count, T&& gen, bool from_cache = false) {
                if (count <= 0) _msg::__fail_msg(_msg::_defl, tools::string_format("The number of inputs must be a positive number, but found %d.", count));
                __create_directories(__testcases_folder());
                for (int i = 1; count; i++) {
                    if (i > _setting::test_case_limit) {
                        _msg::__warn_msg(_msg::_defl, tools::string_format("The number of inputs must be less than test_case_limit(%d)", _setting::test_case_limit));
                        return;
                    }
                    if (from_cache && _gens.find(i) != _gens.end()) continue;
                    if (!from_cache && __testcase_input_file_path(i).__file_exist()) continue;
                    __add_input(i, std::forward<T>(gen));
                    count--;
                }
            }

            void __run() {
                __create_directories(__testcases_folder());
                _states.clear();
                int id = 1;
                for (auto& gen : _gens) {
                    Path input = __testcase_input_file_path(gen.first);
                    _msg::__flash_msg(_msg::_defl, "Generate(Inputs) : ", __ratio_msg(id, _gens.size()));
                    id++;
                    _states[gen.first] = gen.second->__run_program(_setting::_default_path, input, _setting::_default_path, _time_limit, _enum::_FuncProgramType::_GENERATOR);
                }
                _msg::__endl(_msg::_defl);
            }

            void __short_summary(_msg::OutStream& out) {
                std::vector<int> error_files;
                for (auto& state : _states) {
                    if (!__is_success(state.second.exit_code) || __time_limit_exceed(state.second.time, _time_limit))
                        error_files.push_back(state.first);
                }
                if (error_files.empty()) __all_pass(out);
                else __meets_error_files(out, error_files, _states.size());
            }

            _msg::_ColorMsg __state_msg(ReturnState state) {
                if (!__is_success(state.exit_code)) return _run_error_msg;
                if (__time_limit_exceed(state.time, _time_limit)) return _tle_msg;
                return _success_msg;
            }

            void __detail_summary(_msg::OutStream& out) {
                _Table table(out);
                table.add_titles({"Case ID", "Generator Name", "Seed", "State", "RunTime"});
                int count = 0;
                for (auto& state: _states) {
                    count++;
                    table.add_cell(0, count, std::to_string(state.first));
                    table.add_cell(1, count, _gens[state.first]->name());
                    table.add_cell(2, count, _gens[state.first]->get_argv_without_redirection());
                    table.add_cell(3, count, __state_msg(state.second));
                    if (!__is_success(state.second.exit_code)) continue;
                    table.add_cell(4, count, tools::string_format(" %dms", state.second.time));
                }
                table.draw();
            }

            bool __empty() {
                return _gens.empty();
            }

            int __size() {
                return _gens.size();
            }
        }; 

        template<typename T>
        typename std::enable_if<IsProgramConstructible<T>::value, void>::type
        make_inputs(int start, int end, T gen) {  
            _Input input;
            for (int i = start; i <= end; i++) 
                input.__add_input(i, std::forward<T>(gen));
            input.__run();
            input.__detail_summary(_msg::_defl);
        }
        
        template<typename T>
        typename std::enable_if<IsProgramConstructible<T>::value, void>::type
        make_inputs(int index, T gen) {
            make_inputs(index, index, gen);
        }

        template<typename T>
        typename std::enable_if<IsProgramConstructible<T>::value, void>::type
        fill_inputs(int sum, T gen) {     
            _Input input;
            input.__fill_input(sum, std::forward<T>(gen));
            input.__run();
            input.__detail_summary(_msg::_defl);
        }

        template<typename T>
        typename std::enable_if<IsProgramConstructible<T>::value, void>::type
        fill_inputs(T gen) {
            fill_inputs(1, gen);
        }

    }; // namespace io
}; // namespace generator

#endif // _SGPCET_INPUT_H_
#ifndef _SGPCET_SIMPLE_POLYGON_H_
#define _SGPCET_SIMPLE_POLYGON_H_

#ifndef _SGPCET_POINTS_H_
#include "points.h"
#endif //!_SGPCET_POINTS_H_
#ifndef _SGPCET_GEOMETRY_ALGORITHM_H_
#include "geometry_algorithm.h"
#endif //!_SGPCET_GEOMETRY_ALGORITHM_H_

namespace generator {
    namespace rand_geometry {

        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class SimplePolygon;

        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class SimplePolygonGen : public BasicPolygonGen<SimplePolygon, T> {
        public:
            using Context = SimplePolygon<T>;
            using Super = BasicPolygonGen<SimplePolygon, T>;
            SimplePolygonGen(Context& points) : BasicPolygonGen<SimplePolygon, T>(points) {}
        protected:
            virtual void __generate_geometry() override {
                _CONTEXT_GET(node_count);
                _CONTEXT_GET(x_left_limit);
                _CONTEXT_GET(x_right_limit);
                _CONTEXT_GET(y_left_limit);
                _CONTEXT_GET(y_right_limit);
                RandomPoints<T> p(node_count, x_left_limit, x_right_limit, y_left_limit, y_right_limit);
                p.gen();
                _CONTEXT_GET_REF(points);
                points = p.points();
                Point<T> center = __get_center(points);
                __polar_angle_sort(points, center);
            }

            Point<T> __get_center(std::vector<Point<T>>& points) {
                _ResultTypeT<T> x_sum = 0;
                _ResultTypeT<T> y_sum = 0;
                for (auto& p : points) {
                    x_sum += p.x();
                    y_sum += p.y();
                }
                _ResultTypeT<T> n = points.size();
                return Point<T>(x_sum / n, y_sum / n);
            }
        };

        template <typename T, typename>
        class SimplePolygon : public RandomPoints<T> {
        public:
            using _Self = SimplePolygon<T>;
            _OUTPUT_FUNCTION(_Self)
        public:
            SimplePolygon(int node_count = 1, T x_left_limit = 0, T x_right_limit = 0, T y_left_limit = 0, T y_right_limit = 0) :
                RandomPoints<T>(node_count, x_left_limit, x_right_limit, y_left_limit, y_right_limit) 
            {
                _GEOMETRY_DEFAULT 
            }

            _DISABLE_SAME_POINT
            _OUTPUT_FUNCTION_SETTING(_Self)
        protected:
            _DEFAULT_GEOMETRY_GEN_FUNC(SimplePolygon)
        };
    } // namespace rand_geometry
} // namespace generator

#endif //!_SGPCET_SIMPLE_POLYGON_H_
#ifndef _SGPCET_TRIANGLE_H_
#define _SGPCET_TRIANGLE_H_

#ifndef _SGPCET_CONVEX_HULL_H_
#include "convex_hull.h"
#endif //!_SGPCET_CONVEX_HULL_H_

namespace generator {
    namespace rand_geometry {
        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class Triangle;

        template <typename T, typename = typename std::enable_if<is_point_type<T>::value>::type>
        class TriangleGen : public ConvexHullGen<T>  {
        public:
            using Context = Triangle<T>;
            TriangleGen(Context& points) : ConvexHullGen<T>(points) {}
        };

        template <typename T, typename>
        class Triangle : public ConvexHull<T> {
        public:
            using _Self = Triangle<T>;
            _OUTPUT_FUNCTION(_Self);
        public:
            Triangle(T x_left_limit = 0, T x_right_limit = 0, T y_left_limit = 0, T y_right_limit = 0) :
                ConvexHull<T>(3, x_left_limit, x_right_limit, y_left_limit, y_right_limit)       
            {
                _GEOMETRY_DEFAULT 
                this->_output_node_count = false;
            }

            void default_output(std::ostream& os) const {
                if (this->_output_node_count) {
                    os << this->_node_count << "\n";
                }
                os << this->_points[0] << " " << this->_points[1] << " " << this->_points[2];
            }

            _DISABLE_NODE_COUNT
            _OUTPUT_FUNCTION_SETTING(_Self)
        protected:
            _DEFAULT_GEOMETRY_GEN_FUNC(Triangle)
        };
    } // namespace rand_geometry
} // namespace generator
#endif //!_SGPCET_TRIANGLE_H_
#ifndef _SGPCET_BOTH_WEIGHT_H_
#define _SGPCET_BOTH_WEIGHT_H_

#ifndef _SGPCET_ALL_TREE_GRAPH_H_
#include "all_tree_graph.h"
#endif // !_SGPCET_ALL_TREE_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace both_weight {
            template <typename EdgeType>
            using Edge = basic::_Edge<EdgeType>;

            template <typename NodeType>
            using NodeWeight = basic::_Node<NodeType>;

            using TreeGenerator = _enum::TreeGenerator;

            template <typename NodeType, typename EdgeType>
            using TreeGen = basic::TreeGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using RandomFatherGen = basic::RandomFatherGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using PrueferGen = basic::PrueferGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using Tree = basic::Tree<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using ChainGen = basic::ChainGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using Chain = basic::Chain<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using FlowerGen = basic::FlowerGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using Flower = basic::Flower<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using HeightTreeGen = basic::HeightTreeGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using HeightTree = basic::HeightTree<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using MaxDegreeTreeGen = basic::MaxDegreeTreeGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using MaxDegreeTree = basic::MaxDegreeTree<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using MaxSonTreeGen = basic::MaxSonTreeGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using MaxSonTree = basic::MaxSonTree<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using GraphGen = basic::GraphGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using Graph = basic::Graph<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using BipartiteGraphGen = basic::BipartiteGraphGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using BipartiteGraph = basic::BipartiteGraph<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using DAGGen = basic::DAGGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using DAG = basic::DAG<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using CycleGraphGen = basic::CycleGraphGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using CycleGraph = basic::CycleGraph<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using WheelGraphGen = basic::WheelGraphGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using WheelGraph = basic::WheelGraph<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using GridGraphGen = basic::GridGraphGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using GridGraph = basic::GridGraph<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using PseudoTreeGen = basic::PseudoTreeGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using PseudoTree = basic::PseudoTree<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using PseudoInTreeGen = basic::PseudoInTreeGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using PseudoInTree = basic::PseudoInTree<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using PseudoOutTreeGen = basic::PseudoOutTreeGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using PseudoOutTree = basic::PseudoOutTree<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using CactusGen = basic::CactusGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using Cactus = basic::Cactus<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using LinkGen = basic::LinkGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using Link = basic::Link<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using TreeLinkGen = basic::TreeLinkGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using TreeLink = basic::TreeLink<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using ForestGen = basic::ForestGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using Forest = basic::Forest<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using FlowerChainGen = basic::FlowerChainGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using FlowerChain = basic::FlowerChain<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using DegreeTree = basic::DegreeTree<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using DegreeTreeGen = basic::DegreeTreeGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using SonTree = basic::SonTree<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using SonTreeGen = basic::SonTreeGen<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using StartReachableGraph = basic::StartReachableGraph<NodeType, EdgeType>;

            template <typename NodeType, typename EdgeType>
            using StartReachableGraphGen = basic::StartReachableGraphGen<NodeType, EdgeType>;
        } // namespace both_weight
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_BOTH_WEIGHT_H_
#ifndef _SGPCET_EDGE_WEIGHT_H_
#define _SGPCET_EDGE_WEIGHT_H_

#ifndef _SGPCET_ALL_TREE_GRAPH_H_
#include "all_tree_graph.h"
#endif // !_SGPCET_ALL_TREE_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace edge_weight {
            template <typename EdgeType>
            using Edge = basic::_Edge<EdgeType>;

            using NodeWeight = basic::_Node<void>;

            using TreeGenerator = _enum::TreeGenerator;

            template <typename EdgeType>
            using TreeGen = basic::TreeGen<void, EdgeType>;

            template <typename EdgeType>
            using RandomFatherGen = basic::RandomFatherGen<void, EdgeType>;

            template <typename EdgeType>
            using PrueferGen = basic::PrueferGen<void, EdgeType>;

            template <typename EdgeType>
            using Tree = basic::Tree<void, EdgeType>;

            template <typename EdgeType>
            using ChainGen = basic::ChainGen<void, EdgeType>;

            template <typename EdgeType>
            using Chain = basic::Chain<void, EdgeType>;

            template <typename EdgeType>
            using FlowerGen = basic::FlowerGen<void, EdgeType>;

            template <typename EdgeType>
            using Flower = basic::Flower<void, EdgeType>;

            template <typename EdgeType>
            using HeightTreeGen = basic::HeightTreeGen<void, EdgeType>;

            template <typename EdgeType>
            using HeightTree = basic::HeightTree<void, EdgeType>;

            template <typename EdgeType>
            using MaxDegreeTreeGen = basic::MaxDegreeTreeGen<void, EdgeType>;

            template <typename EdgeType>
            using MaxDegreeTree = basic::MaxDegreeTree<void, EdgeType>;

            template <typename EdgeType>
            using MaxSonTreeGen = basic::MaxSonTreeGen<void, EdgeType>;

            template <typename EdgeType>
            using MaxSonTree = basic::MaxSonTree<void, EdgeType>;

            template <typename EdgeType>
            using GraphGen = basic::GraphGen<void, EdgeType>;

            template <typename EdgeType>
            using Graph = basic::Graph<void, EdgeType>;

            template <typename EdgeType>
            using BipartiteGraphGen = basic::BipartiteGraphGen<void, EdgeType>;

            template <typename EdgeType>
            using BipartiteGraph = basic::BipartiteGraph<void, EdgeType>;

            template <typename EdgeType>
            using DAGGen = basic::DAGGen<void, EdgeType>;

            template <typename EdgeType>
            using DAG = basic::DAG<void, EdgeType>;

            template <typename EdgeType>
            using CycleGraphGen = basic::CycleGraphGen<void, EdgeType>;

            template <typename EdgeType>
            using CycleGraph = basic::CycleGraph<void, EdgeType>;

            template <typename EdgeType>
            using WheelGraphGen = basic::WheelGraphGen<void, EdgeType>;

            template <typename EdgeType>
            using WheelGraph = basic::WheelGraph<void, EdgeType>;

            template <typename EdgeType>
            using GridGraphGen = basic::GridGraphGen<void, EdgeType>;

            template <typename EdgeType>
            using GridGraph = basic::GridGraph<void, EdgeType>;

            template <typename EdgeType>
            using PseudoTreeGen = basic::PseudoTreeGen<void, EdgeType>;

            template <typename EdgeType>
            using PseudoTree = basic::PseudoTree<void, EdgeType>;

            template <typename EdgeType>
            using PseudoInTreeGen = basic::PseudoInTreeGen<void, EdgeType>;

            template <typename EdgeType>
            using PseudoInTree = basic::PseudoInTree<void, EdgeType>;

            template <typename EdgeType>
            using PseudoOutTreeGen = basic::PseudoOutTreeGen<void, EdgeType>;

            template <typename EdgeType>
            using PseudoOutTree = basic::PseudoOutTree<void, EdgeType>;

            template <typename EdgeType>
            using CactusGen = basic::CactusGen<void, EdgeType>;

            template <typename EdgeType>
            using Cactus = basic::Cactus<void, EdgeType>;

            template <typename EdgeType>
            using LinkGen = basic::LinkGen<void, EdgeType>;

            template <typename EdgeType>
            using Link = basic::Link<void, EdgeType>;

            template <typename EdgeType>
            using TreeLinkGen = basic::TreeLinkGen<void, EdgeType>;

            template <typename EdgeType>
            using TreeLink = basic::TreeLink<void, EdgeType>;

            template <typename EdgeType>
            using ForestGen = basic::ForestGen<void, EdgeType>;

            template <typename EdgeType>
            using Forest = basic::Forest<void, EdgeType>;

            template <typename EdgeType>
            using FlowerChainGen = basic::FlowerChainGen<void, EdgeType>;

            template <typename EdgeType>
            using FlowerChain = basic::FlowerChain<void, EdgeType>;

            template <typename EdgeType>
            using DegreeTree = basic::DegreeTree<void, EdgeType>;

            template <typename EdgeType>
            using DegreeTreeGen = basic::DegreeTreeGen<void, EdgeType>;

            template <typename EdgeType>
            using SonTree = basic::SonTree<void, EdgeType>;

            template <typename EdgeType>
            using SonTreeGen = basic::SonTreeGen<void, EdgeType>;

            template <typename EdgeType>
            using StartReachableGraph = basic::StartReachableGraph<void, EdgeType>;

            template <typename EdgeType>
            using StartReachableGraphGen = basic::StartReachableGraphGen<void, EdgeType>;
        } // namespace edge_weight
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_EDGE_WEIGHT_H_
#ifndef _SGPCET_NODE_WEIGHT_H_
#define _SGPCET_NODE_WEIGHT_H_

#ifndef _SGPCET_ALL_TREE_GRAPH_H_
#include "all_tree_graph.h"
#endif // !_SGPCET_ALL_TREE_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace node_weight {
            using Edge = basic::_Edge<void>;

            template <typename NodeType>
            using NodeWeight = basic::_Node<NodeType>;

            using TreeGenerator = _enum::TreeGenerator;

            template <typename NodeType>
            using TreeGen = basic::TreeGen<NodeType, void>;

            template <typename NodeType>
            using RandomFatherGen = basic::RandomFatherGen<NodeType, void>;

            template <typename NodeType>
            using PrueferGen = basic::PrueferGen<NodeType, void>;

            template <typename NodeType>
            using Tree = basic::Tree<NodeType, void>;

            template <typename NodeType>
            using ChainGen = basic::ChainGen<NodeType, void>;

            template <typename NodeType>
            using Chain = basic::Chain<NodeType, void>;

            template <typename NodeType>
            using FlowerGen = basic::FlowerGen<NodeType, void>;

            template <typename NodeType>
            using Flower = basic::Flower<NodeType, void>;

            template <typename NodeType>
            using HeightTreeGen = basic::HeightTreeGen<NodeType, void>;

            template <typename NodeType>
            using HeightTree = basic::HeightTree<NodeType, void>;

            template <typename NodeType>
            using MaxDegreeTreeGen = basic::MaxDegreeTreeGen<NodeType, void>;

            template <typename NodeType>
            using MaxDegreeTree = basic::MaxDegreeTree<NodeType, void>;

            template <typename NodeType>
            using MaxSonTreeGen = basic::MaxSonTreeGen<NodeType, void>;

            template <typename NodeType>
            using MaxSonTree = basic::MaxSonTree<NodeType, void>;

            template <typename NodeType>
            using GraphGen = basic::GraphGen<NodeType, void>;

            template <typename NodeType>
            using Graph = basic::Graph<NodeType, void>;

            template <typename NodeType>
            using BipartiteGraphGen = basic::BipartiteGraphGen<NodeType, void>;

            template <typename NodeType>
            using BipartiteGraph = basic::BipartiteGraph<NodeType, void>;

            template <typename NodeType>
            using DAGGen = basic::DAGGen<NodeType, void>;

            template <typename NodeType>
            using DAG = basic::DAG<NodeType, void>;

            template <typename NodeType>
            using CycleGraphGen = basic::CycleGraphGen<NodeType, void>;

            template <typename NodeType>
            using CycleGraph = basic::CycleGraph<NodeType, void>;

            template <typename NodeType>
            using WheelGraphGen = basic::WheelGraphGen<NodeType, void>;

            template <typename NodeType>
            using WheelGraph = basic::WheelGraph<NodeType, void>;

            template <typename NodeType>
            using GridGraphGen = basic::GridGraphGen<NodeType, void>;

            template <typename NodeType>
            using GridGraph = basic::GridGraph<NodeType, void>;

            template <typename NodeType>
            using PseudoTreeGen = basic::PseudoTreeGen<NodeType, void>;

            template <typename NodeType>
            using PseudoTree = basic::PseudoTree<NodeType, void>;

            template <typename NodeType>
            using PseudoInTreeGen = basic::PseudoInTreeGen<NodeType, void>;

            template <typename NodeType>
            using PseudoInTree = basic::PseudoInTree<NodeType, void>;

            template <typename NodeType>
            using PseudoOutTreeGen = basic::PseudoOutTreeGen<NodeType, void>;

            template <typename NodeType>
            using PseudoOutTree = basic::PseudoOutTree<NodeType, void>;

            template <typename NodeType>
            using CactusGen = basic::CactusGen<NodeType, void>;

            template <typename NodeType>
            using Cactus = basic::Cactus<NodeType, void>;

            template <typename NodeType>
            using LinkGen = basic::LinkGen<NodeType, void>;

            template <typename NodeType>
            using Link = basic::Link<NodeType, void>;

            template <typename NodeType>
            using TreeLinkGen = basic::TreeLinkGen<NodeType, void>;

            template <typename NodeType>
            using TreeLink = basic::TreeLink<NodeType, void>;

            template <typename NodeType>
            using ForestGen = basic::ForestGen<NodeType, void>;

            template <typename NodeType>
            using Forest = basic::Forest<NodeType, void>;

            template <typename NodeType>
            using FlowerChainGen = basic::FlowerChainGen<NodeType, void>;

            template <typename NodeType>
            using FlowerChain = basic::FlowerChain<NodeType, void>;

            template <typename NodeType>
            using DegreeTree = basic::DegreeTree<NodeType, void>;

            template <typename NodeType>
            using DegreeTreeGen = basic::DegreeTreeGen<NodeType, void>;

            template <typename NodeType>
            using SonTree = basic::SonTree<NodeType, void>;

            template <typename NodeType>
            using SonTreeGen = basic::SonTreeGen<NodeType, void>;

            template <typename NodeType>
            using StartReachableGraph = basic::StartReachableGraph<NodeType, void>;

            template <typename NodeType>
            using StartReachableGraphGen = basic::StartReachableGraphGen<NodeType, void>;
        } // namespace node_weight
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_NODE_WEIGHT_H_
#ifndef _SGPCET_UNWEIGHT_H_
#define _SGPCET_UNWEIGHT_H_

#ifndef _SGPCET_ALL_TREE_GRAPH_H_
#include "all_tree_graph.h"
#endif // !_SGPCET_ALL_TREE_GRAPH_H_

namespace generator {
    namespace rand_graph {
        namespace unweight {
            using Edge = basic::_Edge<void>;
            using NodeWeight = basic::_Node<void>;
            using TreeGenerator = _enum::TreeGenerator;
            using TreeGen = basic::TreeGen<void, void>;
            using RandomFatherGen = basic::RandomFatherGen<void, void>;
            using PrueferGen = basic::PrueferGen<void, void>;
            using Tree = basic::Tree<void, void>;
            using ChainGen = basic::ChainGen<void, void>;
            using Chain = basic::Chain<void, void>;
            using FlowerGen = basic::FlowerGen<void, void>;
            using Flower = basic::Flower<void, void>;
            using HeightTreeGen = basic::HeightTreeGen<void, void>;
            using HeightTree = basic::HeightTree<void, void>;
            using MaxDegreeTreeGen = basic::MaxDegreeTreeGen<void, void>;
            using MaxDegreeTree = basic::MaxDegreeTree<void, void>;
            using MaxSonTreeGen = basic::MaxSonTreeGen<void, void>;
            using MaxSonTree = basic::MaxSonTree<void, void>;
            using GraphGen = basic::GraphGen<void, void>;
            using Graph = basic::Graph<void, void>;
            using BipartiteGraphGen = basic::BipartiteGraphGen<void, void>;
            using BipartiteGraph = basic::BipartiteGraph<void, void>;
            using DAGGen = basic::DAGGen<void, void>;
            using DAG = basic::DAG<void, void>;
            using CycleGraphGen = basic::CycleGraphGen<void, void>;
            using CycleGraph = basic::CycleGraph<void, void>;
            using WheelGraphGen = basic::WheelGraphGen<void, void>;
            using WheelGraph = basic::WheelGraph<void, void>;
            using GridGraphGen = basic::GridGraphGen<void, void>;
            using GridGraph = basic::GridGraph<void, void>;
            using PseudoTreeGen = basic::PseudoTreeGen<void, void>;
            using PseudoTree = basic::PseudoTree<void, void>;
            using PseudoInTreeGen = basic::PseudoInTreeGen<void, void>;
            using PseudoInTree = basic::PseudoInTree<void, void>;
            using PseudoOutTreeGen = basic::PseudoOutTreeGen<void, void>;
            using PseudoOutTree = basic::PseudoOutTree<void, void>;
            using CactusGen = basic::CactusGen<void, void>;
            using Cactus = basic::Cactus<void, void>;
            using LinkGen = basic::LinkGen<void, void>;
            using Link = basic::Link<void, void>;
            using TreeLinkGen = basic::TreeLinkGen<void, void>;
            using TreeLink = basic::TreeLink<void, void>;
            using ForestGen = basic::ForestGen<void, void>;
            using Forest = basic::Forest<void, void>;
            using FlowerChainGen = basic::FlowerChainGen<void, void>;
            using FlowerChain = basic::FlowerChain<void, void>;
            using DegreeTree = basic::DegreeTree<void, void>;
            using DegreeTreeGen = basic::DegreeTreeGen<void, void>;
            using SonTree = basic::SonTree<void, void>;
            using SonTreeGen = basic::SonTreeGen<void, void>;
            using StartReachableGraph = basic::StartReachableGraph<void, void>;
            using StartReachableGraphGen = basic::StartReachableGraphGen<void, void>;
        } // namespace unweight
    } // namespace rand_graph
} // namespace generator

#endif // !_SGPCET_UNWEIGHT_H_
#ifndef _SGPCET_DISTRIBUTION_H_
#define _SGPCET_DISTRIBUTION_H_

#ifndef _SGPCET_NUMERIC_H_
#include "numeric.h"
#endif // !_SGPCET_NUMERIC_H_

namespace generator {
    namespace rand_numeric {
        template<typename T = double>
        class NormalDistribution {
            private:
            T mean_, stddev_;
            T spare_;
            bool has_spare_;
            
        public:
            explicit NormalDistribution(T mean = 0, T stddev = 1) 
                : mean_(mean), stddev_(stddev), has_spare_(false) {}
            
            T rand() {
                return static_cast<T>(__rand());
            }

            T rand(T from, T to) {
                T x;
                do {
                    x = rand();
                } while (x < from || x > to);
                return x;
            }

        private:
            double __rand() {
                if (has_spare_) {
                    has_spare_ = false;
                    return mean_ + stddev_ * spare_;
                }
                
                double u1 = rand_numeric::rand_real<double>();
                double u2 = rand_numeric::rand_real<double>();
                
                u1 = std::max(u1, std::numeric_limits<double>::epsilon());
                u2 = std::max(u2, std::numeric_limits<double>::epsilon());
                
                double z0 = std::sqrt(-2 * std::log(u1)) * std::cos(2 * _setting::PI * u2);
                double z1 = std::sqrt(-2 * std::log(u1)) * std::sin(2 * _setting::PI * u2);
                
                spare_ = z1;
                has_spare_ = true;
                
                return mean_ + stddev_ * z0;               
            }
        };

        template<typename T = double>
        class LogNormalDistribution {
        private:
            T mu_, sigma_;
            NormalDistribution<T> normal_dist_;
            
        public:
            explicit LogNormalDistribution(T mu = 0, T sigma = 1) 
                : mu_(mu), sigma_(sigma), normal_dist_(mu, sigma) {}
            
            T rand() {
                return std::exp(normal_dist_.rand());
            }

            T rand(T from, T to) {
                T x;
                do {
                    x = rand();
                } while (x < from || x > to);
                return x;
            }
        };
    }
}

#endif // _SGPCET_DISTRIBUTION_H_
#ifndef _SGPCET_BIG_INT_H_
#define _SGPCET_BIG_INT_H_

#ifndef _SGPCET_BIG_INT_BASE_H_
#include "math/big_int_base.h"
#endif //!_SGPCET_BIG_INT_BASE_H_
#ifndef _SGPCET_CHAR_SET_CHECK_H_
#include "math/char_set_check.h"
#endif //!_SGPCET_CHAR_SET_CHECK_H_

namespace generator {
    namespace math {
        class BigInt : public BigIntCalculator<BigInt> {
        public:
            friend class BigIntCalculator<BigInt>;
            const static u32 COMPRESS_BIT = 20;
            constexpr static u32 COMPRESS_MOD = 1 << COMPRESS_BIT;
            constexpr static u32 COMPRESS_MASK = COMPRESS_MOD - 1;
            using FromStrFunction = std::function<void(BigInt&, const std::string&)>;
            using InputFunction = std::function<void(std::istream& is, BigInt& num)>;
            using ToStrFunction = std::function<std::string(const BigInt& num, int)>;
            using OutputFunction = std::function<void(std::ostream& os, const BigInt& num)>;
        protected:
            FromStrFunction _from_str_function;
            InputFunction _input_function;
            ToStrFunction _to_str_function;
            OutputFunction _output_function;
            int _in_out_base; // -1 : default(10)
        public:

            BigInt() : _in_out_base(-1) { 
                set_value(0);
                set_from_str_default();
                set_input_default();
                set_to_str_default();
                set_output_default();
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            BigInt(T val)  : _in_out_base(-1) {
                set_value(val);
                set_from_str_default();
                set_input_default();
                set_to_str_default();
                set_output_default();
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            BigInt(T val, int base)  : _in_out_base(base) {
                set_value(val);
                set_from_str_default();
                set_input_default();
                set_to_str_default();
                set_output_default();
            }

            BigInt(const std::string& s, int base = -1) : _in_out_base(base) {
                set_from_str_default();
                set_input_default();
                set_to_str_default();
                set_output_default();
                from_str(s, base);
            }

            BigInt(const BigInt& other) : 
                BigIntCalculator<BigInt>(other), 
                _from_str_function(other._from_str_function), 
                _input_function(other._input_function), 
                _to_str_function(other._to_str_function),
                _output_function(other._output_function),
                _in_out_base(other._in_out_base) {}
            
            BigInt& operator=(const BigInt& other) {
                if (this != &other) {
                    BigIntCalculator<BigInt>::operator=(other);
                    _from_str_function = other._from_str_function;
                    _input_function = other._input_function;
                    _to_str_function = other._to_str_function;
                    _output_function = other._output_function;
                    _in_out_base = other._in_out_base;
                }
                return *this;
            }

            BigInt(BigInt&& other) noexcept : 
                BigIntCalculator<BigInt>(std::move(other)), 
                _from_str_function(std::move(other._from_str_function)),
                _input_function(std::move(other._input_function)), 
                _to_str_function(std::move(other._to_str_function)),
                _output_function(std::move(other._output_function)),
                _in_out_base(std::move(other._in_out_base)) {}

            BigInt& operator=(BigInt&& other) noexcept {
                if (this != &other) {
                    BigIntCalculator<BigInt>::operator=(std::move(other));
                    _from_str_function = std::move(other._from_str_function);
                    _input_function = std::move(other._input_function);
                    _to_str_function = std::move(other._to_str_function);
                    _output_function = std::move(other._output_function);
                    _in_out_base = std::move(other._in_out_base);
                } 
                return *this;
            }

            BigInt& operator=(const std::string& str) {
                from_str(str, _in_out_base);
                return *this;
            }

            BigInt& operator=(const char* str) {
                from_str(str, _in_out_base);
                return *this;
            }

            template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
            BigInt& operator=(T val) {
                set_value(val);
                return *this;
            }

            void set_from_str(FromStrFunction from_str_function) {
                _from_str_function = from_str_function; 
            }

            void set_from_str_default() {
                _from_str_function = [](BigInt& val, const std::string& s) { val.__default_from_str(s); }; 
            }

            void from_str(const std::string& s, int base = -1) {
                _in_out_base = base;
                _from_str_function(*this, s);
            }

            void set_input(InputFunction input_function) {
                _input_function = input_function;
            }

            void set_input_default() {
                _input_function = [](std::istream& is, BigInt& num) { num.__default_input(is); };
            }

            friend std::istream& operator>>(std::istream& is, BigInt& num) {
                num._input_function(is, num);
                return is;
            }

            void set_to_str(ToStrFunction to_str_function) {
                _to_str_function = to_str_function;
            }

            void set_to_str_default() {
                _to_str_function = [](const BigInt& num, int base) { return num.__default_to_str(base); };
            }

            std::string to_str(int base = -1) const {
                return _to_str_function(*this, base);
            }

            void set_output(OutputFunction output_function) {
                _output_function = output_function; 
            }

            void set_output_default() {
                _output_function = [](std::ostream& os, const BigInt& num) { num.__default_output(os); }; 
            }

            friend std::ostream& operator<<(std::ostream& os, const BigInt& num) {
                num._output_function(os, num);
                return os; 
            }

            _SET_GET_VALUE(int, in_out_base);

        protected:
            int __parse_base(const std::string& s, int& p) {
                int n = s.size();
                if (n == 0) _msg::__fail_msg(_msg::_defl, "string with zero number can't be read.");
                if (s[p] == '0') {
                    if (p + 1 == n) return -1;
                    if (s[p + 1] == 'x') {
                        p += 2;
                        return 16; 
                    }
                    else if (s[p + 1] == 'b') {
                        p += 2;
                        return 2; 
                    } else {
                        return 8; 
                    }
                }
                return -1;
            }
            int __parse_negative(const std::string& s) {
                _is_negative = false;
                int p = 0, n = s.size();
                while(s[p] == '+' || s[p] == '-') {
                    if (s[p] == '-') _is_negative ^= 1;
                    p++;
                    if (p == n) _msg::__fail_msg(_msg::_defl, "string with zero number can't be read.");
                }
                return p;
            }

            static BigInt __get_base_pow(int base, int p) {
                if (!_setting::big_int_cache_pow) return BigInt::pow(base, p);
                static int origin_base = -1;
                static std::vector<BigInt> base_pow;
                if (origin_base != base) {
                    origin_base = base;
                    base_pow.clear();
                    base_pow.emplace_back(1);
                }
                if (base_pow.size() > p && base_pow[p] != 0) return base_pow[p];
                else if (base_pow.size() <= p ) base_pow.resize(p + 1);
                BigInt result(1);
                BigInt a(base);
                int b = p;
                int add = 1;
                int sum = 0;
                while (b) {
                    if (b & 1) {
                        result = result * a;
                        sum |= add;
                        base_pow[sum] = result;
                    }
                    a = a * a;
                    b >>= 1;
                    add <<= 1;
                    if (add <= _setting::vector_limit) {
                        if (add >= base_pow.size()) base_pow.resize(add + 1);
                        base_pow[add] = a;
                    }
                }

                base_pow[p] = result;
                return base_pow[p];
            }

            BigInt __from_string(const std::string& s, int start, int end, int base, int limit) {
                if (end - start < limit) {
                    i64 num = 0;
                    auto& mp = _setting::BigNumberSetting::labels_map();
                    for (int i = start; i < end; i++) {
                        num *= base;
                        int v = mp[std::string(1, s[i])];
                        if (v >= base) _msg::__fail_msg(_msg::_defl, 
                            tools::string_format("string with out base(%d) character %c(%d) can't be read.", base, s[i], v));
                        num += v;
                    }
                    auto res = BigInt(num);
                    return res;
                }                    
                int mid = (start + end) / 2;
                BigInt high = __from_string(s, start, mid, base, limit);
                BigInt low = __from_string(s, mid, end, base, limit);
                auto res = high * __get_base_pow(base, end - mid) + low;
                return res;
            }

            void __from_string(BigInt& val, const std::string& s, int start, int end, int base, int limit) {
                val.data_ref() = std::move(__from_string(s, start, end, base, limit).data());
            }

            void __from_string_pow2(BigInt& val, const std::string& s, int start, int base) {
                int t = __calculate_pow2(base);
                int n = s.size();
                int bit = __digits();
                u64 add = 0;
                int p = 0;
                auto& mp = _setting::BigNumberSetting::labels_map();
                for (int i = n - 1; i >= start; i--) {
                    u64 v = mp[std::string(1, s[i])];
                        if (v >= base) _msg::__fail_msg(_msg::_defl, 
                            tools::string_format("string with out base(%d) character %c(%d) can't be read.", base, s[i], v));
                    add += (v << p);
                    p += t;
                    if (p >= bit) {
                        _data.emplace_back(add & COMPRESS_MASK);
                        p -= bit;
                        add >>= bit;
                    }
                }
                if (add) _data.emplace_back(add);
            }

            void __default_from_str(const std::string& s) {
                _setting::CharSetCheck::enable_default_read();
                int p = __parse_negative(s);
                int actual_base = _in_out_base == -1 ? 10 : _in_out_base;
                if (_setting::big_int_parse_prefix) {
                    int b = __parse_base(s, p);
                    if (b != -1 && _in_out_base != -1 && _in_out_base != b) {
                        _msg::__fail_msg(_msg::_defl, "base is not match.");
                    }
                    if (b != -1) {
                        actual_base = b;
                        _in_out_base = b;
                    }   
                }

                _data.clear();     
                _setting::CharSetCheck::enable_base(actual_base);
                if (s.empty()) _msg::__fail_msg(_msg::_defl, "empty string can't be read.");
                if (BigInt::__is_pow2(actual_base)) __from_string_pow2(*this, s, p, actual_base);
                else {
                    int limit = __calculate_limit(actual_base);
                    __from_string(*this, s, p, s.size(), actual_base, limit);
                }
            }

            std::string __to_string_pow2(int base) const {
                int t = __calculate_pow2(base);
                int bit = __digits();
                int n = _data.size();
                std::vector<i64> res;
                i64 add = 0;
                i64 mask = base - 1;
                auto& digits = _setting::BigNumberSetting::labels();
                for (int i = 0, j = 0;;) {
                    if (j < t) {
                        if (i < n) add += ((i64)_data[i] << j);
                        else if (add == 0) break;
                        j += bit;
                        i++;
                    }
                    res.push_back(add & mask);
                    add >>= t;
                    j -= t;
                } 
                while(res.size() > 1 && res.back() == 0) res.pop_back();
                if (res.size() == 1 && res.back() == 0) return "0";
                std::ostringstream oss;
                if (_is_negative) oss << '-';
                for (int i = res.size() - 1; i >= 0; i--) oss << digits[res[i]];
                return oss.str();
            }

            static BigIntBase __get_out_base_pow(int out_base, int p) {
                static std::vector<BigIntBase> out_base_pow;
                static int origin_base = -1;
                if (origin_base!= out_base) {
                    origin_base = out_base;
                    out_base_pow.clear();
                    BigIntBase base;
                    base.set_radix(out_base);
                    base.set_value(1);
                    out_base_pow.emplace_back(base);
                }
                if (out_base_pow.size() > p && out_base_pow[p]!= 0) return out_base_pow[p];
                else if (out_base_pow.size() <= p ) out_base_pow.resize(p + 1);
                BigIntBase result, mul;
                result.set_radix(out_base);
                result.set_value(1);
                mul.set_radix(out_base);
                mul.set_value(COMPRESS_MOD);
                int add = 1;
                int sum = 0;
                while (p) {
                    if (p & 1) {
                        result *= mul;
                        sum |= add;
                        out_base_pow[sum] = result;
                    }
                    mul *= mul;
                    p >>= 1;
                    add <<= 1;
                    if (add <= _setting::vector_limit) {
                        if (add >= out_base_pow.size()) out_base_pow.resize(add + 1);
                        out_base_pow[add] = mul;
                    }
                }
                out_base_pow[p] = result;
                return out_base_pow[p];
            }

            BigIntBase transbase(int out_base) const {
                if (size() <= 8) {
                    BigIntBase sum, base, own_base, mul, t;
                    sum.set_radix(out_base);
                    base.set_radix(out_base);
                    own_base.set_radix(out_base);
                    mul.set_radix(out_base);
                    t.set_radix(out_base);
                    own_base.set_value(COMPRESS_MOD);
                    base.set_value(1);
                    for (int i = 0; i < size(); i++) {
                        t.set_value(_data[i]);
                        mul = base * t;
                        sum += mul;
                        base *= own_base;
                    }
                    return sum;
                } else {
                    int mid = size() / 2;
                    BigInt low = BigInt(*this);
                    low._data.resize(mid);
                    BigInt high = BigInt(*this);
                    auto& hdata = high._data;
                    hdata.assign(hdata.begin() + mid, hdata.end());
                    auto low_res = low.transbase(out_base);
                    auto high_res = high.transbase(out_base);
                    return high_res * __get_out_base_pow(out_base, mid) + low_res;
                }
            }

            std::string __to_string(int base) const {
                auto sum = transbase(base);
                std::vector<int> res;
                i64 add = 0;
                int n = sum.size();
                int d = sum.digits();
                auto& data = sum.data_ref();
                for (int i = 0, j = 0;;) {
                    if (j < 1) {
                        if (i < n) add += data[i];
                        else if (add == 0) break;
                        j += d;
                        i++;
                    }
                    res.push_back(add % base);
                    add /= base;
                    j--;
                }
                while(res.size() > 1 && res.back() == 0) res.pop_back();
                if (res.size() == 1 && res.back() == 0) return "0";
                std::ostringstream oss;
                if (_is_negative) oss << '-';
                auto& digits = _setting::BigNumberSetting::labels();
                for (int i = res.size() - 1; i >= 0; i--) oss << digits[res[i]];
                return oss.str();
            }

            std::string __default_to_str(int base) const {
                int out_base;
                if (base == -1) out_base = _in_out_base == -1 ? 10 : _in_out_base;
                else out_base = base;
                _setting::CharSetCheck::enable_base(out_base);
                _setting::CharSetCheck::enable_default_write();
                if (__is_zero()) return "0";
                if (BigInt::__is_pow2(out_base)) return __to_string_pow2(out_base);
                else return __to_string(out_base);
            }

            void __default_output(std::ostream& os) const {
                os << __default_to_str(_in_out_base == -1 ? 10 : _in_out_base);
            }

            int __calculate_limit(int base) {
                int cut = __base();
                int limit = 0;
                while(cut >= base) {
                    cut /= base;
                    limit++;
                }
                return limit;
            }

            int __calculate_pow2(int base) const {
                int x = 0;
                while(base % 2 == 0) {
                    base >>= 1;
                    x++;
                }
                return x;
            }

            void __default_input(std::istream& is) {
                std::string s;
                is >> s;
                from_str(s, _in_out_base);
            }

            template <typename T1, typename T2, typename T3>
            void __carry(T1& add, T2& basic_val, T3 new_val) {
                add += (T1)new_val;
                basic_val = (add & COMPRESS_MASK);
                add = (add >> COMPRESS_BIT);
            } 

            template <typename T1, typename T2, typename T3>
            void __borrow(T1& add, T2& basic_val, T3 new_val) {
                add += (T1)new_val;
                basic_val = (add & COMPRESS_MASK);
                add = (add >> COMPRESS_BIT);
            }

            i32 __base() const { return COMPRESS_MOD; }
            i32 __radix() const { return 2; }
            i32 __digits() const { return COMPRESS_BIT; }

            void __copy_status(const BigInt& other) {
                _in_out_base =  other._in_out_base;
            }
        };
    } // namespace math
} // namespace generator

#endif // !_SGPCET_BIG_INT_H_
#ifndef _SGPCET_WORKFLOW_H_
#define _SGPCET_WORKFLOW_H_

#ifndef _SGPCET_INPUT_H_
#include "input.h"
#endif // !_SGPCET_INPUT_H_
#ifndef _SGPCET_OUTPUT_H_
#include "output.h" 
#endif // !_SGPCET_OUTPUT_H_
#ifndef _SGPCET_VALIDATE_H_
#include "validate.h"
#endif // !_SGPCET_VALIDATE_H_
#ifndef _SGPCET_CHECKER_H_
#include "checker.h"
#endif // !_SGPCET_CHECKER_H_
#ifndef _SGPCET_COMPARE_H_
#include "compare.h"
#endif // !_SGPCET_COMPARE_H_
#ifndef _SGPCET_HACK_H_
#include "hack.h"
#endif // !_SGPCET_HACK_H_

namespace generator {
    namespace io {
        class Workflow : public _Reporter {
        protected:
            using Name = std::string;
            using TestCase = std::pair<Name, int>;
            using Time = int;

            std::map<Name, _Program*> _programs;
            Name _std;
            Name _checker;
            Name _validator;
            
            _Input _input;
            std::map<Name, _Hack> _hacks;
            struct _CompareCase {
                int _start, _end;
                _Program* _program;

                _CompareCase(_Program* program) : _start(_setting::_auto_int), _end(_setting::_auto_int), _program(program) {}

                _CompareCase(int start, int end, _Program* program) : _start(start), _end(end), _program(program) {}

            };

            std::vector<_CompareCase> _compares;

            Time _time_limit;
            Time _time_limit_for_std;
            Time _time_limit_for_generator;
            Time _time_limit_for_checker;
            Time _time_limit_for_validator;

            bool _delete_fail_testcase;

            // output
            bool _cover_exist;

            // hack
            bool _copy_wrong_to_testcase;
            bool _delete_correct;

            // log
            bool _detail_report_on_console;
            bool _detail_report_on_file;
            _msg::OutStream _file;

            enum class State {
                UNKNOWN,
                GEN_FAIL,
                VAL_FAIL,
                STD_TLE,
                STD_RE,
                SUCCESS
            };

            std::map<int, State> _states;
        public:
            Workflow(int time_limit = _setting::time_limit_inf) :
                _Reporter(),
                _std(_setting::_empty_program_name),
                _checker(""),
                _validator(_setting::_empty_program_name),
                _input(),
                _time_limit(time_limit),
                _time_limit_for_std(_setting::time_limit_inf),
                _time_limit_for_generator(_setting::time_limit_inf),
                _time_limit_for_checker(_setting::time_limit_inf),
                _time_limit_for_validator(_setting::time_limit_inf),
                _delete_fail_testcase(true),
                _cover_exist(true),
                _copy_wrong_to_testcase(true),
                _delete_correct(true),
                _detail_report_on_console(false),
                _detail_report_on_file(true),
                _file(Path("./summary.log"))
            {
                init_gen();
                set_checker(_enum::Checker::lcmp);
            }
            
            ~Workflow() {
                for (auto& name : _programs) {
                    if (name.second != nullptr) delete name.second;
                }
            }

            _GET_VALUE(Name, std)
            _GET_VALUE(Name, checker)
            _GET_VALUE(Name, validator)
            _SET_GET_VALUE(Time, time_limit)
            _SET_GET_VALUE(Time, time_limit_for_std)
            _SET_GET_VALUE(Time, time_limit_for_generator)
            _SET_GET_VALUE(Time, time_limit_for_checker)
            _SET_GET_VALUE(Time, time_limit_for_validator)
            _SET_GET_VALUE(bool, delete_fail_testcase)
            _SET_GET_VALUE(bool, cover_exist)
            _SET_GET_VALUE(bool, copy_wrong_to_testcase)
            _SET_GET_VALUE(bool, delete_correct)
            _SET_GET_VALUE(bool, detail_report_on_console)
            _SET_GET_VALUE(bool, detail_report_on_file)

            template<typename T>
            void add_program(T&& program) {
                __add_program(std::forward<T>(program));
            }

            template<typename N, typename T>
            typename std::enable_if<std::is_convertible<N, std::string>::value, void>::type
            add_program(N&& name, T&& program) {
                __add_program(std::string(std::forward<N>(name)), std::forward<T>(program));
            }

            template<typename T>
            void set_std(T&& std) {
                _Program* program = __find_program(std::forward<T>(std));
                _std = program->name();
            }

            template<typename N, typename T>
            typename std::enable_if<std::is_convertible<N, std::string>::value, void>::type
            set_std(N&& name, T&& std) {
                _Program* program = __add_program(std::string(std::forward<N>(name)), std::forward<T>(std));
                _std = program->name();
            }

            template<typename T>
            void set_checker(T&& checker) {
                _Program* program = __find_program(std::forward<T>(checker));
                _checker = program->name();
            }

            template<typename N, typename T>
            typename std::enable_if<std::is_convertible<N, std::string>::value, void>::type
            set_checker(N&& name, T&& checker) {
                _Program* program = __add_program(std::string(std::forward<N>(name)), std::forward<T>(checker));
                _checker = program->name();
            }

            template<typename T>
            void set_validator(T&& validator) {
                _Program* program = __find_program(std::forward<T>(validator));
                _validator = program->name();
            }

            template<typename N, typename T>
            typename std::enable_if<std::is_convertible<N, std::string>::value, void>::type
            set_validator(N&& name, T&& validator) {
                _Program* program = __add_program(std::string(std::forward<N>(name)), std::forward<T>(validator));
                _validator = program->name();
            }

            template<typename T>
            void make_inputs(int start, int end, T&& program) {
                __make_inputs(start, end, std::forward<T>(program));
            }

            template<typename T>
            void make_inputs(int index, T&& program) {
                __make_inputs(index, index, std::forward<T>(program));
            }

            template<typename T>
            void fill_inputs(int sum, T&& program) {
                __fill_inputs(sum, std::forward<T>(program));
            }

            template<typename T>
            void fill_inputs(T&& program) {
                __fill_inputs(1, std::forward<T>(program));
            }

            template<typename...Args>
            void compare(Args&&... args) {
                __add_compare(std::forward<Args>(args)...);
            }

            template<typename G, typename T>
            void hack(G&& generator, T&& program, int max_try = 100, bool stop_when_wrong = true, int start_index = _setting::_auto_int) {
                _Program *g = __find_program(std::forward<G>(generator));
                _Program *p = __find_program(std::forward<T>(program));
                if (start_index == _setting::_auto_int) 
                    _hacks[g->name()].__add_comparer(p, max_try, stop_when_wrong);
                else
                    _hacks[g->name()].__add_comparer(p, max_try, start_index, stop_when_wrong);
            }

            void run() {
                __begin_summary_report();
                if (!__check_requires()) return;
                __generate_inputs();
                __validate();
                __generate_outputs();
                __clean_failed_testcase();
                __hack();
                __compare();
                _msg::__info_msg(_msg::_defl, tools::string_format("Report is in file %s", Path(_file.path()).full_path().cname()));
            }

        protected:
            void __check_program_valid(const Name& name, _Program* p) {
                if (!p->__check_program_valid()) {
                    _msg::__fail_msg(_msg::_defl, tools::string_format("program %s is not valid", name.c_str()));
                }
            }

            template<typename T>
            typename std::enable_if<!IsDefaultChecker<T>::value, _Program*>::type
            __add_program(const Name& name, T&& program) {
                _Program* p = __program(std::forward<T>(program));
                __check_program_valid(name, p);
                if (_programs.find(name) != _programs.end()) delete _programs[name];
                p->set_name(name);
                _programs[name] = p;
                return p;
            }

            template<typename T>
            typename std::enable_if<IsDefaultChecker<T>::value, _Program*>::type
            __add_program(const Name& name, T&& program) {
                _Program* p = __checker_program(std::forward<T>(program));
                __check_program_valid(name, p);
                if (_programs.find(name) != _programs.end()) delete _programs[name];
                p->set_name(name);
                _programs[name] = p;
                return p;
            }

            template<typename T>
            typename std::enable_if<!IsDefaultChecker<T>::value, _Program*>::type
            __add_program(T&& program) {
                _Program* p = __program(std::forward<T>(program));
                Name name = p->name();
                __check_program_valid(name, p);
                if (_programs.find(name) != _programs.end()) delete _programs[name];
                _programs[name] = p;
                return p;
            }

            template<typename T>
            typename std::enable_if<IsDefaultChecker<T>::value, _Program*>::type
            __add_program(T&& program) {
                _Program* p = __checker_program(std::forward<T>(program));
                Name name = p->name();
                __check_program_valid(name, p);
                if (_programs.find(name) != _programs.end()) delete _programs[name];
                _programs[name] = p;
                return p;
            }

            _Program* __find_program_by_name(const Name& name) {
                if (_programs.find(name) == _programs.end()) return nullptr;
                return _programs[name];
            }

            template<typename T>
            typename std::enable_if<IsDefaultChecker<T>::value, _Program*>::type
            __find_program(T&& index) {
                _Program* p = __find_program_by_name(checker_name[index]);
                if (p != nullptr) return p;
                p = __checker_program(std::forward<T>(index));
                return __add_program(p);
            }

            template<typename T>
            typename std::enable_if<std::is_convertible<T, std::string>::value, _Program*>::type
            __find_program(T&& name) {
                _Program* p = __find_program_by_name(std::string(name));
                if (p != nullptr) return p;
                return __add_program(std::forward<T>(name));
            }
            
            template<typename T>
            typename std::enable_if<!IsDefaultChecker<T>::value && !std::is_convertible<T, std::string>::value, _Program*>::type
            __find_program(T&& name) {
                return __add_program(std::forward<T>(name));
            }

            template<typename T>
            void __make_inputs(int start, int end, T&& program) {
                _Program* p = __find_program(std::forward<T>(program));
                for (int i = start; i <= end; i++)
                    _input.__add_input(i, p);
            }

            template<typename T>
            void __fill_inputs(int count, T&& program) {
                _Program* p = __find_program(std::forward<T>(program));
                _input.__fill_input(count, p, true);
            }

            void __add_compare() {}

            template<typename T, typename... Args>
            typename std::enable_if<
                IsProgramConstructible<T>::value &&
                ArgsAllTrue<IsProgramConstructible<Args>::value...>::value, 
                void>::type
            __add_compare(T&& program, Args&&... args) {
                _Program* p = __find_program(std::forward<T>(program));
                _compares.push_back(_CompareCase(p));
                __add_compare(std::forward<Args>(args)...);
            }

            void __add_compare(int, int) {}

            template<typename T, typename... Args>
            typename std::enable_if<
                IsProgramConstructible<T>::value &&
                ArgsAllTrue<IsProgramConstructible<Args>::value...>::value, 
                void>::type
            __add_compare(int start, int end, T&& program, Args&&... args) {
                _Program* p = __find_program(std::forward<T>(program));
                _compares.push_back(_CompareCase(start, end, p));
                __add_compare(start, end, std::forward<Args>(args)...);
            }

            template<typename T, typename... Args>
            typename std::enable_if<
                IsProgramConstructible<T>::value,
                void>::type
            __add_compare(int start, int end, T&& program, int next_start, int next_end, Args&&... args) {
                _Program* p = __find_program(std::forward<T>(program));
                _compares.push_back(_CompareCase(start, end, p));
                __add_compare(next_start, next_end, std::forward<Args>(args)...);
            }

            std::string __time_format(int time) {
                if (time == _setting::time_limit_inf) return "inf";
                return tools::string_format("%dms", time);
            }

            void __report_program(_msg::OutStream& out, const Name& name, const Name& stage_name) {
                if (name == _setting::_empty_program_name) 
                    _msg::__info_msg(out, tools::string_format("  No %s", stage_name.c_str()));
                else 
                    _msg::__info_msg(out, tools::string_format("  %s name : %s", stage_name.c_str(), name.c_str()));
            }

            std::string __bool_format(bool b) {
                return b ? "true" : "false";
            }

            void __begin_summary_report(_msg::OutStream& out, bool detail, bool console) {
                if (!detail) {
                    if (console) _msg::__info_msg(out, "Start Workflow :");
                    _msg::__info_msg(out, tools::string_format("  Programs Count : %d", _programs.size()));
                }
                else {
                    _Table table(out);
                    table.add_titles({"Program Name", "Path"});
                    int count = 1;
                    for (auto& p : _programs) {
                        table.add_cell(0, count, p.first);
                        table.add_cell(1, count, p.second->__path_or_func());
                        count++;
                    }
                    table.draw();
                    __report_program(out, _std, "Standard Program");
                    __report_program(out, _checker, "Checker");
                    __report_program(out, _validator, "Validator");                    
                }
                _msg::__info_msg(out, tools::string_format("  Test Cases Count : %d", _input.__size()));
                int hack_size = 0;
                for (auto& h : _hacks) hack_size += h.second.__size();  
                _msg::__info_msg(out, tools::string_format("  Hack Programs Count : %d", hack_size));
                _msg::__info_msg(out, tools::string_format("  Compare Programs Count : %d", _compares.size()));
                _msg::__info_msg(out, "  Time Limit:");
                _msg::__info_msg(out, tools::string_format("    std       : %s", __time_format(_time_limit_for_std).c_str()));
                _msg::__info_msg(out, tools::string_format("    compare   : %s / %s", 
                    __time_format(_time_limit).c_str(), __time_format(__time_limit_extend(_time_limit)).c_str()));
                _msg::__info_msg(out, tools::string_format("    hack user : %s", __time_format(_time_limit).c_str()));
                _msg::__info_msg(out, tools::string_format("    generator : %s", __time_format(_time_limit_for_generator).c_str()));
                _msg::__info_msg(out, tools::string_format("    validator : %s", __time_format(_time_limit_for_validator).c_str()));
                _msg::__info_msg(out, tools::string_format("    checker   : %s", __time_format(_time_limit_for_checker).c_str()));
                if (detail) {
                    _msg::__info_msg(out, "  Setting :");
                    _msg::__info_msg(out, tools::string_format("    delete fail testcase          : %s", __bool_format(_delete_fail_testcase).c_str()));
                    _msg::__info_msg(out, tools::string_format("    (output) cover exist          : %s", __bool_format(_cover_exist).c_str()));
                    _msg::__info_msg(out, tools::string_format("    (hack) copy wrong to testcase : %s", __bool_format(_copy_wrong_to_testcase).c_str()));
                    _msg::__info_msg(out, tools::string_format("    (hack) delete correct         : %s", __bool_format(_delete_correct).c_str()));
                    _msg::__info_msg(out, tools::string_format("    detail report on console      : %s", __bool_format(_detail_report_on_console).c_str()));
                    _msg::__info_msg(out, tools::string_format("    detail report on file         : %s", __bool_format(_detail_report_on_file).c_str()));
                }
                
            }

            void __begin_summary_report() {
                __begin_summary_report(_msg::_defl, _detail_report_on_console, true);
                __begin_summary_report(_file, _detail_report_on_file, false);
                _msg::__endl(_file);
            }

            void __info_msg(const std::string& msg) {
                _msg::__info_msg(_msg::_defl, msg);
                _msg::__info_msg(_file, msg);
            }

            void __warn_msg(const std::string& msg) {
                _msg::__warn_msg(_msg::_defl, msg);
                _msg::__warn_msg(_file, msg);
            }

            bool __check_requires() {
                if (_input.__empty()) {
                    __info_msg("No Generator.");
                    return false;
                }
                if (_std == _setting::_empty_program_name) {
                    __info_msg("No Standard Program.");
                    return false;
                }
                if ((!_hacks.empty() || ! _compares.empty()) &&
                    _checker == _setting::_empty_program_name) {
                    __info_msg("No Checker.");
                    return false;
                }
                return true;
            }

            void __generate_inputs() {
                _input.set_time_limit(_time_limit_for_generator);
                _input.__run();
                if (_detail_report_on_console) _input.__detail_summary(_msg::_defl);
                else _input.__short_summary(_msg::_defl);
                _msg::__info_msg(_file, "Generate(Inputs) :");
                if (_detail_report_on_file) _input.__detail_summary(_file);
                else _input.__short_summary(_file);
                _msg::__endl(_file);
                auto states = _input.states();
                for (auto& s : states) {
                    if (!__is_success(s.second.exit_code)) _states[s.first] = State::GEN_FAIL;
                    else _states[s.first] = State::SUCCESS;
                }
            }

            void __validate() {
                if (_validator == _setting::_empty_program_name) {
                    __warn_msg("You'd better have a Validator to ensure the generated testcases are valid.");
                    return;
                }
                _Validate validator;
                validator.__set_validator(__find_program(_validator));
                validator.set_time_limit(_time_limit_for_validator);
                for (auto& s : _states) {
                    if (s.second == State::SUCCESS) validator.__add_validate(s.first);
                }
                validator.__run();
                if (_detail_report_on_console) validator.__detail_summary(_msg::_defl);
                else validator.__short_summary(_msg::_defl);
                _msg::__info_msg(_file, "Validate :");
                if (_detail_report_on_file) validator.__detail_summary(_file);
                else validator.__short_summary(_file);
                _msg::__endl(_file);
                auto states = validator.states();
                for (auto& s : states) {
                    if (!__is_success(s.second.exit_code)) _states[s.first] = State::VAL_FAIL;
                }
            }

            void __generate_outputs() {
                _Output output;
                output.__set_std(__find_program(_std));
                output.set_cover_exist(_cover_exist);
                output.set_time_limit(_time_limit_for_std);
                for (auto& s : _states) {
                    if (s.second == State::SUCCESS) output.__add_output(s.first);
                }
                output.__run();
                if (_detail_report_on_console) output.__detail_summary(_msg::_defl);
                else output.__short_summary(_msg::_defl);
                _msg::__info_msg(_file, "Generate(Outputs) :");
                if (_detail_report_on_file) output.__detail_summary(_file);
                else output.__short_summary(_file);
                _msg::__endl(_file);
                auto states = output.states();
                for (auto& s : states) {
                    if (!__is_success(s.second.exit_code)) _states[s.first] = State::STD_RE;
                    if (__time_limit_exceed(s.second.time, _time_limit_for_std)) _states[s.first] = State::STD_TLE;
                }
            }

            void __clean_failed_testcase() {
                if (!_delete_fail_testcase) return;
                for (auto& s : _states) {
                    if (s.second != State::SUCCESS) {
                        Path input = __testcase_input_file_path(s.first);
                        Path output = __testcase_output_file_path(s.first);
                        input.__delete_file();
                        output.__delete_file();
                    }
                }
            }

            void __hack() {
                if (_hacks.empty()) return;
                _msg::__info_msg(_file, "Hack :");
                int count = 1;
                for (auto& h : _hacks) {
                    _Hack& hack = h.second;
                    if (hack.__empty()) continue;
                    hack.set_time_limit(_time_limit);
                    hack.__set_generator(__find_program(h.first));
                    hack.set_time_limit_for_generator(_time_limit_for_generator);
                    hack.__set_std(__find_program(_std));
                    hack.set_time_limit_for_std(_time_limit_for_std);
                    hack.__set_checker(__find_program(_checker));
                    hack.set_time_limit_for_checker(_time_limit_for_checker);
                    hack.__set_validator(__find_program(_validator));
                    hack.set_time_limit_for_validator(_time_limit_for_validator);
                    if (_validator != _setting::_empty_program_name) {
                        hack.__set_validator(__find_program(_validator));
                        hack.set_time_limit_for_validator(_time_limit_for_validator);
                    }
                    hack.set_copy_wrong_to_testcase(_copy_wrong_to_testcase);
                    hack.set_delete_correct(_delete_correct);
                    hack.set_sub_folder_name(hack.generator()->name());
                    hack.__hack();
                    if (_detail_report_on_console) hack.__detail_summary(_msg::_defl);
                    else hack.__short_summary(_msg::_defl);
                    if (_detail_report_on_file) hack.__detail_summary(_file);
                    else hack.__short_summary(_file);
                    count++;
                }         
                _msg::__endl(_file);
            }

            void __compare() {
                if (_compares.empty()) return;
                _Compare compare;
                compare.set_time_limit(_time_limit);
                compare.__set_checker(__find_program(_checker));
                compare.set_time_limit_for_checker(_time_limit_for_checker);
                for (auto& c : _compares) {
                    if (c._start == _setting::_auto_int && c._end == _setting::_auto_int) 
                        compare.__add_testcase(c._program);
                    else
                        compare.__add_testcase(c._program, c._start, c._end);
                }
                compare.__compare();
                if (_detail_report_on_console) compare.__detail_summary(_msg::_defl);
                else compare.__short_summary(_msg::_defl);
                _msg::__info_msg(_file, "Compare :");
                if (_detail_report_on_file) compare.__detail_summary(_file);
                else compare.__short_summary(_file);
                _msg::__endl(_file);
            }

        };
    } // namespace io
} // namespace generator

#endif // _SGPCET_WORKFLOW_H_
#ifndef _SGPCET_INCLUDE_ALL_H_
#define _SGPCET_INCLUDE_ALL_H_

#ifndef _SGPCET_COMMON_H_
#include "basic/common.h"
#endif // !_SGPCET_COMMON_H_

#ifndef _SGPCET_SETTING_H_
#include "basic/setting.h"
#endif // !_SGPCET_SETTING_H_
#ifndef _SGPCET_TOOLS_H_
#include "basic/tools.h"
#endif // !_SGPCET_TOOLS_H_
#ifndef _SGPCET_ENUM_H_
#include "basic/enum.h"
#endif // !_SGPCET_ENUM_H_
#ifndef _SGPCET_MACRO_H_
#include "basic/macro.h"
#endif // !_SGPCET_MACRO_H_

#ifndef _SGPCET_COLOR_H_
#include "log/color.h"
#endif // !_SGPCET_COLOR_H_
#ifndef _SGPCET_LOGGER_H_
#include "log/logger.h"
#endif // !_SGPCET_LOGGER_H_

#ifndef _SGPCET_GEN_STRATEGY_H_
#include "basic/gen_strategy.h"
#endif // !_SGPCET_GEN_STRATEGY_H_

#ifndef _SGPCET_PATH_H_
#include "io/path.h"
#endif // !_SGPCET_PATH_H_
#ifndef _SGPCET_FILE_H_
#include "io/file.h"
#endif // !_SGPCET_FILE_H_
#ifndef _SGPCET_PROGRAM_H_
#include "io/program.h"
#endif // !_SGPCET_PROGRAM_H_
#ifndef _SGPCET_COMMAND_PATH_H_
#include "io/command_path.h"
#endif // !_SGPCET_COMMAND_PATH_H_
#ifndef _SGPCET_COMMAND_FUNC_H_
#include "io/command_func.h"
#endif // !_SGPCET_COMMAND_FUNC_H_
#ifndef _SGPCET_IO_INIT_H_
#include "io/io_init.h"
#endif // !_SGPCET_IO_INIT_H_
#ifndef _SGPCET_REPORTER_H_
#include "io/reporter.h"
#endif // !_SGPCET_REPORTER_H_
#ifndef _SGPCET_INPUT_H_
#include "io/input.h"
#endif // !_SGPCET_INPUT_H_
#ifndef _SGPCET_OUTPUT_H_
#include "io/output.h" 
#endif // !_SGPCET_OUTPUT_H_
#ifndef _SGPCET_VALIDATE_H_
#include "io/validate.h"
#endif // !_SGPCET_VALIDATE_H_
#ifndef _SGPCET_CHECKER_H_
#include "io/checker.h"
#endif // !_SGPCET_CHECKER_H_
#ifndef _SGPCET_COMPARE_H_
#include "io/compare.h"
#endif // !_SGPCET_COMPARE_H_
#ifndef _SGPCET_HACK_H_
#include "io/hack.h"
#endif // !_SGPCET_HACK_H_
#ifndef _SGPCET_WORKFLOW_H_
#include "io/workflow.h"
#endif // !_SGPCET_WORKFLOW_H_

#ifndef _SGPCET_NTT_H_
#include "math/ntt.h"
#endif //!_SGPCET_NTT_H_
#ifndef _SGPCET_BIG_INT_CALCULATOR_H_
#include "math/big_int_calculator.h"
#endif //!_SGPCET_BIG_INT_CALCULATOR_H_
#ifndef _SGPCET_BIG_INT_BASE_H_
#include "math/big_int_base.h"
#endif //!_SGPCET_BIG_INT_BASE_H_
#ifndef _SGPCET_CHAR_SET_CHECK_H_
#include "math/char_set_check.h"
#endif //!_SGPCET_CHAR_SET_CHECK_H_
#ifndef _SGPCET_BIG_INT_H_
#include "math/big_int.h"
#endif //!_SGPCET_BIG_INT_H_

#ifndef _SGPCET_NUMBER_CONST_H_
#include "rand/number_const.h"
#endif // !_SGPCET_NUMBER_CONST_H_
#ifndef _SGPCET_NUMBER_FORMAT_H_
#include "rand/number_format.h"
#endif // !_SGPCET_NUMBER_FORMAT_H_
#ifndef _SGPCET_NUMERIC_H_
#include "rand/numeric.h"
#endif // !_SGPCET_NUMERIC_H_
#ifndef _SGPCET_ARRAY_H_
#include "rand/array.h"
#endif // !_SGPCET_ARRAY_H_
#ifndef _SGPCET_DISTRIBUTION_H_
#include "rand/distribution.h"
#endif // !_SGPCET_DISTRIBUTION_H_

#ifndef _SGPCET_EDGE_H_
#include "graph/edge.h"
#endif // !_SGPCET_EDGE_H_
#ifndef _SGPCET_NODE_H_
#include "graph/node.h"
#endif // !_SGPCET_NODE_H_
#ifndef _SGPCET_BASIC_TREE_GRAPH_H_
#include "graph/basic_tree_graph.h"
#endif // !_SGPCET_BASIC_TREE_GRAPH_H_
#ifndef _SGPCET_WEIGHT_TYPE_H_
#include "graph/weight_type.h"
#endif // !_SGPCET_WEIGHT_TYPE_H_
#ifndef _SGPCET_GEN_FUNCTION_H_
#include "graph/gen_function.h"
#endif // !_SGPCET_GEN_FUNCTION_H_
#ifndef _SGPCET_LINK_FORWARD_H_
#include "graph/link_forward.h"
#endif // !_SGPCET_LINK_FORWARD_H_
#ifndef _SGPCET_TREE_STRATEGY_H_
#include "graph/tree_strategy.h"
#endif // !_SGPCET_TREE_STRATEGY_H_
#ifndef _SGPCET_GEN_TREE_H_
#include "graph/gen_tree.h"
#endif // !_SGPCET_GEN_TREE_H_
#ifndef _SGPCET_GRAPH_STRATEGY_H_
#include "graph/graph_strategy.h"
#endif // !_SGPCET_GRAPH_STRATEGY_H_
#ifndef _SGPCET_GEN_GRAPH_H_
#include "graph/gen_graph.h"
#endif // !_SGPCET_GEN_GRAPH_H_
#ifndef _SGPCET_ALL_TREE_GRAPH_H_
#include "graph/all_tree_graph.h"
#endif // !_SGPCET_ALL_TREE_GRAPH_H_
#ifndef _SGPCET_UNWEIGHT_H_
#include "graph/unweight.h"
#endif // !_SGPCET_UNWEIGHT_H_
#ifndef _SGPCET_NODE_WEIGHT_H_
#include "graph/node_weight.h"
#endif // !_SGPCET_NODE_WEIGHT_H_
#ifndef _SGPCET_EDGE_WEIGHT_H_
#include "graph/edge_weight.h"
#endif // !_SGPCET_EDGE_WEIGHT_H_
#ifndef _SGPCET_BOTH_WEIGHT_H_
#include "graph/both_weight.h"
#endif // !_SGPCET_BOTH_WEIGHT_H_

#ifndef _SGPCET_GEOMETRY_BASIC_H_
#include "geometry/geometry_basic.h"
#endif //!_SGPCET_GEOMETRY_BASIC_H_
#ifndef _SGPCET_RANGE_FORMAT_H_
#include "geometry/range_format.h"
#endif //!_SGPCET_RANGE_FORMAT_H_
#ifndef _SGPCET_GEOMETRY_STRATEGY_H_
#include "geometry/geometry_strategy.h"
#endif //!_SGPCET_GEOMETRY_STRATEGY_H_
#ifndef _SGPCET_COORDINATE_H_
#include "geometry/coordinate.h"
#endif //!_SGPCET_COORDINATE_H_
#ifndef _SGPCET_POINT_H_
#include "geometry/point.h"
#endif //!_SGPCET_POINT_H_
#ifndef _SGPCET_POINTS_H_
#include "geometry/points.h"
#endif //!_SGPCET_POINTS_H_
#ifndef _SGPCET_LINE_SEGMENT_H_
#include "geometry/line_segment.h"
#endif //!_SGPCET_LINE_SEGMENT_H_
#ifndef _SGPCET_GEOMETRY_ALGORITHM_H_
#include "geometry/geometry_algorithm.h"
#endif //!_SGPCET_GEOMETRY_ALGORITHM_H_
#ifndef _SGPCET_CONVEX_HULL_H_
#include "geometry/convex_hull.h"
#endif //!_SGPCET_CONVEX_HULL_H_
#ifndef _SGPCET_TRIANGLE_H_
#include "geometry/triangle.h"
#endif //!_SGPCET_TRIANGLE_H_
#ifndef _SGPCET_SIMPLE_POLYGON_H_
#include "geometry/simple_polygon.h"
#endif //!_SGPCET_SIMPLE_POLYGON_H_

namespace generator {
  namespace all {
    using namespace generator::tools;
    using namespace generator::_msg;
    using namespace generator::_setting;
    using namespace generator::_enum;
    using namespace generator::io;
    using namespace generator::math;
    using namespace generator::rand_numeric;
    using namespace generator::rand_array;
    using namespace generator::rand_graph;
    using namespace generator::rand_geometry;
  } // namespace all
} // namespace generator

#ifdef _SGPCET_MACRO_H_
#undef _GET_VALUE_CONST
#undef _GET_VALUE_REF
#undef _GET_VALUE
#undef _SET_VALUE
#undef _SET_GET_VALUE
#undef _OUTPUT_FUNCTION
#undef _OUTPUT_FUNCTION_SETTING
#undef _DEF_GEN_FUNCTION
#undef _CONTEXT_V
#undef _CONTEXT_V_REF
#undef _CONTEXT_GET
#undef _CONTEXT_GET_REF
#undef _MUST_IS_ROOTED
#undef _DEFAULT_GRAPH_GEN_FUNC
#undef _DEFAULT_GEOMETRY_GEN_FUNC
#undef _DEFAULT_OUTPUT
#undef _DEFAULT_GEN
#undef _TREE_GRAPH_DEFAULT
#undef _GEOMETRY_DEFAULT
#undef _DISABLE_NODE_COUNT
#undef _DISABLE_EDGE_COUNT
#undef _DISABLE_DIRECTION
#undef _DISABLE_MULTIPLY_EDGE
#undef _DISABLE_SELF_LOOP
#undef _DISABLE_CONNECT
#undef _GEOMETRY_IN_RAND_FUNC
#undef _GEOMETRY_OUT_RAND_FUNC
#undef _DISABLE_SAME_POINT
#endif // _SGPCET_MACRO_H_

#endif // !_SGPCET_INCLUDE_ALL_H_
#endif // _SGPCET_ 
        